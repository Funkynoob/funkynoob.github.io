<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>redis</title>
    <link href="/2024/03/18/redis/"/>
    <url>/2024/03/18/redis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="持久化"><a class="markdownIt-Anchor" href="#持久化">#</a> 持久化</h1><p><code>redis</code>  提供了持久化策略， <code>redis</code>  会将内存中的数据持久化到磁盘中存储避免了断电之后，内存中的数据消失。当再次重启  <code>redis</code>  服务器后， <code>redis</code>  会读取磁盘文件加载进内存，将数据恢复至之前的状态。</p><p><code>redis</code>  提供了四种持久化策略：</p><ul><li><strong> <code>RDB</code> </strong> ( <code>Redis Database</code> ): 使用该策略， <code>redis</code>  会为数据库的数据在指定的时间间隔中生成一份时间点快照。</li><li><strong> <code>AOF</code> </strong> (Append Only File): 使用该策略， <code>redis</code>  会记录每次服务器收到的<strong>写</strong>的操作。这些操作会在服务器启动的时候重新运行以便能够重新构建起原始的数据库。这些<strong>写</strong>操作会按照  <code>redis</code>  的协议以同样的格式被日志记录</li><li><strong> <code>No persistence</code> </strong>: 你可以完全禁用持久化。这有时候是在缓存的时候使用。</li><li><strong> <code>RDB + AOF</code> </strong>: 你也可以在在同一次运行中结合使用  <code>AOF</code>  和  <code>RDB</code>  两种策略</li></ul><h2 id="rdb"><a class="markdownIt-Anchor" href="#rdb">#</a> RDB</h2><p>实现类似照片记录效果的方式，就是把某一时刻的数据和状态以文件的形式写到磁盘上，也就是快照。这样一来即使故障宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为  <code>RDB</code>  文件 (文件名默认为： <code>dump.rdb</code> )，其中， <code>RDB</code>  就是  <code>Redis DataBase</code>  的缩写。</p><p>当服务器再次重启后，服务器将会读取这个快照文件，恢复整个数据集。</p><h3 id="如何开启rdb"><a class="markdownIt-Anchor" href="#如何开启rdb">#</a> 如何开启 RDB</h3><p>进入  <code>redis</code>  配置文件，大概在  <code>418</code>  行，你将会看到如下的话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">################################ SNAPSHOTTING  ################################<br><br># Save the DB to disk.<br>#<br><span class="hljs-meta"># save <span class="hljs-string">&lt;seconds&gt;</span> <span class="hljs-string">&lt;changes&gt;</span> [<span class="hljs-string">&lt;seconds&gt;</span> <span class="hljs-string">&lt;changes&gt;</span> ...]</span><br>#<br># Redis will save the DB <span class="hljs-keyword">if</span> the given number of seconds elapsed and it<br><span class="hljs-meta"># surpassed the given number of write operations against the DB.</span><br>#<br># Snapshotting can be completely disabled with a single empty <span class="hljs-built_in">string</span> argument<br><span class="hljs-meta"># as in following example:</span><br><span class="hljs-meta"># save <span class="hljs-string">&quot;&quot;</span></span><br><br>#<br># Unless specified otherwise, by <span class="hljs-keyword">default</span> Redis will save the DB:<br>#   * After <span class="hljs-number">3600</span> seconds (an hour) <span class="hljs-keyword">if</span> at least <span class="hljs-number">1</span> change was performed<br>#   * After <span class="hljs-number">300</span> seconds (<span class="hljs-number">5</span> minutes) <span class="hljs-keyword">if</span> at least <span class="hljs-number">100</span> changes were performed<br>#   * After <span class="hljs-number">60</span> seconds <span class="hljs-keyword">if</span> at least <span class="hljs-number">10000</span> changes were performed<br>#<br></code></pre></td></tr></table></figure><p>原来  <code>redis</code>  默认已经开启了  <code>RDB</code>  且遵守以下策略：</p><ul><li>在 60 秒之后，如果至少有 10000 次改变被执行</li><li>在 5 分钟之后，如果至少有 100 次变化被执行</li><li>在 1 小时之后，如果至少有 1 次变化被执行</li></ul><p>如果上面的规定至少有一个被遵守， <code>redis</code>  将会自动触发  <code>RDB</code>  持久化，为此刻的数据生成快照，然后将其保存在为以  <code>rdb</code>  为后缀的二进制文件，文件名默认为 <code>dump.rdb</code> 。</p><p>你可以以如下的形式重载  <code>redis</code>  默认的  <code>RDB</code>  持久化规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">save &lt;seconds&gt; &lt;changes&gt; [&lt;seconds&gt; &lt;changes&gt; ...]<br></code></pre></td></tr></table></figure><p><code>redis</code>  会当  <code>&lt;seconds&gt;</code>  秒消逝，并且累计的  <code>&lt;changes&gt;</code>  个数的写操作被执行后，自动保存数据库。</p><blockquote><p>注意是在每个时间区间内，一旦写操作<strong>累积</strong>到了设定的数就会触发</p></blockquote><h3 id="禁用rdb"><a class="markdownIt-Anchor" href="#禁用rdb">#</a> 禁用 RDB</h3><p>在配置文件中可以使用一个简单的配置来禁用  <code>RDB</code>  持久化策略，在  <code>redis</code>  中有以下描述：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"># Snapshotting can be completely disabled <span class="hljs-keyword">with</span> a single empty string argument<br># <span class="hljs-keyword">as</span> <span class="hljs-keyword">in</span> following example:<br>快照化可以用下面的例子，使用单个空的字符串参数来完全禁用：<br># save <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="配置rdb"><a class="markdownIt-Anchor" href="#配置rdb">#</a> 配置 RDB</h3><p>如何更改默认文件名，来到配置文件的大概  <code>481</code>  行：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># The filename where to dump the DB</span><br><span class="hljs-attribute">dbfilename</span> dump.rdb<br></code></pre></td></tr></table></figure><p>你可以通过更改  <code>dbfilename</code>  的值来修改  <code>RDB</code>  文件的名字。</p><p>如何更改文件存储路径，来到配置文件的大概  <code>502</code>  行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment"># The working directory.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The DB will be written inside this directory, with the filename specified</span><br><span class="hljs-comment"># above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The Append Only File will also be created inside this directory.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that you must specify a directory here, not a file name.</span><br><span class="hljs-built_in">dir</span> ./<br></code></pre></td></tr></table></figure><p>你可以通过修改  <code>dir</code>  的值来修改  <code>RDB</code>  的存储路径。</p><h3 id="手动保存"><a class="markdownIt-Anchor" href="#手动保存">#</a> 手动保存</h3><p><code>redis</code>   提供了两个命令来手动保存  <code>RDB</code>  文件： <code>save</code>  ， <code>bgsave</code>  。</p><p><code>save</code>  以同步的方式执行保存操作，会阻塞进程。</p><p><code>bgsave</code>  以异步的方式执行保存操作，不会阻塞进程</p><p>当你运行上述命令时，会为当前  <code>redis</code>   实例中的所有数据生成一个以  <code>RDB</code>  文件的格式的快照。</p><p>你绝对不应该在生产环境中使用  <code>save</code>   命令，当你运行该命令时，会阻塞所有客户端的请求，服务器将不再接受所有客户端的请求，直到保存操作结束。</p><p>实际上， <code>redis</code>  的自动保存正是调用的  <code>bgsave</code></p><blockquote><p>在生产环境中必须使用  <code>bgsave</code></p></blockquote><h3 id="rdb的优点"><a class="markdownIt-Anchor" href="#rdb的优点">#</a> RDB 的优点</h3><ul><li><code>RDB</code>  是一个非常紧凑的单时间点代表  <code>Redis</code>  数据的单文件。 <code>RDB</code>  文件非常适合于备份。举个例子，你可能想每个小时归档你的  <code>RDB</code>  文件，或者每天保存一次  <code>RDB</code>  快照。这样允许你非常轻松的恢复不同版本的数据以防灾难的发生。</li><li><code>RDB</code>  非常适合于灾难性的数据恢复，因为单文件的结构可以被运输至远程的数据中心。</li><li><code>RDB</code>  最大化  <code>redis</code>  的功能，因为  <code>redis</code>  的父进程为了完成持久化的唯一的工作就是  <code>fork</code>  子进程，然后剩余的工作都交给子进程。父进程并不会执行  <code>I/O</code>  操作。</li><li>对比  <code>AOF</code> ， <code>RDB</code>  在大数据的情况下，能够进行快速重启。</li></ul><h3 id="rdb的缺点"><a class="markdownIt-Anchor" href="#rdb的缺点">#</a> RDB 的缺点</h3><ul><li><p><code>RDB</code>  不是一个好选择，如果你想减少数据丢失的可能性以防  <code>redis</code>  异常的停止工作。你可以配置不同的  <code>RDB</code>  创建的时间点。然而，你会经常每 5 分钟或者更久的时间创建一个  <code>RDB</code>   快照，所以在   <code>redis</code>   没有正常进行  <code>shutdown</code>  的莫名情况停止工作的情况下，你应该准备好丢失最新几分钟的数据</p></li><li><p><code> RDB</code>  需要经常调用  <code>fork()</code>  以使用子进程进行持久化。 <code>fork()</code>  有时会很消耗时间，如果数据库的我数据很大的话，并且如果数据很大，且  <code>cpu</code>  的性能不是很好，将会导致  <code>redis</code>  在几微秒甚至 1 秒的时间停止服务客户端。 <code>AOF</code>  也会使用  <code>fork()</code>  但是不会如此频繁，并且你也可以自定义重新写入日志的频率且不用担心任何耐用性的损失。</p></li></ul><h3 id="数据检查"><a class="markdownIt-Anchor" href="#数据检查">#</a> 数据检查</h3><p><code>redis</code>  提供了一个工具用来检查  <code>RDB</code>   文件的格式是否正确：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis－check－rdb &lt;/path/to/rdb/file&gt;<br></code></pre></td></tr></table></figure><p>如果  <code>RDB</code>  文件损坏，该命令能检查出来。如果加载坏的  <code>RDB</code>  文件，那么  <code>redis</code>  客户端将无法执行命令，会弹出  <code>not connected</code>  字样</p><h2 id="aof"><a class="markdownIt-Anchor" href="#aof">#</a> AOF</h2><p>快照不总是耐用的。如果你的计算机上的正在运行的  <code>redis</code>  停止了、断电了、或者你意外地使用  <code>kill －9</code>   杀死了你的实例，最新写入  <code>redis</code>  的数据将会丢失。</p><p><code>AOF</code>  是  <code>RDB</code>  的一个更充满耐用性的替代品。在  <code>1.1</code>  版本开始了使用。</p><p><code>AOF</code>  以日志的形式记录每一次 ** 写操作，** 且不记录任何形式的读操作。当服务器重新启动的时候会读取日志记录，重新执行以构建原来的数据。</p><h3 id="开启aof"><a class="markdownIt-Anchor" href="#开启aof">#</a> 开启 AOF</h3><p><code>redis</code>  没有默认开启  <code>AOF</code>  ，需要手动开启。</p><p>进入配置文件，大概  <code>1381</code>  行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># AOF and RDB persistence can be enabled at the same time without problems.</span><br><br><span class="hljs-comment"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><br><span class="hljs-comment"># with the better durability guarantees.</span><br><br><span class="hljs-comment">#</span><br><br><span class="hljs-comment"># Please check https://redis.io/topics/persistence for more information.</span><br><br>appendonly <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><p>将  <code>appendonly</code>  的值改为  <code>yes</code>  则代表开启了 <code>AOF</code>  。</p><p>由文档注释可知，如果你开启了  <code>AOF</code>  ，那么每次服务器启动的时候就只会加载  <code>AOF</code>  文件，不管是否开启了  <code>RDB</code>  持久化。</p><h3 id="aof文件"><a class="markdownIt-Anchor" href="#aof文件">#</a> AOF 文件</h3><p>自  <code>redis 7.0.0</code>  开始， <code>redis</code>  使用<strong>多部分  <code>AOF</code>  机制</strong>。这是什么呢？原始的单  <code>AOF</code>  文件被分割为：</p><p><code>base</code>  文件 (最多只有一个)：它是在创建文件时表示数据集完整状态的快照，可以为  <code>RDB</code>  或者  <code>AOF</code>  格式</p><p><code>incremental</code>  文件 (可能会有多个)：包含额外的被应用在数据库的跟随旧文件的命令</p><p>这两个文件会被放进一个分离的路径且会被  <code>manifest</code>  文件追踪。</p><h4 id="文件存放位置"><a class="markdownIt-Anchor" href="#文件存放位置">#</a> 文件存放位置</h4><p>上述三种文件的存放位置，同样可以由配置文件进行配置，在配置文件大概  <code>1404</code>  行：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># Append-only file names are created by Redis following a specific pattern.</span><br><span class="hljs-comment"># The file name&#x27;s prefix is based on the &#x27;appendfilename&#x27; configuration</span><br><span class="hljs-comment"># parameter, followed by additional information about the sequence and type.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For example, if appendfilename is set to appendonly.aof, the following file</span><br><span class="hljs-comment"># names could be derived:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># - appendonly.aof.1.base.rdb as a base file.</span><br><span class="hljs-comment"># - appendonly.aof.1.incr.aof, appendonly.aof.2.incr.aof as incremental files.</span><br><span class="hljs-comment"># - appendonly.aof.manifest as a manifest file.</span><br><br><span class="hljs-attribute">appendfilename</span> <span class="hljs-string">&quot;appendonly.aof&quot;</span><br><br><span class="hljs-comment"># For convenience, Redis stores all persistent append-only files in a dedicated</span><br><span class="hljs-comment"># directory. The name of the directory is determined by the appenddirname</span><br><span class="hljs-comment"># configuration parameter.</span><br><br>appenddirname <span class="hljs-string">&quot;appendonlydir&quot;</span><br></code></pre></td></tr></table></figure><p>根据注释我们可以知道， <code>AOF</code>  文件名字遵守一个格式：由  <code>appendfilename</code>  的值为前缀，随后更随着序列号和类型，默认的名字为：</p><ul><li><code>appendonly.aof.1.base.rdb</code> ： <code>base</code>  文件</li><li><code>appendonly.aof.1.incr.aof</code> ,  <code>appendonly.aof.2.incr.aof</code> ： <code>increment</code>  文件</li><li><code>appendonly.aof.manifest</code> ： <code>manifest</code>  文件</li></ul><p>每次进行写回后， <code>AOF</code>  文件的序列号将会进行增加，开始序号为 1。</p><ul><li><p>修改  <code>appendfilename</code>  值来修改文件名的前缀</p></li><li><p>修改  <code>appenddirname</code>  的值来修改存放路径。</p></li></ul><p>注意在  <code>redis 7</code>  之后  <code>AOF</code>  文件的存放路径由  <code>dir</code>  +  <code>appenddirname</code>  一起决定，即会在  <code>RDB</code>  文件的存放路径中，放一个隔离的  <code>appenddirname</code>  的目录来存放  <code>AOF</code>  文件</p><h3 id="写回策略"><a class="markdownIt-Anchor" href="#写回策略">#</a> 写回策略</h3><p><code>redis</code>  支持三种写回策略：</p><ul><li><p><code>Always</code> ：同步写回，每个写命令执行完立刻同步地将日志写回磁盘。这个策略会导致服务器非常非常的慢，当很多客户端同时请求时，客户端将会不得不等待服务器一条命令一条命令写回后再进行回复，但该策略也会很安全。</p></li><li><p><code>everysec</code> ：每秒写回，每个写命令执行完，只是先把日志写到  <code>AOF</code>  文件的内存缓冲区，每隔  <code>1</code>  秒把缓冲区中的内容写入磁盘。该策略已经足够快了，但是你可能会丢失 1 秒的数据如果服务器宕机了的话。</p></li><li><p><code>no</code> ：操作系统控制的写回，每个写命令执行完，只是先把日志写到  <code>AOF</code>  文件的内存缓冲区，由操作系统决定何时将缓冲区的数据写回磁盘。该此略会更快，但会很不安全。通常， <code>linux</code>  会每 30 秒将数据写回磁盘，但这取决于内核。</p></li></ul><p>我们进入配置文件，大概 1448 行：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># appendfsync always</span><br><span class="hljs-attribute">appendfsync</span> everysec<br><span class="hljs-comment"># appendfsync no</span><br></code></pre></td></tr></table></figure><p>我们可以通过修改  <code>appendfsync</code>  的值来修改写回策略，根据配置文件我们可以了解到  <code>redis</code>  默认且推荐的策略是  <code>everysec</code>  ，该策略兼具速度并且相对的安全。</p><h3 id="日志重写"><a class="markdownIt-Anchor" href="#日志重写">#</a> 日志重写</h3><p><code>AOF</code>  会随着写操作的次数而变得越来越大。举个例子，如果你增加了一个计数器 100 次，你会都得到一个包含了最终值的键，但是 100 次操作全部进入了你的  <code>AOF</code>  文件，而其他 99 个操作不需要参入重建现在状态的过程。</p><p>重写是完全安全的。当  <code>Redis</code>  继续追加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪， <code>Redis</code>  就会切换这两个文件并开始追加到新文件。</p><p>所以  <code>Redis</code>  支持一个有趣的功能：它能够在后台重建 AOF 而不中断对客户端的服务。每当您发出  <code>BGREWRITEAOF</code>  命令时， <code>Redis</code>  都会写入在内存中重建当前数据集所需的最短命令序列。 如果您在  <code>Redis 2.2</code>  中使用  <code>AOF</code> ，则需要时不时地运行  <code>BGREWRITEAOF</code> 。因为自从  <code>Redis 2.4</code>  开始才能够自动触发日志重写。</p><p>从  <code>Redis 7.0.0</code>  开始，当计划进行  <code>AOF</code>  重写时， <code>Redis</code>  父进程会打开一个新的增量  <code>AOF</code>  文件来继续写入。子进程执行重写逻辑并生成新的  <code>base AOF</code> 。 <code>Redis</code>  将使用临时清单文件来跟踪新生成的基础文件和增量文件。 当它们准备好时， <code>Redis</code>  将执行原子替换操作以使这个临时清单文件生效。为了避免  <code>AOF</code>  重写重复失败和重试时创建大量增量文件的问题， <code>Redis</code>  引入了  <code>AOF</code>  重写限制机制，以确保失败的  <code>AOF</code>  重写以越来越慢的速度重试。</p><p>既然说到  <code>Redis 2.4</code>  以上地版本会自动进行重写，那么如何配置呢，来到配置文件大概 1471 行：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># Automatic rewrite of the append only file.</span><br><span class="hljs-comment"># Redis is able to automatically rewrite the log file implicitly calling</span><br><span class="hljs-comment"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This is how it works: Redis remembers the size of the AOF file after the</span><br><span class="hljs-comment"># latest rewrite (if no rewrite has happened since the restart, the size of</span><br><span class="hljs-comment"># the AOF at startup is used).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This base size is compared to the current size. If the current size is</span><br><span class="hljs-comment"># bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class="hljs-comment"># you need to specify a minimal size for the AOF file to be rewritten, this</span><br><span class="hljs-comment"># is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class="hljs-comment"># is reached but it is still pretty small.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Specify a percentage of zero in order to disable the automatic AOF</span><br><span class="hljs-comment"># rewrite feature.</span><br><br><span class="hljs-attribute">auto</span>-aof-rewrite-percentage <span class="hljs-number">100</span><br><span class="hljs-attribute">auto</span>-aof-rewrite-min-size <span class="hljs-number">64</span>mb<br></code></pre></td></tr></table></figure><p>由注释可知， <code>redis</code>  会自动调用  <code>BGREWRITEAOF</code>  命令当  <code>AOF</code>  文件的大小到达指定的百分比时。 <code>redis</code>  会记住最新一次重写时的文件大小，如果没有发生重写，那么当服务器重启之后的  <code>AOF</code>  文件的大小将会被使用。这个被记住的大小将会被与现在的大小进行比较，如果现在文件的大小超过了指定的百分比，重写将会被触发。并且，你需要指定要重写的  <code>AOF</code>  文件的最小大小，这对于避免重写  <code>AOF</code>  文件很有用，因为即使达到百分比增加但仍然很小。</p><p>指定百分比为 0 可以禁用自动  <code>AOF</code></p><p>现在你可以指定  <code>auto-aof-rewrite-percentage</code>  的值来指定百分比，指定  <code>auto-aof-rewrite-min-size</code>  的值来指定最小的文件大小。</p><h4 id="手动重写"><a class="markdownIt-Anchor" href="#手动重写">#</a> 手动重写</h4><p>你可以主动使用  <code>BGREWRITEAOF</code>  命令来执行重写操作，事实上，自动的重写操作也是由  <code>redis</code>  客户端向  <code>redis</code>  服务器发送这个命令完成的。</p><h3 id="数据检查-2"><a class="markdownIt-Anchor" href="#数据检查-2">#</a> 数据检查</h3><p><code>redis</code>  提供了工具来检查  <code>AOF</code>  文件的格式是否正确：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-check-aof &lt;/path/to/aof&gt;<br></code></pre></td></tr></table></figure><p>如果提示  <code>AOF</code>  文件的格式出错，那么你可以通过添加  <code>--fix</code>  选项来修复该文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-check-aof --fix &lt;/path/to/aof&gt; <br></code></pre></td></tr></table></figure><h2 id="混合模式"><a class="markdownIt-Anchor" href="#混合模式">#</a> 混合模式</h2><p><code>redis</code>  支持  <code>RDB</code>  和  <code>AOF</code>  混合模式。</p><p>如何开启混合模式，来到配置文件大概  <code>1516</code>  行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Redis can create append-only base files in either RDB or AOF formats. Using</span><br><span class="hljs-comment"># the RDB format is always faster and more efficient, and disabling it is only</span><br><span class="hljs-comment"># supported for backward compatibility purposes.</span><br>aof-use-rdb-preamble <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p><code>aof-use-rdb-preamble</code>  用于开启混合模式，可见混合模式是默认开启的，代表着，如果你启用了  <code>RDB</code>  和  <code>AOF</code> ，那么将进入混合模式。</p><h3 id="原理"><a class="markdownIt-Anchor" href="#原理">#</a> 原理</h3><p>当你开启混合模式时，服务器启动时将会进行一次快照存储，然后使用  <code>AOF</code>  记录每一次写操作。当  <code>AOF</code>  达到重写条件时，将会将最新的数据存储为新的  <code>RDB</code>  记录。这样的话，重启服务的时候会从  <code>RDB</code>  和  <code>AOF</code>  两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。简单来说：混合持久化方式产生的文件一部分是  <code>RDB</code>  格式，一部分是  <code>AOF</code>  格式</p><h2 id="no-persistence"><a class="markdownIt-Anchor" href="#no-persistence">#</a> No persistence</h2><p>禁用用  <code>AOF</code>  和  <code>RDB</code>  ，仅仅把  <code>redis</code>  当作缓存来用。</p><h1 id="事务"><a class="markdownIt-Anchor" href="#事务">#</a> 事务</h1><p><code>redis</code>  支持事务。在事务中  <code>redis</code>  允许在一步中运行完所有的命令。整个事务围绕着 4 个命令： <code>exec</code> 、 <code>multi</code> 、 <code>discard</code> 、 <code>watch</code></p><p><code>redis</code>  的事务有两个特点：</p><ul><li>所有在事务中的命令将会被序列化并被顺序执行。在事务执行时其他客户端的请求将不会被处理。这个特点保证了事务中的所有命令将会以一个独立的单步操作的方式执行。</li><li><code>exec</code>  命令会触发事务中命令的执行，所以如果客户端在命令执行前就失去连接，那么事务将不会开始执行。当你使用  <code>AOF</code>  持久化时， <code>redis</code>  在事务执行后会尝试把事务写进文件里。如果  <code>redis</code>  服务器宕机了，那么可能只有一部分的事务命令写入文件。 <code>reids</code>  服务器重新启动的时候会检查  <code>AOF</code>  文件的格式，如果有错误将会退出。可以使用  <code>redis-check-aof</code>  工具尝试移除一部分事务来修复  <code>AOF</code>  文件。</li></ul><h2 id="开启事务"><a class="markdownIt-Anchor" href="#开启事务">#</a> 开启事务</h2><p>使用  <code>multi</code>  命令开启事务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; MULTI<br>OK<br></code></pre></td></tr></table></figure><p>成功开启事务将会以  <code>ok</code>  的形式返回</p><h3 id="序列化命令"><a class="markdownIt-Anchor" href="#序列化命令">#</a> 序列化命令</h3><p>在事务的状态下，输入的所有命令将会以队列的形式进行记忆。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379(TX)&gt; INCR foo<br>QUEUED<br>127.0.0.1:6379(TX)&gt; INCR bar<br>QUEUED<br></code></pre></td></tr></table></figure><p>每次命令的返回值  <code>queued</code>  表示该命令已经加入队列，但此时该命令并没有执行。</p><h3 id="执行命令"><a class="markdownIt-Anchor" href="#执行命令">#</a> 执行命令</h3><p>当完成了所有命令的输入后，使用  <code>exec</code>  命令顺序执行事务中的所有命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379(TX)&gt; EXEC<br>1) (integer) 1<br>2) (integer) 1<br></code></pre></td></tr></table></figure><p>每条命令的结果，将会以一个数组的形式进行返回。</p><h3 id="退出事务"><a class="markdownIt-Anchor" href="#退出事务">#</a> 退出事务</h3><p>在事务的状态下，如果你想退出事务可以使用  <code>discard</code>  进行退出</p><blockquote><p>Note</p><p>在  <code>redis</code>  中不支持回滚，因为回滚会影响  <code>redis</code>  的表现和简单</p></blockquote><h2 id="错误"><a class="markdownIt-Anchor" href="#错误">#</a> 错误</h2><p>在  <code>redis</code>  的事务中有两个可能发生的错误：事务开始前的错误和事务开始后的错误。</p><h3 id="事务开始前"><a class="markdownIt-Anchor" href="#事务开始前">#</a> 事务开始前</h3><p>在事务开始前，也就是正在将命令加入队列时，有些错误将会导致命令无法加入队列中。例如：错误的命令 (命令的参数不对或者命令本身的名字不对)、内存溢出的情况 (如果你配置了服务器的内存限制)。</p><p>如果在事务执行前发生了错误，那么在执行  <code>exec</code>  命令后， <code>redis</code>  将会返回  <code>error</code>  并拒绝执行事务，并退出事务状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; set<br>(error) ERR wrong number of arguments for &#x27;set&#x27; command<br>127.0.0.1:6379(TX)&gt; exec<br>(error) EXECABORT Transaction discarded because of previous errors.<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure><h3 id="事务开始后"><a class="markdownIt-Anchor" href="#事务开始后">#</a> 事务开始后</h3><p>在调用了  <code>exec</code>  命令执行事务后，如果某些命令执行发生了错误比如：让一个字符串进行自增，那么该命令将会返回  <code>error</code>  ，但这并不会影响其他的命令的执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379(TX)&gt; incr k1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; incr k<br>QUEUED<br>127.0.0.1:6379(TX)&gt; exec<br>1) (error) ERR value is not an integer or out of range<br>2) (integer) 4<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure><blockquote><p>上述结果得知： <code>redis</code>  的事务并没有原子性</p></blockquote><h2 id="乐观锁"><a class="markdownIt-Anchor" href="#乐观锁">#</a> 乐观锁</h2><p><code>redis</code>  使用  <code>watch</code>  命令来实现乐观锁。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">watch &lt;key&gt; [key...]<br></code></pre></td></tr></table></figure><p>通过  <code>watch</code>  监控键，如果在命令入队时，该键的值发生了改变，那么事务不会执行，当你调用  <code>exec</code>  后，事务将返回  <code>nil</code>  并退出事务状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; get k #k当前的值发生了改变<br>&quot;4&quot;<br>127.0.0.1:6379&gt; watch k #监控k<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; incr k #此时，另一个客户端修改了k的值为5<br>QUEUED<br>127.0.0.1:6379(TX)&gt; set k1 qweasd<br>QUEUED<br>127.0.0.1:6379(TX)&gt; exec #执行事务后，发现返回nil<br>(nil)<br>127.0.0.1:6379&gt; get k1 #发现所有键的值都没有被事务所修改<br>&quot;hello&quot;<br>127.0.0.1:6379&gt; get k<br>&quot;5&quot;<br></code></pre></td></tr></table></figure><p>如果你在监控了某个键后，不想再监控了，可以使用  <code>unwatch</code>  命令来取消监控。该命令没有任何参数，将会取消监控所有的键。</p><h1 id="管道"><a class="markdownIt-Anchor" href="#管道">#</a> 管道</h1><p><code>Redis</code>  是一种基于<strong>客户端 - 服务端模型</strong>以及<strong>请求 / 响应协议</strong>的 TCP 服务。一个请求会遵循以下步骤：</p><ol><li>客户端向服务端发送命令分四步 (发送命令→命令排队→命令执行→返回结果)，并监听  <code>Socket</code>  返回，通常以阻塞模式等待服务端响应。</li><li>服务端处理命令，并将结果返回给客户端。</li></ol><p>如果同时需要执行大量的命令，那么就要等待上一条命令应答后再执行，这中间不仅仅多了<strong> RTT（Round Time Trip）</strong>，而且还频繁调用系统 IO，发送网络请求，同时需要  <code>redis</code>  调用多次  <code>read()</code>  和  <code>write()</code>  系统方法，系统方法会将数据从<strong>用户态</strong>转移到<strong>内核态</strong>，这样就会对进程上下文有比较大的影响了，性能不太好。</p><p>管道用来优化客户端和服务端的<strong>网络时延 (RTT)</strong>。</p><p><code>管道(pipeline)</code>  可以一次性发送多条命令给服务端，服务端依次处理完完毕后，通过一条响应一次性将结果返回，通过减少客户端与  <code>redis</code>  的通信次数来实现降低往返延时时间。 <code>pipeline</code>  实现的原理是队列，先进先出特性就保证数据的顺序性。</p><h1 id="主从复制"><a class="markdownIt-Anchor" href="#主从复制">#</a> 主从复制</h1><p><code>redis</code>  提供一个主从复制机制。<strong>主 (master) 库</strong> 能够进行读写，<strong>从 (slave) 库</strong> 只能读。当  <code>master</code>  数据变化的时候，自动将新的数据异步同步到其它  <code>slave</code>  数据库，保证主从之间的数据保持一致性。</p><h2 id="配置"><a class="markdownIt-Anchor" href="#配置">#</a> 配置</h2><p>通过修改从库的配置，标识从库要复制的是哪个主库。前往配置文件大概 553 行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># replicaof <span class="hljs-string">&lt;masterip&gt;</span> <span class="hljs-string">&lt;masterport&gt;</span></span><br></code></pre></td></tr></table></figure><p>通过配置  <code>relicaof</code>  的参数  <code>masterip</code>  主库的  <code>ip</code>  ， <code>masterport</code>  主库的端口</p><p>如果主库被设置了密码，那么需要修改另一个配置，前往配置文件大概 554 行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># masterauth <span class="hljs-string">&lt;master-password&gt;</span></span><br></code></pre></td></tr></table></figure><p>通过配置  <code>masterauth</code>  的参数  <code>master-password</code>  指明主库的密码，从而能被验证通过。</p><p>除上述配置之外，主库的配置文件不需要任何修改。</p><h2 id="连接主库"><a class="markdownIt-Anchor" href="#连接主库">#</a> 连接主库</h2><p>我们使用一个主库，然后再使用两个从库。使整个架构呈现出：一个主库下面挂着三个从库的状态。</p><p>假设我们的主库的套接字为：172.17.0.2:6376。从库的套接字为：172.17.0.3:6377、172.17.0.4:6378。密码都为：12345</p><p>所以从库的配置文件呈现如下情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">172.17.0.3:6377</span><br>replicaof 172.0.2 6376<br>masterauth 12345<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">172.17.0.4:6378</span><br>replicaof 172.0.2 6376<br>masterauth 12345<br></code></pre></td></tr></table></figure><p>为了更好的观察运行情况，我们对上述三个库，继续修改如下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">以下配置路径均可以自定义</span><br>dir /usr/local/etc/redis #设置工作目录<br>log /usr/local/etc/redis/redis.log #设置日志路径<br>pid /usr/local/etc/redis/redis.pid #设置pid文件路径<br>appendonly no #关闭AOF持久化，可关可不关<br></code></pre></td></tr></table></figure><p>配置完成后，我们首先启动主库，观察之前配置的日志文件，如果出现以下日志，说明启动成功：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Ready to <span class="hljs-keyword">accept</span> connections tcp<br></code></pre></td></tr></table></figure><p>随后，我们启动剩余两个从库，从库启动成功后会尝试连接主库，出现以下日志说明连接成功：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Connecting <span class="hljs-keyword">to</span> MASTER <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>:<span class="hljs-number">6376</span><br>MASTER &lt;-&gt; <span class="hljs-keyword">REPLICA</span> sync started<br></code></pre></td></tr></table></figure><p>如果你想查看当前  <code>redis</code>  实例的主从状态，可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">info replication<br></code></pre></td></tr></table></figure><p>该命令会显示当前  <code>redis</code>  实例处于的主从状态，如果是主库，那么也会显示当前主库挂载了哪些从库。</p><h3 id="手动配置"><a class="markdownIt-Anchor" href="#手动配置">#</a> 手动配置</h3><p>上面的配置均基于配置文件，在  <code>redis</code>  服务启动后，也可以手动配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">slaveof &lt;masterip&gt; &lt;masterport&gt;<br></code></pre></td></tr></table></figure><p><code>slaveof</code>  命令对标  <code>replicaof</code>  配置。可以在运行时进行配置。</p><blockquote><p>注意：如果主库仍然含有密码，仍需要在配置文件中配置  <code>masterauth</code></p></blockquote><p>如果，你想要在运行时让从库变为主库同样可以使用  <code>slaveof</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">slaveof no one<br></code></pre></td></tr></table></figure><blockquote><p>注意手动配置仅仅在当此运行中有效，重新启动服务后，任然会使用配置文件的配置</p></blockquote><h2 id="同步"><a class="markdownIt-Anchor" href="#同步">#</a> 同步</h2><p>尝试在主库中写入一些键，观察从库的状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6376&gt; set k1 v1 #我们在从库中设置一个数据<br>OK <br>127.0.0.3:6377&gt; get k1 #切换至从库，获取改键，发现能够获取，且值和主库中的对应<br>&quot;v1&quot;<br><br>127.0.0.3:6377&gt; set k2 v2 #尝试在从库中进行写入，发现报错无法写入<br>(error) READONLY You can&#x27;t write against a read only replica.<br></code></pre></td></tr></table></figure><blockquote><p>从库没有写入的权力</p></blockquote><p>如果运行时，主库宕机了怎么办？我们尝试  <code>shutdown</code>  主库，观察从库的日志：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Connecting <span class="hljs-keyword">to</span> MASTER <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>:<span class="hljs-number">6376</span><br>MASTER &lt;-&gt; <span class="hljs-keyword">REPLICA</span> sync started<br>Error condition <span class="hljs-keyword">on</span> socket <span class="hljs-keyword">for</span> SYNC: <span class="hljs-keyword">Connection</span> refused<br></code></pre></td></tr></table></figure><p>你会看到一场串的上面的内容，代表着当主库宕机后，从库其实一直在尝试连接主库。意味着，从库在主库宕机后选择发呆，什么事也不干，<strong>也不会从从库变为主库</strong>，只是一味请求连接主库。同时如果你在从库查看数据，同步之后的数据任然存在。</p><p>那此时的主库重启后仍然为主库吗？答案是，仍然是！</p><p>如果从库宕机后，我们持续向主库中写入数据，从库再次启动后能否同步到主库的新数据？答案是也会！</p><h3 id="同步链"><a class="markdownIt-Anchor" href="#同步链">#</a> 同步链</h3><p>上一个  <code>slave</code>  可以是下一个  <code>slave</code>  的  <code>master</code> ,  <code>slave</code>  同样可以接收其他  <code>slave</code>  的连接和同步请求，那么该  <code>slave</code>  作为了链条中下一个的  <code>master</code> , 可以有效减轻主  <code>master</code>  的写压力形成同步链。</p><p>可以在配置文件中直接配置  <code>replicaof</code>  或者在运行中使用  <code>slaveof</code>  来暂时设置。</p><h3 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2">#</a> 原理</h3><ol><li>当主从库连接良好时，主库会向从库发送命令流来同步由于以下原因导致主库数据集发生改变的影响</li></ol><ul><li>客户端写入</li><li>键过期或者删除</li><li>更改主库数据集的任何其他操作，例如： <code>flushdb</code></li></ul><ol start="2"><li><p>当主从库因为网络问题或者命令流发送超时导致连接丢失后，从库会进行重连并尝试进行部分的重新同步：意味着从库会尝试获取一部分它在失去连接中丢失的命令流</p></li><li><p>当部分重新同步不可能时， <code>slave</code>  将请求完全重新同步，其中主服务器需要创建所有的数据快照，将其发送到从库，然后在数据集发生变化时继续发送命令流。</p></li></ol><p>每个主库都有一个 复制 ID ，这是一个超大伪随机的字符串用来标记一个给定数据集的状况。每个主库也拥有一个发送给从库且随着复制流字节增长的偏移量，使用主库的改变用来更新从库的状态。主库的偏移量在从库没有连接时也存在，下面给出的就是主库数据集版本的标识。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Replication</span> ID, <span class="hljs-keyword">offset</span><br></code></pre></td></tr></table></figure><p>当从库连接至主库后，从库会使用  <code>PSYNC</code>  命令用来发送他的旧主库的复制 ID 以及最近处理的的偏移量。这样主设备就可以只发送所需的增量部分。但是，如果主库缓冲区没有足够的  <code>backlog</code>  或者从库正在参考的是一个历史的从来不知道的复制 ID，然后就会发生全量的重新同步：在这个情况下，从库会获得全量的数据集的复制。</p><p>全量的重新同步的细节如下：</p><p>主库会启动一个后台保存进程生产  <code>RDB</code>  文件。同一时间，主库会开始缓存所有新收到的写命令。当后台保存完成后，主库会将数据库文件传输给从库，然后从库会将文件保存在硬盘上之后将它加载进内存。然后主库会发送所有缓存的命令到从库。这是以命令流的形式发送的。</p><p>主库会使用心跳机制，默认每 10s 钟和从库进行通信保持长连接。</p><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点">#</a> 缺点</h2><p>由于所有的写操作都是先在  <code>Master</code>  上操作，然后同步更新到  <code>Slave</code>  上，所以从  <code>Master</code>  同步到  <code>Slave</code>  机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重， <code>Slave</code>  机器数量的增加也会使这个问题更加严重。</p><p>默认情况下，当  <code>master</code>  宕机后，不会在引  <code>slave</code>  节点中自动重选一个  <code>master</code> ，这意味着，你无法进行写入。</p><h1 id="哨兵"><a class="markdownIt-Anchor" href="#哨兵">#</a> 哨兵</h1><p>为了解决主从复制的痛点 ——  <code>master</code>  宕机后， <code>slave</code>  中并不会产生一个  <code>master</code>  来进行写入。吹哨人巡查监控后台  <code>master</code>  主机是否故障，如果故障了根据投票数自动将某一个从库转换为新主库，继续对外服务。</p> <img src="redis/sentinel.png" alt="哨兵架构" style="zoom: 50%;" /><blockquote><p>哨兵是在非集群状态下使用的</p></blockquote><p>以下是哨兵提供的一系列功能：</p><ul><li><strong>监控</strong>：哨兵能持续不断地检查  <code>master</code>  和  <code>slave</code>  是否如期运行</li><li><strong>通知</strong>：哨兵能通过  <code>API</code>  通知系统管理员，或者其他电脑程序，某一个被监控的  <code>redis</code>  实例出问题了</li><li><strong>自动的故障转移</strong>：如果  <code>master</code>  宕机了，哨兵会开始故障转移进程，将  <code>slave</code>  提拔为  <code>master</code>  ，其他的额外的  <code>slave</code>  将会被<strong>重新配置</strong>以使用新的  <code>master</code>  ，并且使用  <code>reids</code>  服务器的应用程序会在连接中被通知使用新的地址</li><li><strong>配置提供者</strong>：哨兵充当客户端服务发现的权威来源，客户端连接到哨兵以询问负责给定服务的  <code>master</code>  的地址。如果发生故障转移，哨兵将报告新地址。</li></ul><blockquote><p>哨兵在进行故障转移时，会动态的修改配置文件</p></blockquote><h2 id="哨兵架构"><a class="markdownIt-Anchor" href="#哨兵架构">#</a> 哨兵架构</h2><p><code>reids</code>  的哨兵是<strong>分布式系统</strong>。哨兵被设计来以<strong>多个哨兵进程共同合作</strong>的配置运行。这样的好处有如下：</p><ol><li>当多个哨兵都认同某个给定的  <code>master</code>  已经宕机，那么故障检测将会被执行。这降低了<strong>假阳性</strong>的可能性，也就是误判  <code>master</code>  宕机。</li><li>在所有的哨兵进程没有完全停止工作时哨兵也能发挥作用，这提高了对抗故障的<strong>健壮性</strong></li></ol><blockquote><p>哨兵、 <code>Redis</code>  实例（ <code>master</code>  和  <code>slave</code> ）以及连接到哨兵 和  <code>Redis</code>  的客户端的总和，也是一个具有特定属性的更大的分布式系统</p></blockquote><h2 id="如何运行哨兵实例"><a class="markdownIt-Anchor" href="#如何运行哨兵实例">#</a> 如何运行哨兵实例</h2><p>你可以使用  <code>redis</code>  提供的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-sentinel /path/to/sentinel.conf<br></code></pre></td></tr></table></figure><p>也可以同样使用  <code>redis-server</code>  命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-server /path/to/sentinel.conf --sentinel<br></code></pre></td></tr></table></figure><p>哨兵被<strong>强制使用配置文件</strong>，无法默认运行，因为该文件会被系统使用，用来保存当前的状态，并且会在重新启动时被重新加载。如果没有给出配置文件或者配置文件路径不可写，哨兵将简单地拒绝启动。</p><p>哨兵运行<strong>默认监听端口 26379</strong>，所以为了保证能够运行，必须让你的服务器打开<strong> 26379 端口</strong>。否则，哨兵们将不能交流并且也无法就该做什么达成一致，所以故障转义将不会被执行。</p><h3 id="配置哨兵文件"><a class="markdownIt-Anchor" href="#配置哨兵文件">#</a> 配置哨兵文件</h3><p><code>Redis</code>  源代码发行版包含一个名为  <code>Sentinel.conf</code>  的文件，它是一个自记录示例配置文件，可用于配置  <code>Sentinel</code> ，但是典型的最小配置文件如下所示：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs smali">sentinel<span class="hljs-built_in"> monitor </span>mymaster 127.0.0.1 6379 2<br>sentinel down-after-milliseconds mymaster 60000<br>sentinel failover-timeout mymaster 180000<br>sentinel parallel-syncs mymaster 1<br><br>sentinel<span class="hljs-built_in"> monitor </span>resque 192.168.1.3 6380 4<br>sentinel down-after-milliseconds resque 10000<br>sentinel failover-timeout resque 180000<br>sentinel parallel-syncs resque 5<br></code></pre></td></tr></table></figure><p>您只需要指定要监视的  <code>master</code> ，为每个单独的  <code>master</code> （可能有任意数量的 <code>slave</code> ）提供不同的名称，无需指定  <code>slave</code> ， <code>slave</code>  是自动发现的。 哨兵将使用有关 <code>slave</code>  的附加信息自动更新配置（以便在重新启动时保留信息），每次在故障转移期间将  <code>slave</code>  提升为  <code>master</code>  以及每次发现新的哨兵时，配置也会被重写</p><p>上面的示例配置基本上监视两组  <code>Redis</code>  实例，每个实例由一个主实例和未定义数量的  <code>slave</code>  组成。一组实例称为  <code>mymaster</code> ，另一组实例称为  <code>resque</code></p><p><code>sentinel monitor</code>  语句的参数含义如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;<br></code></pre></td></tr></table></figure><p>让我们一行一行检查：</p><p>第一行用于告诉  <code>Redis</code>  监视一个名为  <code>mymaster</code>  的主机，该主机位于地址  <code>127.0.0.1</code>  和端口  <code>6379</code> ，投票数 ( <code>quorum</code> ) 为 2。一切都非常明显，但<strong> quorum 参数</strong>除外：</p><ul><li><p>投票数是需要就  <code>master</code>  无法访问这一事实达成一致的哨兵数量，以便真正将主站标记为故障，并在可能的情况下最终启动故障转移过程</p></li><li><p>然而，投票数仅用于检测故障。为了实际执行故障转移，需要选举其中一个哨兵为故障转移的领导者并被授权继续进行。只有大多数哨兵进程投票才会发生这种情况</p></li></ul><p>例如，如果您有 5 个 哨兵进程，并且给定  <code>master</code>  进程的投票数设置为 2，则会发生以下情况：</p><ul><li>如果两个哨兵同时同意主节点无法访问，则两者之一将尝试启动故障转移</li><li>如果总共至少有三个哨兵可达，则故障转移将被授权并实际启动</li></ul><blockquote><p>实际上，这意味着在故障期间，如果大多数哨兵进程无法通信（也称为少数分区中没有故障转移），则哨兵永远不会启动故障转移</p></blockquote><p>除了上述配置之外，其余的哨兵配置遵从与以下格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sentinel &lt;option_name&gt; &lt;master_name&gt; &lt;option_value&gt;<br></code></pre></td></tr></table></figure><ul><li><code>down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</code> ：是当哨兵开始认为实例<strong>主观下线</strong>时，实例不应该可达的时间（要么不回复我们的  <code>PING</code> ，要么回复错误）</li><li><code>parallel-syncs &lt;master-name&gt; &lt;nums&gt;</code> ：设置故障转移后可以重新配置为同时使用新  <code>master</code>  的  <code>slave</code>  数量。数字越低，完成故障转移过程所需的时间越长。</li><li><code>auth-pass &lt;master-name&gt; &lt;password&gt;</code> ： <code>master</code>  设置了密码，连接  <code>master</code>  服务的密码</li></ul><p>其余的可参照实例配置文件： <code>sentinel.conf</code></p><blockquote><p><code>redis</code>  官方建议配置至少三个哨兵</p></blockquote><h2 id="主观下线和客观下线"><a class="markdownIt-Anchor" href="#主观下线和客观下线">#</a> 主观下线和客观下线</h2><p><code>redis</code>  哨兵有两种下下线的判断：客观下线 (ODOWN) 和主观下线 (SDOWN)</p><ul><li>主观下线 (SDOWN)：单独一个哨兵认为  <code>master</code>  已经下线，这种情况由于， <code>master</code>  没有在有效的时间正确回应哨兵的  <code>PING</code>  命令。这个时间在配置文件中是  <code>is-master-down-after-milliseconds</code>  参数。<ul><li>仅仅通过  <code>SDOWN</code>  无法判断  <code>master</code>  是否下线。需要哨兵之间进行投票。</li></ul></li><li>客观下线 (ODOWN)：当哨兵之间的投票数达到之前设定的  <code>quorm</code>  时， <code>master</code>  进入客观下线状态。触发故障转移。</li></ul><h2 id="故障转移流程"><a class="markdownIt-Anchor" href="#故障转移流程">#</a> 故障转移流程</h2><ol><li>主观下线</li><li>客观下线</li><li>选出领导者哨兵：当主节点被判断客观下线以后，各个哨兵节会进行协商，通过  <code>raft</code>  算法 先选举出一个领导者 (leader) 哨兵节点并由该领导者节点，也即被选举出的兵王进行  <code>failover</code>  (故障转移）</li><li>由领导者 (leader) 开始推动故切流程并选出一个新  <code>master</code> ：<ol><li>在剩下的  <code>slave</code>  中选出一个  <code>master</code>  , 从节点选举过程评估从节点的下列信息来选举  <code>master</code> ：<ul><li>与主节点断开的时间</li><li>从节点优先级：由  <code>replica-priority</code>  参数指定，越低的优先级越高，但该参数指定为 0 时，该节点将不会参与选举。</li><li>复制偏移处理：更新的偏移量越优先</li><li>运行 ID</li></ul></li><li>切换剩下的  <code>slave</code>  至新的  <code>master</code> ：<ul><li>执行  <code>slaveof no one</code>  命令让选出来的从节成为新的主节点，并通过  <code>slaveof</code>  命令让其他节点成为其从节点</li><li>会修改  <code>slave</code>  以及  <code>sentinel</code>  的配置文件</li></ul></li></ol></li><li>此时，若旧的  <code>master</code>  重新上线，仍然会成为新选举出来的  <code>master</code>  的  <code>slave</code></li></ol><h1 id="集群"><a class="markdownIt-Anchor" href="#集群">#</a> 集群</h1><h2 id="为什么要使用-redis-集群"><a class="markdownIt-Anchor" href="#为什么要使用-redis-集群">#</a> 为什么要使用 redis 集群</h2><p>使用主从复制 + 哨兵的模式能够很大程度上减轻   <code>redis</code>   的读写压力，但归根结底，此模式仍有不足：</p><ul><li>接受请求的服务器从始至终只有一台   <code>redis</code>  实例，无法适应高并发的场景。</li><li>从节点的上位可能会导致写丢失。</li></ul><h2 id="什么是redis集群"><a class="markdownIt-Anchor" href="#什么是redis集群">#</a> 什么是 redis 集群</h2><p>由于数据量过大，单个   <code>master</code>  复制集难以承担，因此需要对多个复制集进行集群，形成水平扩展每个复制集只负责存储整个数据集的一部分，这就是  <code>Redis</code>  的集群，其作用是提供在多个  <code>Redis</code>  节点间共享数据的程序集。</p><p>形象的图像表示如下图：</p><p><img src="/upload/cluster.png" alt="cluster.png" title="cluster架构"></p><p>当客户端请求来到  <code>redis</code>  服务之后，将会根据规则将请求分散至不同的  <code>redis</code>  实例中，以减少每台服务器的压力。每台   <code>redis</code>  服务器仅仅存储数据集的一部分，且  <code>redis</code>   服务间数据共享。</p><h2 id="如何确定键的落点"><a class="markdownIt-Anchor" href="#如何确定键的落点">#</a> 如何确定键的落点</h2><p><code>redis</code>  通过哈希的方式找到键的落点。下面我们一一介绍常见的哈希方式以及  <code>redis</code>   最终的使用方案。</p><h3 id="普通哈希"><a class="markdownIt-Anchor" href="#普通哈希">#</a> 普通哈希</h3><p>通过简单的哈希函数来确定键的落点。例如，现在我有三个实例：A、B、C 组成了一个集群。那么，可能的哈希函数就可能如下所示：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">RES</span> <span class="hljs-operator">=</span> <span class="hljs-variable">KEY</span> <span class="hljs-operator">%</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>通过键对 3 取余得到键的落点在哪个实例上。这样的方法看似非常简单且稳妥。但实际上却有很大的弊端：当其中某个实例宕机或者新加入一些实例后，哈希函数将会发生改变，之前的键的映射方式将会重新洗牌，将会有大量的键无法映射到对应的  <code>redis</code>   的服务上。</p><h3 id="一致性哈希"><a class="markdownIt-Anchor" href="#一致性哈希">#</a> 一致性哈希</h3><p>一致性哈希是为了解决普通哈希带来的问题 —— 当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系。一致性哈希算法将整个哈希值空间映射成一个虚拟的圆环。整个哈希空间的取值范围为 0~2<sup>32-1，按顺时针方向开始从 0~2</sup>32-1 排列，最后的节点 2^32-1 在 0 开始位置重合，形成一个虚拟的圆环。如下图所示：</p><p><img src="/upload/consistency-hash.png" alt="consistency-hash.png" title="一致性哈希环"></p><h5 id="服务器映射到哈希环"><a class="markdownIt-Anchor" href="#服务器映射到哈希环">#</a> 服务器映射到哈希环</h5><p>接下来，将服务器节点映射到哈希环上对应的位置。我们可以对服务器 IP 地址进行哈希计算，哈希计算后的结果对 2<sup>32 取模，结果一定是一个 0 到 2</sup>32-1 之间的整数。最后将这个整数映射在哈希环上，整数的值就代表了一个服务器节点的在哈希环上的位置。即：hash（服务器 ip）% 2^32。下面我们依次将 node0、node1、node2 三个缓存服务器映射到哈希环上，如下图所示：</p><p><img src="/upload/consistency-hash-node.png" alt="consistency-hash-node.png"></p><h5 id="对象key映射到服务器"><a class="markdownIt-Anchor" href="#对象key映射到服务器">#</a> 对象 key 映射到服务器</h5><p>当服务器接收到数据请求时，首先需要计算请求 Key 的哈希值；然后将计算的哈希值映射到哈希环上的具体位置；接下来，从这个位置沿着哈希环顺时针查找，遇到的第一个节点就是 key 对应的节点；最后，将请求发送到具体的服务器节点执行数据操作。</p><p>假设我们有 “key-01：张三”、“key-02：李四”、“key-03：王五” 三条缓存数据。经过哈希算法计算后，映射到哈希环上的位置如下图所示：</p><p><img src="/upload/consistency-hah-map.png" alt="consistency-hah-map.png"></p><p>如上图所示，通过哈希计算后，key-01 顺时针寻找将找到 node0，key-02 顺时针寻找将找到 node1，key-03 顺时针寻找将找到 node2。最后，请求找到的服务器节点执行具体的业务操作。</p><p>以上便是一致性哈希算法的工作原理。</p><h4 id="服务器扩容缩容"><a class="markdownIt-Anchor" href="#服务器扩容缩容">#</a> 服务器扩容 &amp; 缩容</h4><p>前面介绍了一致性哈希算法的工作原理，那么，一致性哈希算法如何避免服务器动态伸缩的问题的呢？</p><h5 id="服务器缩容"><a class="markdownIt-Anchor" href="#服务器缩容">#</a> 服务器缩容</h5><p>服务器缩容就是减少集群中服务器节点的数量或是集群中某个节点故障。假设，集群中的某个节点故障，原本映射到该节点的请求，会找到哈希环中的下一个节点，数据也同样被重新分配至下一个节点，其它节点的数据和请求不受任何影响。这样就确保节点发生故障时，集群能保持正常稳定。如下图所示：</p><p><img src="/upload/consistency-hash-reduce.png" alt="consistency-hash-reduce.png"></p><p>如上图所示：节点 node2 发生故障时，数据 key-01 和 key-02 不会受到影响，只有 key-03 的请求被重定位到 node0。在一致性哈希算法中，如果某个节点宕机不可用了，那么受影响的数据仅仅是会寻址到此节点和前一节点之间的数据。其他哈希环上的数据不会受到影响。</p><h5 id="服务器扩容"><a class="markdownIt-Anchor" href="#服务器扩容">#</a> 服务器扩容</h5><p>服务器扩容就是集群中需要增加一个新的数据节点，假设，由于需要缓存的数据量太大，必须对集群进行扩容增加一个新的数据节点。此时，只需要计算新节点的哈希值并将新的节点加入到哈希环中，然后将哈希环中从上一个节点到新节点的数据映射到新的数据节点即可。其他节点数据不受影响，具体如下图所示：</p><p><img src="/upload/consistency-hash-scall.png" alt="consistency-hash-scall.png"></p><p>如上图所示，加入新的 node3 节点后，key-01、key-02 不受影响，只有 key-03 的寻址被重定位到新节点 node3，受影响的数据仅仅是会寻址到新节点和前一节点之间的数据。</p><p>通过一致性哈希算法，集群扩容或缩容时，只需要重新定位哈希环空间内的一小部分数据。其他数据保持不变。当节点数越多的时候，使用哈希算法时，需要迁移的数据就越多，使用一致哈希时，需要迁移的数据就越少。所以，一致哈希算法具有较好的容错性和可扩展性。</p><h4 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2">#</a> 缺点</h4><p>一致性哈希也并不是那么完美，它有一个很致命的弱点 —— 数据倾斜。由于哈希计算的随机性，我们无法保证所有的节点都能完美地均匀地分散在哈希环上，特别是在节点太少的情况下，会导致大量的键会集中映射至少量几个节点的情况，造成数据访问的冷热不均，如下图所示：</p><p><img src="/upload/consistency-hash-short.png" alt="consistency-hash-short.png"></p><p>如上图所示，key-1、key-2、key-3 可能被映射到同一个节点 node0 上。导致 node0 负载过大，而 node1 和 node2 却很空闲的情况。这有可能导致个别服务器数据和请求压力过大和崩溃，进而引起集群的崩溃。</p><h3 id="哈希槽"><a class="markdownIt-Anchor" href="#哈希槽">#</a> 哈希槽</h3><p>为了解决一致性哈希的数据倾斜问题， <code>redis</code>  使用了名为<strong>哈希槽</strong>的技术来实现集群。 <code>redis</code>  通过将键映射至<strong>哈希槽</strong>而不是节点来规避底层节点的变动带来的数据问题。使用如下的公式来计算哈希槽：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-type">HASH_SLOT</span> <span class="hljs-operator">=</span> <span class="hljs-variable">CRC16</span><span class="hljs-punctuation">(</span><span class="hljs-variable">key</span><span class="hljs-punctuation">)</span> <span class="hljs-variable">mod</span> <span class="hljs-number">16384</span><br></code></pre></td></tr></table></figure><p>通过  <code>CRC16</code>  算法计算  <code>key</code>  的哈希值，该哈希值总共有 16 位，也就是哈希值的范围为 0~65535。但在  <code>redis</code>  中哈希槽的个数被设定为 0~16383</p><h4 id="分片"><a class="markdownIt-Anchor" href="#分片">#</a> 分片</h4><p>每个节点分配一定数量哈希槽，哈希槽被<strong>分片</strong>至集群中的节点上。也就是每个节点就是哈希槽的<strong>分片</strong>。</p><p>假如，现在我有 A，B，C 三台节点并组成一个集群，三台机器的分片可能如下：</p><ul><li>节点 A 包含哈希槽 0~5500</li><li>节点 B 包含哈希槽 5501 到 11000</li><li>节点 C 包含哈希槽 11001 至 16383</li></ul><p>我们使用上面提到的哈希槽计算公式计算给定键的哈希槽，根据每个节点的分片将其分配至对应的节点上。</p><p>哈希槽均匀地分布在各个节点上，这样数据倾斜问题就解决了。</p><p>实际上，键的映射只和哈希槽有关。我们可以形象地将哈希槽和节点理解为：座位和教室的关系。</p><p><strong>教室 (节点)<strong> 包含</strong>座位 (哈希槽)</strong>。同学 (键) 寻找的永远是座位，不管如何移动教室，同学最终只会根据其座位坐上他应在的位置上。只不过，座位可能会从属于不同的教室，即哈希槽位可能会从属于不同的节点。</p><h5 id="优点"><a class="markdownIt-Anchor" href="#优点">#</a> 优点</h5><p>使用哈希槽的技术可以可以很方便地添加和移除节点。例如，现在有 A、B、C 三台节点，现在我向里面添加一个新的节点 D，那么我们只需要从 A、B、C 三个节点中移走部分的哈希槽至节点 D 即可。同样的，如果我移除节点 C，那么我们只需要将 C 的哈希槽移动到 A、B 节点上，一旦节点 C 的哈希槽空了，那么删除 C 即可。</p><p>同时哈希槽的移动并不会停止集群对外服务，这意味着无论是修改分片占比还是移动哈希槽都不会让集群下线。</p><h4 id="为什么使用16384个槽位"><a class="markdownIt-Anchor" href="#为什么使用16384个槽位">#</a> 为什么使用 16384 个槽位</h4><p>前面提到 CRC16 计算的哈希位数有 16 位，即范围为 0~65535，但   <code>redis</code>   只使用了 14 位，即哈希槽范围为 0~16383。为什么这样设计能？我目前的水平不足以理解背后的原因，但究其原因是因为：</p><ul><li>集群之间发送的心跳包包含  <code>redis</code>  所有的配置，包括哈希槽，且哈希槽占据心跳包的大部分空间，为了减小心跳包占用的带宽，所以缩小哈希槽的范围，14 位是折中的选择</li><li>官方建议的集群节点数不超过 1000 个，所以不需要太大的哈希槽范围</li></ul><h2 id="集群配置参数"><a class="markdownIt-Anchor" href="#集群配置参数">#</a> 集群配置参数</h2><ul><li><strong>cluster-enabled  <code>&lt;yes/no&gt;</code> </strong>：如果设置为 yes，那么这个配置文件所代表的  <code>redis</code>  实例将会支持集群。否则，该实例将会以普通的方式启动。</li><li><strong>cluster-config-file  <code>&lt;filename&gt;</code> </strong>：设置集群的配置文件，该文件是无法写入的，集群节点会在每次配置改变时自动将配置持久化进该文件里，为了当重新启动时读取该文件。该文件会列举像是集群中的节点、他们的状态、持久化变量等等</li><li><strong>cluster-node-timeout <milliseconds></strong>：</li><li><strong>cluster-allow-reads-when-down</strong>  <code>&lt;yes/no&gt;</code> ：</li></ul><h2 id="创建集群"><a class="markdownIt-Anchor" href="#创建集群">#</a> 创建集群</h2><p>在创建集群之间，我们必须首先进行配置以让  <code>redis</code>  实例支持以集群模式运行。最小的配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">port 7000 #redis的端口<br>cluster-enabled yes #声明该实例支持集群模式<br>cluster-config-file nodes.conf #设置该实例的集群配置文件<br>cluster-node-timeout 5000 #超时时间<br>appendonly yes #支持AOF持久化<br></code></pre></td></tr></table></figure><p>最小的集群必须至少含有 3 台   <code>master</code>  节点。官方推荐部署时，使用六台节点的集群，3 台   <code>master</code>  节点和 3 台   <code>slave</code>  节点。现在我们以这个场景进行创建集群的演示：</p><h3 id="运行集群节点"><a class="markdownIt-Anchor" href="#运行集群节点">#</a> 运行集群节点</h3><p>首先我们必须让所有的在集群中工作的节点都支持以集群的模式运行。注意，此时不用单独配置主从复制的关系。 <code>redis</code>  会自动为我们搭建主从复制关系。我们规定 6 个节点的端口分别为：7000，7001，7002，7003，7004，7005。那么每个节点的配置文件的内容如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">bind 0.0.0.0<br>daemonize yes<br>protected-mode no<br>port 7000 #端口自定<br>dir /usr/local/etc/redis #工作路径自定<br>logfile 7000.log #日志文件自定<br>pidfile 7000.pid #pid文件自定<br>appendonly yes<br>appendfilename &quot;7000.aof&quot; #aof文件前缀自定<br>masterauth 12345 #如果由密码，则必须配置该项，用于建立自从复制关系时的认证<br>requirepass 12345 #密码，可要可不要<br><br>cluster-enabled yes<br>cluster-config-file node-7000.conf #集群配置文件自定<br>cluster-node-timeout 5000<br></code></pre></td></tr></table></figure><p>请确保每个节点都包含了属于该节点的配置文件。随后我们使用命令启动着 6 个节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-server /path/to/config.conf<br></code></pre></td></tr></table></figure><p>启动完成后，你会在日志中发现下面这句话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I&#x27;m 97a3a64667477371c4479320d683e4c8db5858b1<br></code></pre></td></tr></table></figure><p><code>ID</code>  会在集群中被永久使用以代表唯一的实例名字。节点会使用  <code>ID</code>  来记住其他节点。随后你会在工作目录下，看见新创建的集群配置文件。</p><h3 id="创建真正的集群"><a class="markdownIt-Anchor" href="#创建真正的集群">#</a> 创建真正的集群</h3><p>现在我们已经有了正在运行的实例了，现在你可以使用以下的命令来创建你的集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -a &lt;password&gt; --cluster create &lt;ip&gt;:&lt;port&gt; [ip:port....] --cluster-replicas 1<br></code></pre></td></tr></table></figure><p>这里使用的命令是 create，因为我们要创建一个新的集群。选项 --cluster-replicas 1 意味着我们希望为每个创建的主节点创建一个副本。其他参数是我想要用来创建新集群的实例的地址列表。</p><p>redis-cli 将为一个配置提出建议。随机分配主从关系。输入 yes 接受建议的配置。集群将被配置并被加入。这意味着实例将被引导以相互通信。最后，如果一切顺利，您将看到如下消息：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[OK]</span> <span class="hljs-attribute">All</span> <span class="hljs-number">16384</span> slots covered<br></code></pre></td></tr></table></figure><p>现在你已经构建起三主三从的集群架构了。如果你这时候前往集群配置文件，你能观察到此时的配置文件已经被写入该集群的一些信息了。</p><blockquote><p><code>redis</code>  之间通信的端口默认为，port + 10000。</p></blockquote><h4 id="查看集群信息"><a class="markdownIt-Anchor" href="#查看集群信息">#</a> 查看集群信息</h4><p>现在你可以查看你之前创建好地集群的信息。我们可以从端口为 7000 的这台实例入手，通过以下命令进入客户端并查看节点的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -a &lt;password&gt; -p 7000<br><br>127.0.0.1:7000&gt; info replication<br>127.0.0.1:7000&gt; cluster info<br>127.0.0.1:7000&gt; cluster slots<br></code></pre></td></tr></table></figure><h3 id="读写"><a class="markdownIt-Anchor" href="#读写">#</a> 读写</h3><p>现在进入某一个实例尝试读写吧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">redis-cli -c -p 7000</span><br>redis 127.0.0.1:7000&gt; set foo bar<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [12182] located at 127.0.0.1:7002</span><br>OK<br>redis 127.0.0.1:7002&gt; set hello world<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [866] located at 127.0.0.1:7000</span><br>OK<br>redis 127.0.0.1:7000&gt; get foo<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [12182] located at 127.0.0.1:7002</span><br>&quot;bar&quot;<br>redis 127.0.0.1:7002&gt; get hello<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [866] located at 127.0.0.1:7000</span><br>&quot;world&quot;<br></code></pre></td></tr></table></figure><p><code>-c</code>  选项代表该客户端以集群模式连接服务端。你可能已经看见了上面结果的  <code>redirected</code>  提示且观察到客户端连接到的服务端发生了变化。下面我们来介绍一下。该提示信息被称为 ——Moved 重定向错误。每当客户端的请求被某个节点接受后，会计算键的哈希槽，当判断该哈希槽不属于该节点，则会查找哈希槽和节点的映射集。然后回复客户端，让其重定向至指定的节点。</p><h3 id="重新分片"><a class="markdownIt-Anchor" href="#重新分片">#</a> 重新分片</h3><p>这个操作将会让某一个节点的的分片被重新划分。让其他节点的部分哈希槽移动至该节点，使用如下的命令进行重新分片：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-clit -a &lt;passowrd&gt; --cluster reshard &lt;ip&gt;:&lt;port&gt;<br></code></pre></td></tr></table></figure><p>如果我们以端口为 7000 的节点为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -a &lt;password&gt; --cluster reshard 127.0.0.1:7000<br></code></pre></td></tr></table></figure><p>你只需要指定这个集群的单个节点， <code>redis</code>  将会自动寻找剩余的节点。</p><p>目前 redis-cli 只能在管理员支持下重新分片，你不能只是说将 5% 的槽从这个节点移动到另一个节点（但这实现起来非常简单）。所以它会一个问题开始。第一个问题是是您想要移动的哈希槽的个数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">How many slots do you want to move (from 1 to 16384)?<br></code></pre></td></tr></table></figure><p>当你确认后，会询问你接受这些哈希槽的   <code>master</code>  节点 ID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">What is the receiving node ID? <br></code></pre></td></tr></table></figure><p>当你执行分片时，该集群中的所有节点包括 ID 等一切信息均以展示，所以你可以直接从上方查阅。</p><p>当你确认后，会继续询问你哈希槽来源的 IDs。你有两个选择：</p><ul><li><code>all</code> ：哈希槽来自于除该节点外的所有节点</li><li>随着 node #1、node #2、node #3… 写入来源节点的 id，随后以  <code>done</code>  结束输入</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">Please enter all the source node IDs.<br>  Type &#x27;all&#x27; to use all the nodes as source nodes for the hash slots.<br>  Type &#x27;done&#x27; once you entered all the source nodes IDs.<br>Source node #1: 2280954adfacc87e6f776bcb2684ea1be1b46567<br>Source node #2: done<br><br></code></pre></td></tr></table></figure><p>最后，会询问你是否执行重新分片：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Do you want to proceed with the proposed reshard plan (yes/no)?<br></code></pre></td></tr></table></figure><p>输入 yes 即可开始重新分片</p><p>分片完成成后可以使用如下的命令检查节点的健康状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -a &lt;password&gt; --cluster check &lt;ip&gt;:&lt;port&gt;<br></code></pre></td></tr></table></figure><p>重新分片可以自动进行，无需以交互方式手动输入参数。这可以使用如下的命令行来实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --cluster reshard &lt;host&gt;:&lt;port&gt; --cluster-from &lt;node-id&gt; --cluster-to &lt;node-id&gt; --cluster-slots &lt;number of slots&gt; --cluster-yes<br></code></pre></td></tr></table></figure><h3 id="故障转移"><a class="markdownIt-Anchor" href="#故障转移">#</a> 故障转移</h3><p><code>redis</code>  集群不用使用哨兵的支持则可以自动触发故障转移。现在，尝试使某一台  <code>master</code>  宕机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -a &lt;password&gt; -p &lt;port&gt; shutdown<br></code></pre></td></tr></table></figure><p>随后我们使用，如下命令查看其中一个节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -a 12345 -p 7001 cluster nodes<br></code></pre></td></tr></table></figure><p>可以发现指定的那台节点已经宕机。但仍有三台  <code>master</code>   节点。可以确定，从节点已经上位为主节点。</p><p>现在让之前的主节点重新上线，仍然使用上面的命令可以发现，之前的宕机的主节点上线后变为从节点。</p><h4 id="手动故障转移"><a class="markdownIt-Anchor" href="#手动故障转移">#</a> 手动故障转移</h4><p>如果你想手动切换主从节点的状态，可以使用如下命令，进行手动的故障转移：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -a 12345 -p 7000 cluster failover<br></code></pre></td></tr></table></figure><h3 id="添加新节点"><a class="markdownIt-Anchor" href="#添加新节点">#</a> 添加新节点</h3><p>添加一个新的主节点非常简单，你只需要添加一个空的节点，并且移动一些哈希槽到这个新的主节点。而添加一个从节点只需要告诉这个节点以从节点的身份启动，就能添加一个从节点。</p><p>下面我们从添加主节点开始。</p><h4 id="添加主节点"><a class="markdownIt-Anchor" href="#添加主节点">#</a> 添加主节点</h4><p>我们以端口为 7006 的节点为例子。（注意，你之前已经创建了以 7000 到 7 005 端口的共六个节点的集群。）现在请确保你已经按照之前的步骤，创建了一个端口为 7006 的   <code>redis</code>  配置文件。让我们启动他。</p><p>当你启动完成后，你会发现该实例的集群配置文件只有它自己，是因为该节点还未加入原来的集群中，现在让我们使用下面的命令来加入他：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -a &lt;password&gt; --cluster add-node &lt;ip&gt;:&lt;port&gt; &lt;ip&gt;:&lt;port&gt;<br></code></pre></td></tr></table></figure><p>第一个参数代表着新加入集群的节点的套接字，第二个参数代表着集群中任意节点的套接字，用于标识新加入的节点加入的是哪个集群中。你只需要标识其中一个节点的套接字，其他的节点将会被自动寻找。</p><p>现在你可以链接任何节点使用  <code>cluster nodes</code>  查看节点状况。你会发现，新加入的节点默认为主节点。</p><h5 id="重新分片-2"><a class="markdownIt-Anchor" href="#重新分片-2">#</a> 重新分片</h5><p>当你将节点成功加入集群中后，该节点就能正确的将查询进行重定向，该新节点和其他的节点有如下的不同：</p><ul><li>该节点没有数据且没有被分配哈希槽</li><li>因为该节点是没有分配哈希槽的主节点，所有该节点无法在从节点想提拔为主节点时参与选举</li></ul><p>所以现在可以使用如下的命令进行重新分片：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">reids-cli -a &lt;passowrd&gt; --cluster reshard &lt;ip&gt;:&lt;port&gt;<br></code></pre></td></tr></table></figure><h4 id="添加从节点"><a class="markdownIt-Anchor" href="#添加从节点">#</a> 添加从节点</h4><p>添加从节点有两种途径，一种是像之前我们添加主节点那样，但是在末尾添加一个   <code>--cluster-slave</code>  参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -a &lt;password&gt; --cluster add-node &lt;ip&gt;:&lt;port&gt; &lt;ip&gt;:&lt;port&gt; --cluster-slave<br><br></code></pre></td></tr></table></figure><p>使用这个命令，我们并没有指定我们目标的主节点，所以  <code>redis-cli</code>  会随机挑选一个主节点。但是如果你想明确指定一个目标主节点你可以使用如下的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -a &lt;password&gt; --cluster add-node &lt;ip&gt;:&lt;port&gt; &lt;ip&gt;:&lt;port&gt; --cluster-slave --cluster-mster-id &lt;id&gt;<br></code></pre></td></tr></table></figure><p>通过指定目标主节点的 id，我们可以指定我们想要的目标主节点。</p><p>另外的一种方式就是，你可以先添加一个空的主节点，然后让他变成某个主节点的从节点，我们以端口为 7006 的节点为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:7006&gt;cluster replicate &lt;id&gt;<br></code></pre></td></tr></table></figure><p>参数 id 为某个主节点的 id。执行完这个命令后即可让该节点变为指定主节点的从节点</p><h2 id="删除节点"><a class="markdownIt-Anchor" href="#删除节点">#</a> 删除节点</h2><p>使用如下命令删除一个节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -a &lt;passowrd&gt; --cluster del-node &lt;ip&gt;:&lt;port&gt; &lt;node-id&gt;<br></code></pre></td></tr></table></figure><p>第一个参数代表着集群中的一个节点，用于寻找集群中的其他节点。第二个参数时你想要删除的那个节点。</p><p>你能使用这个命令删除主从节点，但是如果你想删除一个主节点，请确保这个主节点是空的。如果这个主节点不是空的，你需要在删除前将这个节点上的所有数据重新分片至其他的节点上。</p><p>其他的删除主节点的替代方法就是你可以进行手动的故障转移，当这个节点转换为从节点后即可删除。但显然的，这个方法并不会帮你减少主节点的数量，所以当你想减少主节点的数量时，重新分片是必要的。</p><p>还有一个特殊的方法当你想移除一个的宕机的节点时，你不应该使用   <code>del-node </code>  命令因为他会尝试连接所有节点。所有你将会面对一个 —— <code>connection refused error</code>  (连接拒绝错误)，相反的，你应该使用如下的命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">redis-cli --cluster <span class="hljs-keyword">call</span> <span class="hljs-symbol">&lt;ip&gt;</span>:<span class="hljs-symbol">&lt;port&gt;</span> cluster forget <span class="hljs-symbol">&lt;node-id&gt;</span><br></code></pre></td></tr></table></figure><p>这个命令将会在任何节点上执行  <code>cluster forget</code>  命令</p><h2 id="hash-tag"><a class="markdownIt-Anchor" href="#hash-tag">#</a> hash tag</h2><p><code>hash tag</code>  用于将多个键分配至同一个哈希槽。这用于在集群中实现多键操作。</p><p>为了实现  <code>hash tag</code>  ，键的哈希槽和其他的键的计算在某种情况下有细微的差别。如果一个键包含一个  <code>&quot;&#123;...&#125;</code> &quot; 那么只有  <code>&#123;</code>  和  <code>&#125;</code>  里的子串会被哈希，以获取哈希槽。但是也有可能会有大量的  <code>&#123;</code> 或} 出现。所以该算法被指定遵循以下规则：</p><ul><li>键包含一个  <code>&#123;</code></li><li>并且有一个  <code>&#125;</code>  在  <code>&#123;</code>  右边</li><li>有一个或多个字符在第一个  <code>&#123;</code>  和  <code>&#125;</code>  的中间</li></ul><p>第一个  <code>&#123;</code>  和  <code>&#125;</code>  的中间字符串会被哈希。</p><p>例子：</p><ul><li>两个键，{user1000}.forllowing 和 {user1000}.forllowers 会被分配至一个哈希槽。因为只有唯一的字串 user1000 会被哈希</li><li>键 foo {}{bar}，整个键会被哈希因为第一个  <code>&#123;</code>  和  <code>&#125;</code>  的中间没有字符</li><li>键  <code>foo&#123;&#123;bar&#125;&#125;zap</code>  的字串  <code>&#123;bar</code>  会被哈希，因为这是一个在第一个  <code>&#123;</code>  和  <code>&#125;</code>  的中间的字符子串</li><li>键   <code>foo&#123;bar&#125;&#123;zap&#125;</code>  的 子串  <code>bar</code>  会被哈希</li><li>如果键以  <code>&#123;&#125;</code>  开头，则保证它作为一个整体进行哈希处理。当使用二进制数据作为键名时这很有用</li></ul>]]></content>
    
    
    <categories>
      
      <category>nosql</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/2024/03/10/docker/"/>
    <url>/2024/03/10/docker/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="什么是docker"><a class="markdownIt-Anchor" href="#什么是docker">#</a> 什么是 Docker</h1><p><code>docker</code>  提供了一个平台为开发，转交，测试，以及运行应用提供了便利，让应用从操作系统等底层环境中分离开，不再受底层环境的桎梏。 <code>docker</code>  提供了一种名为 <strong>容器</strong> 的特性，让应用的运行与打包，在一个隔离的环境中。</p><h1 id="容器container"><a class="markdownIt-Anchor" href="#容器container">#</a> 容器 (container)</h1><p>容器是提供给代码运行的隔离的环境。这意味着容器对你的操作系统或者文件系统一无所知。容器提供了代码运行的所有必要的东西，像是软件运行的必要的环境、类库，甚至是最底层的操作系统。你可以将容器类比为集装箱 —— 事实上这也是  <code>docker</code>  logo 的类比。容器就好似集装箱一样，所有的集装箱之间互不干扰。</p><h2 id="镜像image"><a class="markdownIt-Anchor" href="#镜像image">#</a> 镜像 (image)</h2><p>镜像和容器的关系类似于类和对象的、程序和进程的关系。镜像在本地运行起来之后就是容器。镜像由开发人员所维护以及编写，镜像包括了代码运行的所有必要的环境。</p><h3 id="如何获得镜像"><a class="markdownIt-Anchor" href="#如何获得镜像">#</a> 如何获得镜像</h3><p><code>Docker</code>  官方提供了一个镜像仓库 —— <a href="https://hub.docker.com/">Docker hub</a>，类似于  <code>Github</code>  这样的代码托管平台，该镜像仓库托管了所有官方或者第三方提供的镜像。</p><img src="docker/docker_hub.png" alt="docker hub"/><p>由于  <code>docker hub</code>  是国外的，可以使用一些镜像仓库进行加速，例如阿里云、腾讯云。</p><p>通过以下命令拉取镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull &lt;image&gt;:[tag] #如果不指定tag，tag将会是默认值：latest<br></code></pre></td></tr></table></figure><blockquote><p>某个版本的镜像由镜像名和 tag 进行指定</p></blockquote><h2 id="查看本地镜像"><a class="markdownIt-Anchor" href="#查看本地镜像">#</a> 查看本地镜像</h2><p>查看本地的所有镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images<br></code></pre></td></tr></table></figure><p>查看某个镜像的详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker image inspect &lt;image-name&gt;<br></code></pre></td></tr></table></figure><h3 id="删除本地镜像"><a class="markdownIt-Anchor" href="#删除本地镜像">#</a> 删除本地镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi &lt;image-name&gt;<br></code></pre></td></tr></table></figure><h2 id="运行容器"><a class="markdownIt-Anchor" href="#运行容器">#</a> 运行容器</h2><p>如何将镜像运行起来？ <code>docker</code>  提供了一个子命令，来将镜像运行为容器。：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run<br></code></pre></td></tr></table></figure><blockquote><p>如果该镜像本地没有，则会进行远程拉取</p></blockquote><p>假设现在我们有一个名为： <code>mysql</code>  的镜像，我们来演示如何运行它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d|--detach #-d参数代表后台运行，并打印容器Id，如果不加这个参数，那么执行这个命令后，你的命令行会卡住，无法输入命令<br>--name mysql #--name，为该容器分配一个名字<br>-p|--publish 3306:3306 #-p为该容器分配一个端口映射，由于外部无法直接访问容器内部，因此需要进行端口映射。代表着宿主机的3306端口映射到容器的3306端口<br>-e|--env TZ=Asia/Shanghai #-e为容器写入环境变量，前面提到容器本事其实就算一个操作系统，所以理应由环境变量，该环境变量由容器中的容器读写<br>-e MYSQL_ROOT_PASSWORD=123<br>mysql #镜像名<br></code></pre></td></tr></table></figure><blockquote><p>好了，当你按下回车的那一刻，一个名为  <code>mysql</code>  的容器就开始创建了</p></blockquote><h3 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量">#</a> 环境变量</h3><p>你可能想问，我怎么知道有哪些环境变量我可以使用。其实，每个镜像都配备了官方文档，你可以在上面寻找官方提供的环境变量，在<a href="https://hub.docker.com/"> Docker hub</a> 上面搜索  <code>mysql</code>  找到最高  <code>star</code>  的那个镜像：</p><img src="docker/mysql.png" alt="mysql镜像"/><p>点进去，持续往下翻，直到你看到：</p><img src="docker/mysql_doc.png" alt="mysql镜像"/><p>现在你就知道了官方给我们提供了哪些环境变量。如图， <code>MYSQL_ROOT_PASSWORD</code>  代表着数据库的密码</p><h2 id="如何查看运行的容器"><a class="markdownIt-Anchor" href="#如何查看运行的容器">#</a> 如何查看运行的容器</h2><p><code>docker</code>  提供了一个子命令，用于查看运行的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps &lt;container&gt; <br></code></pre></td></tr></table></figure><p>大概样式如下：</p><img src="docker/docker_ps.png" alt="运行中的容器"/><h2 id="启动-停止-删除"><a class="markdownIt-Anchor" href="#启动-停止-删除">#</a> 启动、停止、删除</h2><p>如果你想暂停一个容器，那么只需要使用如下命令，即可暂停容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop &lt;container-name&gt;<br></code></pre></td></tr></table></figure><blockquote><p>请注意，即使你暂停了容器，该容器任然存在，只是没有在运行了而已</p></blockquote><p>如果此时你想重新启动这个容器，那么使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start &lt;container-name&gt;<br></code></pre></td></tr></table></figure><blockquote><p>请注意，不要使用  <code>docker run</code>  因为，该命令总是新创建一个容器，而不是启动原来的容器，请注意与  <code>docker start</code>  的区别</p></blockquote><p>如果你想删除一个容器，那么运行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm &lt;container-name&gt;<br></code></pre></td></tr></table></figure><p>如果此时你的容器正在运行，那么依靠上面的命令你是无法删除的，使用如下命令进行强制删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">docker rm &lt;container-name&gt; -f<br></code></pre></td></tr></table></figure><h1 id="数据卷volume"><a class="markdownIt-Anchor" href="#数据卷volume">#</a> 数据卷 (volume)</h1><h2 id="如何进入容器"><a class="markdownIt-Anchor" href="#如何进入容器">#</a> 如何进入容器</h2><p>之前提到容器相当于操作系统，每个操作系统都有它自己的文件系统，所以如何进入到容器内部操纵里面的文件呢？</p><p>使用  <code>docker</code>  提供的如下子命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec<br></code></pre></td></tr></table></figure><p>该命令会在容器内部运行你提供的命令，该命令会运行在默认的目录下，且必须保证命令是可执行，链式的或者引用的命令是无法执行的，例如</p><ul><li>该命令可以执行:  <code>docker exec -it my_container sh -c &quot;echo a &amp;&amp; echo b&quot;</code></li><li>该命令不可以执行:  <code>docker exec -it my_container &quot;echo a &amp;&amp; echo b&quot;</code></li></ul><p>使用如下命令进入容器内部：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it &lt;container-name&gt; bash<br></code></pre></td></tr></table></figure><p>回车后你会发现，主机名改变了，使用  <code>ls</code>  命令，你将会看到如  <code>linux</code>  一般的文件系统。</p><p>此时你可能会迫不及待，打算执行一些操作，于是你新创建一个名为  <code>test</code>  的文件，然后尝试用  <code>vi</code>  命令进行编辑，可是当你执行过后会发现， <code>vi</code>  命令找不到。这是怎么回事呢？明明容器就如操作系统一样，应该也会包含所有的命令的啊。</p><p>结论是：镜像所创建的环境仅仅会包含和镜像应用有关的命令，所有不会包含所有的命令。所有，你在有关  <code>mysql</code>  的容器中使用  <code>mysql</code>  命令会成功，而你在不包含  <code>mysql</code>  的容器中使用，则会失败。</p><h2 id="和容器进行连接"><a class="markdownIt-Anchor" href="#和容器进行连接">#</a> 和容器进行连接</h2><p>如果有些命令无法使用，拿我想修改容器中的数据的时候该怎么办？  <code>docker</code>  提供了一个特性 —— 数据卷，来帮助我们完成这个操作。</p><p>什么是数据卷？在操作系统中，万物皆文件，数据卷就是挂载载文件系统上的设备。像物理机上的硬盘就是数据卷。当然在  <code>docker</code>  中数据卷只是逻辑的。</p><p>所以，该如何使用这个数据卷呢？相信你一定使用过  <code>u盘</code>  ，当你插上  <code>u盘</code>  后，你的文件系统就会将这个  <code>u盘</code>  挂载到文件系统上，你就能通过文件的形式访问  <code>u盘</code>  的数据。</p><p>所以我们要做的就是，将  <code>docker</code>  容器中的文件看成  <code>u 盘</code>  将其挂载到我们的宿主机的文件系统上，然后就能通过宿主机修改容器的数据。这就是数据卷的作用。那么我们该如何使用？</p><h2 id="挂载数据卷"><a class="markdownIt-Anchor" href="#挂载数据卷">#</a> 挂载数据卷</h2><blockquote><p>数据卷只能在运行容器时进行挂载。</p></blockquote><p>在运行  <code>docker run</code>  时只需要添加一个选项即可，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d|--detach #-d参数代表后台运行，并打印容器Id，如果不加这个参数，那么执行这个命令后，你的命令行会卡住，无法输入命令<br>--name mysql #--name，为该容器分配一个名字<br>-p|--publish 3306:3306 #-p为该容器分配一个端口映射，由于外部无法直接访问容器内部，因此需要进行端口映射。代表着宿主机的3306端口映射到容器的3306端口<br>-e|--env TZ=Asia/Shanghai #-e为容器写入环境变量，前面提到容器本事其实就算一个操作系统，所以理应由环境变量，该环境变量由容器中的容器读写<br>-e MYSQL_ROOT_PASSWORD=123 <br>-v source:/var/lib/mysql #将名为source的数据卷与/var/lib/mysql相映射<br>mysql #镜像名<br></code></pre></td></tr></table></figure><blockquote><p>数据卷默认存放在： <code>/var/lib/docker/volumes/&lt;volume-name&gt;/_data</code>  目录下</p></blockquote><p>现在你就能在： <code>/var/lib/docker/volumes/source/_data</code>  下看到你挂载的数据卷了，里面包含了容器中  <code>/var/lib/mysql</code>  目录下的所有的文件</p><p>当然你也可以运行以下命令来提前创建一个数据卷：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume create [volume-name]<br></code></pre></td></tr></table></figure><p>如果你不指定数据卷的名字，那么会使用一段  <code>hash</code>  值来作为数据卷的名字。现在，请前往之前所说的那个目录下，你已经能看到这个数据卷了。当然，数据卷下面并没有任何数据，因为你没有进行挂载。然后你可以在运行容器时使用该数据卷的名字进行挂载。</p><h3 id="自定义数据卷位置"><a class="markdownIt-Anchor" href="#自定义数据卷位置">#</a> 自定义数据卷位置</h3><p>如果你不想让数据卷放在默认位置下，你可以在运行容器时指定目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -dp 80:80 <br>--name docker-demo<br>-v /root:/var/lib/nginx #我们在root目录下进行挂载<br>docker-demo <br></code></pre></td></tr></table></figure><p>前外  <code>/root</code>  目录下，你就能看到这个数据卷</p><blockquote><p>注意自定义目录必须要以绝对路径起首，不然会被默认为默认数据卷</p></blockquote><h2 id="查看数据卷"><a class="markdownIt-Anchor" href="#查看数据卷">#</a> 查看数据卷</h2><p>你可以使用，如下命令查看所有的数据卷：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume ls<br></code></pre></td></tr></table></figure><p>如果你想查看某个数据卷的详细信息，可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume inspect &lt;volume-name&gt;<br></code></pre></td></tr></table></figure><h1 id="网络network"><a class="markdownIt-Anchor" href="#网络network">#</a> 网络 (network)</h1><p>现在让我考考你一个问题。如果现在有两个容器，一个是数据库，一个是服务器，服务器想要访问数据库怎么办呢。前面说到，容器是一个个隔离的环境，如何才能让容器之间通信呢？</p><p>容器作为操作系统，当然有自己的<strong>网络</strong>。 <code>docker</code>  在运行的时候会初始化一张虚拟网卡，现在前往你的宿主机尝试一下  <code>ip addr</code>  命令，如果你的  <code>docker</code>  在运行中，不出意外你将会看到：</p><img src="docker/net_adapter.png" alt="docker的虚拟网卡"/><p>这就是  <code>docker</code>  生成的虚拟网卡。意味着容器本身之间也能进行<strong>通信</strong>。</p><h2 id="使用默认的网络"><a class="markdownIt-Anchor" href="#使用默认的网络">#</a> 使用默认的网络</h2><p><code>docker</code>  会初始化一个  <code>docker0</code>  的网卡，分配一个名为  <code>bridge</code>  的默认网段。所有启动的容器将会默认使用这个网段，并分配一个  <code>ip</code>  地址，但 <code>docker</code>  官方并不推荐使用默认的网络，而是推荐 —— 自定义网络</p><h2 id="自定义网络"><a class="markdownIt-Anchor" href="#自定义网络">#</a> 自定义网络</h2><p>在  <code>docker</code>  中只有同一网段的<strong>容器</strong>才能互相通信。你可以创建自定义的<strong>网络</strong>，然后将容器连接到这个自定义的网络上，一旦容器连接到同一个网络上，容器中间就能通过  <code>ip</code>  地址或者容器名进行通信。</p><p><code>docker</code>  提供了用于创建网络的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network create &lt;network-name&gt;<br></code></pre></td></tr></table></figure><p>该令会创建一个默认基于  <code>driver</code>  网卡的网络，该网络会被分配一个网段。</p><h2 id="连接网络"><a class="markdownIt-Anchor" href="#连接网络">#</a> 连接网络</h2><p>现在你可以在运行容器的时候，连接指定的网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d|--detach #-d参数代表后台运行，并打印容器Id，如果不加这个参数，那么执行这个命令后，你的命令行会卡住，无法输入命令<br>--name mysql #--name，为该容器分配一个名字<br>-p|--publish 3306:3306 #-p为该容器分配一个端口映射，由于外部无法直接访问容器内部，因此需要进行端口映射。代表着宿主机的3306端口映射到容器的3306端口<br>-e|--env TZ=Asia/Shanghai #-e为容器写入环境变量，前面提到容器本事其实就算一个操作系统，所以理应由环境变量，该环境变量由容器中的容器读写<br>-e MYSQL_ROOT_PASSWORD=123 <br>--network=&lt;network-name&gt;<br>mysql #镜像名<br></code></pre></td></tr></table></figure><p>一旦你运行这个容器，该容器会加入这个网络，并分配一个  <code>ip</code>  地址</p><p>或者你可以为一个已经运行的容器连接网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network connet &lt;network-name&gt; &lt;container-name&gt;<br></code></pre></td></tr></table></figure><h1 id="层layer"><a class="markdownIt-Anchor" href="#层layer">#</a> 层 (layer)</h1><p>了解完上述概念，相信你已经能运行一个自己的容器了。</p><p>现在让我们来思考一个问题：如果我们拉取两个镜像 —— 一个是只有操作系统的镜像，另外一个是建立在该操作系统上的  <code>jre</code>  镜像。那么，拉取完操作系统镜像后，并在拉取  <code>jre</code>  镜像时会再继续拉取一个包含操作系统的  <code>jre</code>  环境吗？</p><p>答案是不会的，这就涉及到了  <code>docker</code>  的一个重要概念 —— <strong>层 (layer)</strong>。 <code>docker</code>  将容器成了多个层，层与层之间能够复用。如果两个镜像包含了相同的层，那么相同的层将不会进行重复拉取而是复用，这就增加了镜像的复用性，减少了镜像的空间大小。每个镜像都可以建立在某个层上，对某个层进行扩展和补充形成新的层。</p><p>我们把那些提供基础环境的层叫做：基础镜像</p><h1 id="自定义镜像"><a class="markdownIt-Anchor" href="#自定义镜像">#</a> 自定义镜像</h1><p>使用  <code>dcoker</code>  我们可以自定义镜像，但我们不用去实现镜像的细节，我们只需要告诉  <code>docker</code>  这个镜像需要什么，然后  <code>docker</code>  帮我们组装这个镜像。那么，我们如何告诉  <code>docker</code>  我们需要什么呢？ <code>docker</code>  提供了一个文件 ——  <code>Dockerfile</code>  来让我们编写自定义镜像的细节。</p><h2 id="编写dockerfile"><a class="markdownIt-Anchor" href="#编写dockerfile">#</a> 编写 Dockerfile</h2><p><code>Dockerfile</code>  常用的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM #用于设置容器的基础镜像，用于应用运行的基础环境<br>WORKDIR &lt;path&gt; #容器的工作目录，当你进入容器的文件系统后，默认为该目录<br>COPY &lt;src&gt; &lt;target&gt;  #将宿主机的文件拷贝至容器的目录下<br>RUN #在构建镜像时执行一些命令<br>EXPOSE #暴露的端口，通知Docker监听的端口<br>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] #在容器运行后执行<br>ENV key=value... #添加环境变量<br></code></pre></td></tr></table></figure><h2 id="cmd"><a class="markdownIt-Anchor" href="#cmd">#</a> CMD</h2><p>当你运行时容器，会执行  <code>CMD</code>  给出的指令，公有三种形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] #executable形式：executable是执行的命令，param时给命令的参数<br>CMD [&quot;param1&quot;,&quot;param2&quot;] #param会传递给ENTRYPOINT<br>CMD command param1 param2 (shell form) #shell形式，默认用shell命令，shell类型默认为sh<br></code></pre></td></tr></table></figure><blockquote><p>只能存在一条  <code>CMD</code>  语句，如果存在多条，只使用最后一条语句</p></blockquote><h2 id="entrypoint"><a class="markdownIt-Anchor" href="#entrypoint">#</a> ENTRYPOINT</h2><p>与  <code>CMD</code>  类似，共有两种形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] #executable形式：executable是执行的命令，param时给命令的参数<br>ENTRYPOINT command param1 param2  #shell形式，默认用设定的shell类型去执行，shell类型默认为sh<br></code></pre></td></tr></table></figure><blockquote><p>只能存在一条  <code>ENTRYPOINT</code>  语句，如果存在多条，只使用最后一条语句</p></blockquote><blockquote><p><code>CMD</code>  与  <code>ENTRYPOINT</code>  不同之处在于， <code>ENTRYPOINT</code>  不可以被  <code>docker run</code>  后的参数覆盖，会把  <code>docker run</code>  后面的参数传递给  <code>ENTRYPOINT</code>  指定的参数。</p></blockquote><p>以下为实例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">18</span>-alpine <span class="hljs-comment">#dockerfile开头通常为FROM以引入基础环境</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app <span class="hljs-comment">#设置工作路径 /app</span></span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> package*.json ./ <span class="hljs-comment">#拷贝待用package的json文件至 /app 下面</span></span><br><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./src ./src <span class="hljs-comment">#仍然时拷贝</span></span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./public ./public</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm install \ <span class="hljs-comment">#运行命令</span></span><br>    &amp;&amp; npm install -g serve \<br>    &amp;&amp; npm <span class="hljs-keyword">run</span><span class="language-bash"> build \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -fr node_modules</span><br> <br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span> <span class="hljs-comment">#暴露端口</span><br><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">&quot;serve&quot;</span>, <span class="hljs-string">&quot;-s&quot;</span>, <span class="hljs-string">&quot;build&quot;</span> ] <span class="hljs-comment">#容器运行时执行命令</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2024/02/21/spring/"/>
    <url>/2024/02/21/spring/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="引入"><a class="markdownIt-Anchor" href="#引入">#</a> 引入</h1><p>考虑下面一个模拟保存用户的 <code>MVC</code>  程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//dao层</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserDao</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoForMysqlImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserDao</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;正在保存user for mysql&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//service层</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserService</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">IUserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoForMysqlImpl</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">()</span> &#123;<br>        userDao.saveUser();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//controller层</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Controller</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">IUserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        userService.saveUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">正在保存<span class="hljs-keyword">user</span> <span class="hljs-title">for</span> mysql<br></code></pre></td></tr></table></figure><p>运行结果看起来完美无缺，能够正常保存，于是你正常上线。但某一天客户突然要求你更换数据库为  <code>Oracle</code>  而不是  <code>Mysql</code> ，你可能会想那好办，我再写一个  <code>UserDaoForOracleImpl</code>  就好了呗。于是你马不停蹄地写出了这个给类，然后一一更改每一层的依赖…</p><p>这样的操作以及源代码有什么问题？</p><p>由<strong> OCP 原则</strong>可知：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，我们应当采用扩展。对源代码的修改显然已经破坏了这个原则。</p><p>由<strong> DIP 原则</strong>可知：高层模块不应该依赖于下层模块的细节，也就是不应该在程序中出现下层模块的实例，换句话说也就是面向接口开发。源代码中高层对底层的依赖显然也违背了这个原则。</p><p>由于高层实例和下层实例的强耦合，导致每做出一次更新，就要修改源代码，也就导致每次更新都要重新对以往的代码进行测试。</p><p>争对以上所述情况，出现了一个新型的解决方案： <code>IOC</code></p><blockquote><p>[!Important]</p><p><strong>开闭原则 (<font color="red">O</font>pen <font color="red">C</font>lose <font color="red">P</font>rinciple OCP)</strong> ：软件实体应当对扩展开放，对修改关闭。</p><p>Software entities should be open for extension，but closed for modification.</p><p><strong>依赖倒置原则 (<font color="red">D</font>ependency <font color="red">I</font>version <font color="red">P</font>rinciple DIP)</strong> ：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</p><p>High level modules shouldn’t depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.</p></blockquote><h1 id="ioc"><a class="markdownIt-Anchor" href="#ioc">#</a> IoC</h1><p><strong>控制反转 (nversion <font color="red">o</font>f <font color="red">C</font>ontrol IoC)</strong> ：通过使用直接构建类或诸如服务定位模式的机制来控制其依赖关系的实例化或位置的逆过程。以上为<a href="https://docs.Spring.io/Spring-framework/reference/core/beans/introduction.html"> Spring 官方</a>的解释。</p><p>可能不太好懂，可以换作通俗的话来解释。也就是解释反转是什么：</p><ol><li>不在程序中采用硬编码的方式来  <code>new</code>  对象，也就是说<strong>创造对象的权力</strong>被我反转出去了。</li><li>不在程序中自己解决对象之间的依赖问题，也就是说<strong>依赖关系的维护权</strong>被我反转出去了。</li></ol><p><code>Ioc</code>  是种思想，不是某种具体的解决措施。  <code>Ioc</code>  有很多种实现方式。</p><p><code>Spring</code>  框架 (容器) 为我们提供了  <code>Ioc</code>  的一种具体的解决办法也就是<strong>依赖注入 (<font color="red">D</font>ependency <font color="red">I</font>njection DI)</strong> 。也就是说我们能通过<strong>依赖注入</strong>来实现<strong>控制反转</strong>。</p><p>依赖注入  <code>DI</code>  的两种注入方式：</p><ul><li>构造器注入：通过构造器注入</li><li><code>set</code>  注入：通过  <code>set</code>  方法注入</li></ul><blockquote><p>[!Note]</p><p>依赖：A 和 B 之间的关系</p><p>注入：创造 A 和 B 之间的关系</p></blockquote><h2 id="第一个spring程序"><a class="markdownIt-Anchor" href="#第一个spring程序">#</a> 第一个 Spring 程序</h2><h3 id="获取配置文件"><a class="markdownIt-Anchor" href="#获取配置文件">#</a> 获取配置文件</h3><p><code>Spring</code>  框架称呼被  <code>Ioc</code>  管理的对象为  <code>bean</code> 。 <code>Spring</code>  通过  <code>xml</code>  配置文件来进行相关配置，同时<strong>对配置文件的命名不做要求</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.Springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.Springframework.org/schema/beans http://www.Springframework.org/schema/beans/Spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">   bean标签为bean对象</span><br><span class="hljs-comment">   id：代表bean对象的唯一标识，不能重复。否则会抛出BeanDefinitionParsingException bean定义解析错误</span><br><span class="hljs-comment">   class：实例对象的全类名</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.demo.bens.UserBean&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="获取ioc容器"><a class="markdownIt-Anchor" href="#获取ioc容器">#</a> 获取 IoC 容器</h3><p>配置完成配置文件后，紧接着就要通过解析配置文件获取  <code>IOC</code>  容器，在  <code>Spring</code>  中  <code>ApplicationContext</code>  接口即为  <code>IoC</code>  容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在类路径中查找配置文件</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ioc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;Spring.xml&quot;</span>);<br><br><span class="hljs-comment">//在本地查找配置文件</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ioc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemXmlApplicationContext</span>(<span class="hljs-string">&quot;path/to/xml&quot;</span>);<br><br><span class="hljs-comment">//初始化Ioc容器时支持多个配置文件</span><br><span class="hljs-comment">//ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;asd.xml&quot;,&quot;asad.xml&quot;,&quot;asdaa.xml&quot;....);</span><br></code></pre></td></tr></table></figure><blockquote><p>在获取  <code>IoC</code>  容器时，就会实例化那些单例的  <code>bean</code></p><p><code>ApplicationContext</code>  继承自  <code>BeanFactory</code> ，实际上也就是  <code>bean</code>  工厂。</p></blockquote><h3 id="获取bean"><a class="markdownIt-Anchor" href="#获取bean">#</a> 获取 bean</h3><p>获得  <code>Ioc</code>  容器后，我们就可以获取容器里面锁创造的  <code>bean</code>  了， <code>Spring</code>  提供了三种获取  <code>bean</code>  的重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">userBean</span> <span class="hljs-operator">=</span> ioc.getBean(<span class="hljs-string">&quot;userBean&quot;</span>);<br><span class="hljs-type">UserBean</span> <span class="hljs-variable">userBean</span> <span class="hljs-operator">=</span> ioc.getBean(<span class="hljs-string">&quot;userBean&quot;</span>,UserBean.class);<br><span class="hljs-type">UserBean</span> <span class="hljs-variable">userBean</span> <span class="hljs-operator">=</span> ioc.getBean(UserBean.Class);<br></code></pre></td></tr></table></figure><blockquote><p><code>Spring</code>  框架通过反射机制和工厂模式来创造  <code>bean</code>  。也就是：首先解析  <code>XML</code>  文件，获取类路径，其次通过工厂模式利用反射通过类路径创建对象。</p><p><code>Spring</code>  默认使用空构造方法创建对象。</p><p><code>Spring</code>  底层使用一个  <code>map</code>  集合来管理对象和  <code>id</code>  之间的关系， <code>getBean</code>  方法实际上是就是通过键获取值。</p><p>当获取  <code>bean</code>  时，如果指定的 <code>id</code>  或者类型不存在，那么将会抛出  <code>NoSuchBeanDefinitionException</code>  没有该  <code>bean</code>  定义异常</p></blockquote><h2 id="spring对ioc的实现"><a class="markdownIt-Anchor" href="#spring对ioc的实现">#</a> Spring 对 IOC 的实现</h2><h3 id="依赖注入"><a class="markdownIt-Anchor" href="#依赖注入">#</a> 依赖注入</h3><p>解决对象之间的依赖问题。</p><h4 id="set注入"><a class="markdownIt-Anchor" href="#set注入">#</a> set 注入</h4><p><code>set</code>  注入，基于  <code>set</code>  方法实现的，底层会通过反射机制调用属性对应的  <code>set</code>  方法然后给属性赋值。这种方式要求属性必须对外提供  <code>set</code>  方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.Springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.Springframework.org/schema/beans http://www.Springframework.org/schema/beans/Spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.dao.UserDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.service.UserService&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">property标签：代表通过set的方式注入</span><br><span class="hljs-comment">name：代表对应属性。注意，该属性不是指的属性名，而是setter方法，去掉set以及首字母小写之后的属性。</span><br><span class="hljs-comment">ref：引用类型。ref填入的时其他bean的id</span><br><span class="hljs-comment">value：普通的字面量</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;world&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>set 注入底层通过反射获取的 setter 方法，所以 name 属性必须是 setter 方法去掉 set 以及首字母小写之后的名字</p></blockquote><h4 id="构造器注入"><a class="markdownIt-Anchor" href="#构造器注入">#</a> 构造器注入</h4><p>核心原理：通过调用构造方法来给属性赋值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.dao.UserDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;customService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.service.CustomService&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">constructor-arg：代表通过构造器注入</span><br><span class="hljs-comment">index：构造器中的参数位置，默认以0开始</span><br><span class="hljs-comment">name：参数名字</span><br><span class="hljs-comment">type：参数类型</span><br><span class="hljs-comment">value和ref与set注入同</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;world&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;haha&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>不指定  <code>index</code>  、 <code>name</code>  和  <code>type</code>  的话， <code>Spring</code>  也能猜出来该赋值给谁。注意此方法也是使用的  <code>type</code></p><p>两种注入方式的实际不同：一个是实例化后注入，一个是实例的时候就注入。</p></blockquote><h3 id="set注入专题"><a class="markdownIt-Anchor" href="#set注入专题">#</a> set 注入专题</h3><h4 id="注入外部bean"><a class="markdownIt-Anchor" href="#注入外部bean">#</a> 注入外部 Bean</h4><p>引用的是在  <code>bean</code>  外面定义的  <code>bean</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderDaoBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.dao.OrderDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.service.OrderSerivce&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;orderDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;orderDaoBean&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注入内部bean"><a class="markdownIt-Anchor" href="#注入内部bean">#</a> 注入内部 bean</h4><p>在  <code>bean</code>  标签中嵌套  <code>bean</code>  标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderServiceInner&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.service.OrderSerivce&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;orderDao&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.dao.OrderDao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注入简单类型"><a class="markdownIt-Anchor" href="#注入简单类型">#</a> 注入简单类型</h4><p><code>Spring</code>  认为的简单类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSimpleValueType</span><span class="hljs-params">(Class&lt;?&gt; type)</span> &#123;<br>    <span class="hljs-keyword">return</span> (!isVoidType(type) &amp;&amp;<br>            (isPrimitiveOrWrapper(type) || <span class="hljs-comment">//基本类型和包装类型</span><br>             Enum.class.isAssignableFrom(type) || <span class="hljs-comment">//枚举类型</span><br>             CharSequence.class.isAssignableFrom(type) || <br>             Number.class.isAssignableFrom(type) ||<br>             Date.class.isAssignableFrom(type) || <span class="hljs-comment">//日期</span><br>             Temporal.class.isAssignableFrom(type) || <br>             ZoneId.class.isAssignableFrom(type) ||<br>             TimeZone.class.isAssignableFrom(type) ||<br>             File.class.isAssignableFrom(type) ||<br>             Path.class.isAssignableFrom(type) ||<br>             Charset.class.isAssignableFrom(type) ||<br>             Currency.class.isAssignableFrom(type) ||<br>             InetAddress.class.isAssignableFrom(type) ||<br>             URI.class == type ||<br>             URL.class == type ||<br>             UUID.class == type ||<br>             Locale.class == type ||<br>             Pattern.class == type ||<br>             Class.class == type));<br>&#125;<br></code></pre></td></tr></table></figure><p>注入简单类型形如如下形式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderServiceInner&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.service.OrderSerivce&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;world&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>当把日期当作简单类型注入时必须考虑注入的格式，要必须完全符合日期格式才能成功注入，如下所示</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.service.OrderSerivce&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Thu Feb 22 10:53:41 CST 2024&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;date1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2024/2/22 20:20:20&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="级联属性赋值"><a class="markdownIt-Anchor" href="#级联属性赋值">#</a> 级联属性赋值</h4><p>引用外部  <code>bean</code>  后，对外部  <code>bean</code>  的属性赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;class&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.Clazz&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jjj&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;clazz&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;class&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;clazz.name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;软件1班&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注入数组"><a class="markdownIt-Anchor" href="#注入数组">#</a> 注入数组</h4><p>在注入时使用标签： <code>&lt;array&gt;</code></p><h5 id="简单类型"><a class="markdownIt-Anchor" href="#简单类型">#</a> 简单类型</h5><p>在  <code>&lt;array&gt;</code>  中使用  <code>&lt;value&gt;</code>  标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jjj&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;clazz&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>456<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="引用类型"><a class="markdownIt-Anchor" href="#引用类型">#</a> 引用类型</h5><p>在  <code>&lt;array&gt;</code>  中使用  <code>&lt;ref&gt;</code>  标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dept1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.Dept&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dept2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.Dept&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dept3&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.Dept&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;employee&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.Employee&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;depts&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dept1&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dept2&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dept3&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注入list集合"><a class="markdownIt-Anchor" href="#注入list集合">#</a> 注入 list 集合</h4><p>在注入时使用标签： <code>&lt;list&gt;</code></p><h5 id="是简单类型"><a class="markdownIt-Anchor" href="#是简单类型">#</a> 是简单类型</h5><p>在  <code>&lt;list&gt;</code>  中使用  <code>&lt;value&gt;</code>  标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jjj&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;clazz&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>456<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="引用类型-2"><a class="markdownIt-Anchor" href="#引用类型-2">#</a> 引用类型</h5><p>在  <code>&lt;list&gt;</code>  中使用  <code>&lt;ref&gt;</code>  标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dept1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.Dept&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dept2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.Dept&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dept3&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.Dept&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;employee&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.Employee&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;depts&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dept1&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dept2&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dept3&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注入map集合"><a class="markdownIt-Anchor" href="#注入map集合">#</a> 注入 map 集合</h4><p>在注入时使用标签： <code>&lt;map&gt;</code>  以及其中的  <code>&lt;entry&gt;</code></p><h5 id="简单类型-2"><a class="markdownIt-Anchor" href="#简单类型-2">#</a> 简单类型</h5><p>在  <code>&lt;entry&gt;</code>  中使用  <code>&lt;value&gt;</code>  或者  <code>&lt;key&gt;</code>  标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;peopleBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.People&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;addrs&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--如果key不是简单类型，使用 key-ref 属性--&gt;</span><br>            <span class="hljs-comment">&lt;!--如果value不是简单类型，使用 value-ref 属性--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;北京大兴区&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上海浦东区&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;深圳宝安区&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="引用类型-3"><a class="markdownIt-Anchor" href="#引用类型-3">#</a> 引用类型</h5><p>在  <code>&lt;entry&gt;</code>  中使用  <code>&lt;value-ref&gt;</code>  或者  <code>&lt;key-ref&gt;</code>  标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;emploee1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.Employee&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;deptMap&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--如果key不是简单类型，使用 key-ref 属性--&gt;</span><br>            <span class="hljs-comment">&lt;!--如果value是简单类型，使用 value 属性--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">key-ref</span>=<span class="hljs-string">&quot;dept1&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">key-ref</span>=<span class="hljs-string">&quot;dept2&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">key-ref</span>=<span class="hljs-string">&quot;dept3&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注入set集合"><a class="markdownIt-Anchor" href="#注入set集合">#</a> 注入 set 集合</h4><p>在注入时使用  <code>&lt;set&gt;</code>  标签</p><h5 id="简单类型-3"><a class="markdownIt-Anchor" href="#简单类型-3">#</a> 简单类型</h5><p>在  <code>&lt;set&gt;</code>  中使用  <code>&lt;value&gt;</code>  标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;peopleBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.People&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;phones&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--简单类型使用value，非简单类型可以使用ref--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>110<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>110<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>120<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>120<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>119<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>119<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="引用类型-4"><a class="markdownIt-Anchor" href="#引用类型-4">#</a> 引用类型</h5><p>在  <code>&lt;set&gt;</code>  中使用  <code>&lt;ref&gt;</code>  标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;peopleBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.People&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;phones&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--非简单类型可以使用ref，简单类型使用value--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;phone1&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;phone2&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;phone3&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;phone4&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;phone5&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注入properties"><a class="markdownIt-Anchor" href="#注入properties">#</a> 注入 Properties</h4><p>在注入时使用  <code>&lt;props&gt;</code>  标签和  <code>&lt;prop&gt;</code>  标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.DataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;properties&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;driver&quot;</span>&gt;</span>com.cj.jc.sql.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/tes<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>123456<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注入空字符串和null值"><a class="markdownIt-Anchor" href="#注入空字符串和null值">#</a> 注入空字符串和 null 值</h4><p>空字符串可以是以下的方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.service.OrderSerivce&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;world&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注入  <code>null</code>  可以不注入对应属性，也可以使用  <code>&lt;null&gt;</code>  标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderDaoBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.dao.OrderDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.service.OrderSerivce&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;orderDao&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="p命名空间注入"><a class="markdownIt-Anchor" href="#p命名空间注入">#</a> p 命名空间注入</h3><p>使用前确保使用约束： <code>xmlns:p=http://www.Springframework.org/schema/p</code></p><p>相当于  <code>set</code>  注入和在注入时使用  <code>&lt;property&gt;</code>  标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.Student&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;llll&quot;</span> <span class="hljs-attr">p:clazz-ref</span>=<span class="hljs-string">&quot;clazz&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>该命名空间的形式为： <code>p:xxx[-ref]</code>   <code>xxx</code>  为属性名，是否带  <code>ref</code>  取决于该属性是否为引用属性</p></blockquote><h3 id="c命名空间注入"><a class="markdownIt-Anchor" href="#c命名空间注入">#</a> c 命名空间注入</h3><p>使用前确保使用约束： <code>xmlns:p=http://www.Springframework.org/schema/c</code></p><p>相当于构造器注入和在注入时使用  <code>&lt;constructor-arg&gt;</code>  ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;use&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.entity.User&quot;</span> <span class="hljs-attr">c:_0</span>=<span class="hljs-string">&quot;111&quot;</span> <span class="hljs-attr">c:name</span>=<span class="hljs-string">&quot;jjjj&quot;</span> <span class="hljs-attr">c_1-ref</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>该命名空间的形式为： <code>p:_num|xxx[-ref]</code>   <code>_num</code>  相当于  <code>&lt;constructor-arg&gt;</code>  中的序号  <code>xxx</code>  相当于属性名，是否带  <code>ref</code>  取决于该属性是否为引用属性</p></blockquote><h3 id="util命名空间"><a class="markdownIt-Anchor" href="#util命名空间">#</a> util 命名空间</h3><p>使用  <code>util </code> 命名空间可以让<strong>配置复用</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.Springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:util</span>=<span class="hljs-string">&quot;http://www.Springframework.org/schema/util&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.Springframework.org/schema/beans http://www.Springframework.org/schema/beans/Spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                           http://www.Springframework.org/schema/util http://www.Springframework.org/schema/util/Spring-util.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">保证有下面连个约束：</span><br><span class="hljs-comment">xmlns:util=&quot;http://www.Springframework.org/schema/util&quot;</span><br><span class="hljs-comment"> xsi:schemaLocation=&quot;http://www.Springframework.org/schema/util http://www.Springframework.org/schema/util/Spring-util.xsd&quot;</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">util:properties</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;prop&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;driver&quot;</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/Spring<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>123456<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">util:properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.powernode.Spring6.beans.MyDataSource1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;properties&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;prop&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.powernode.Spring6.beans.MyDataSource2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;properties&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;prop&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">引用某个类里面的公共，静态的变量作为bean</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">util:constant</span> <span class="hljs-attr">static-field</span>=<span class="hljs-string">&quot;java.lang.Integer.MAX_VALUE&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;aaa&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">相当于可复用的&lt;list&gt;标签</span><br><span class="hljs-comment">--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">util:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bbb&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>321<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1234567<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">相当于可复用的&lt;map&gt;标签</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">util:map</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;world&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">util:map</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">相当于可复用的&lt;set&gt;标签</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">util:set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>321<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1234567<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">util:set</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="基于xml的自动装配"><a class="markdownIt-Anchor" href="#基于xml的自动装配">#</a> 基于 xml 的自动装配</h3><p>自动装配：不用显示地对类地引用对象进行赋值。使用  <code>&lt;bean&gt;</code>  标签的  <code>autowire</code>  属性。</p><h4 id="根据名称"><a class="markdownIt-Anchor" href="#根据名称">#</a> 根据名称</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;aaa&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.dao.UserDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.service.UserService&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>注意根据名称自动注入装配，会根据  <code>id</code>  或  <code>name</code>  与  <code>setter</code>  方法匹配。所以  <code>id</code>  或  <code>name</code>  不能随便写。</p><p>没有  <code>name</code>  属性时会根据  <code>id</code>  进行匹配。</p><blockquote><p>此类型也是  <code>set</code>  注入，必须保证  <code>setter</code>  方法的存在</p></blockquote><h4 id="根据类型"><a class="markdownIt-Anchor" href="#根据类型">#</a> 根据类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;aaa&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.dao.UserDao&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;customService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.di.service.CustomService&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>注意根据名称自动注入装配时，如果有多个相同类型的  <code>bean</code>  存在，那么无法进行自动装配，会抛出  <code>UnsatisfiedDependencyException</code></p><blockquote><p>此类型也是  <code>set</code>  注入，必须保证  <code>setter</code>  方法的存在</p></blockquote><h3 id="引入外部属性配置文件"><a class="markdownIt-Anchor" href="#引入外部属性配置文件">#</a> 引入外部属性配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.Springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.Springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.Springframework.org/schema/beans http://www.Springframework.org/schema/beans/Spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                           http://www.Springframework.org/schema/context http://www.Springframework.org/schema/context/Spring-context.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">确保以下两个约束存在：</span><br><span class="hljs-comment">  xmlns:context=&quot;http://www.Springframework.org/schema/context&quot;</span><br><span class="hljs-comment">xsi:schemaLocation=&quot;http://www.Springframework.org/schema/context http://www.Springframework.org/schema/context/Spring-context.xsd&quot;</span><br><span class="hljs-comment">--&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--引入外部配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">使用$&#123;&#125;引用属性</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.powernode.Spring6.beans.MyDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="bean的作用域"><a class="markdownIt-Anchor" href="#bean的作用域">#</a> bean 的作用域</h2><p>默认情况下  <code>bean</code>  是单例的。在  <code>Spring</code>  上下文初始化的时候实例化。通过  <code>&lt;bean&gt;</code>  标签的  <code>scope</code>  属性进行配置。</p><p><code>scope</code>  一个有  <code>8</code>  个取值：</p><ul><li><code>singleton</code> ：默认的，单例。</li><li><code>prototype</code> ：原型。每调用一次  <code>getBean()</code>  方法则获取一个新的  <code>Bean</code>  对象。或每次注入的时候都是新对象。</li><li><code>request</code> ：一个请求对应一个  <code>Bean</code>  。<strong>仅限于在 WEB 应用中使用</strong>。</li><li><code>session</code> ：一个会话对应一个  <code>Bean</code>  。<strong>仅限于在 WEB 应用中使用</strong>。</li><li><code>global session</code> ：<strong>portlet 应用中专用的</strong>。如果在  <code>Servlet</code>  的  <code>WEB</code>  应用中使用  <code>global session</code>  的话，和  <code>session</code>  一个效果。（  <code>portlet</code>  和  <code>servlet</code>  都是规范。servlet 运行在 servlet 容器中，例如  <code>Tomcat</code>  。 <code>portlet</code>  运行在  <code>portlet</code>  容器中。）</li><li><code>application</code> ：一个应用对应一个  <code>Bean</code>  。<strong>仅限于在 WEB 应用中使用。</strong></li><li><code>websocket</code> ：一个  <code>websocket</code>  生命周期对应一个  <code>Bean</code>  。<strong>仅限于在 WEB 应用中使用。</strong></li><li>自定义  <code>scope</code> ：很少使用。</li></ul><h2 id="bean的创造"><a class="markdownIt-Anchor" href="#bean的创造">#</a> bean 的创造</h2><h3 id="通过构造方法实例化"><a class="markdownIt-Anchor" href="#通过构造方法实例化">#</a> 通过构造方法实例化</h3><p>默认情况下， <code>Spring</code>  会调用构造方法进行实例化</p><h3 id="通过简单工厂模式实例化"><a class="markdownIt-Anchor" href="#通过简单工厂模式实例化">#</a> 通过简单工厂模式实例化</h3><p>如下所示，需要申明一个带有<strong>静态方法的工厂类</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StarFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Star <span class="hljs-title function_">getStar</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Star</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后申明  <code>bean</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">注意申明的bean的class属性为该工厂类而不是产品类，且通过factory-method属性申明哪个方法作为产品类的生产方法</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.bean.SimpleStarFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;get&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>之后就可以通过  <code>id</code>  或者  <code>class</code>  获得  <code>bean</code></p><blockquote><p>如果要为  <code>factory-method</code>  转递参数，再  <code>bean</code>  中通过  <code>&lt;constructor-arg&gt;</code>  进行传递</p></blockquote><h3 id="通过factory-bean实例化"><a class="markdownIt-Anchor" href="#通过factory-bean实例化">#</a> 通过 factory-bean 实例化</h3><p>如下所示，需要申明一个带有<strong>实例方法的工厂类</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StarFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> Star <span class="hljs-title function_">getStar</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Star</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后申明  <code>bean</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">首先要把该工厂类进行实例化，应为生产方法是实例方法</span><br><span class="hljs-comment">在产品类的bean中，在factory-bean属性中填入工厂类bean的id，表明对应的工厂类，其次使用factory-method属性申明生产产品类的生产方法</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;factory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.bean.StarFactory&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;star&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.bean.Star&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;factory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getStar&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>之后就可以通过  <code>id</code>  或者  <code>class</code>  获得  <code>bean</code></p><blockquote><p>如果要为  <code>factory-method</code>  转递参数，再  <code>bean</code>  中通过  <code>&lt;constructor-arg&gt;</code>  进行传递</p></blockquote><h3 id="通过factorybean接口实例化"><a class="markdownIt-Anchor" href="#通过factorybean接口实例化">#</a> 通过 FactoryBean 接口实例化</h3><p>如下所示，需要声明一个实现了  <code>FactoryBean</code>  接口的工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;Product&gt; &#123;<br>    <span class="hljs-comment">//生产方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>    &#125;<br><span class="hljs-comment">//返回对应的类型</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>        <span class="hljs-keyword">return</span> Product.class;<br>    &#125;<br><span class="hljs-comment">//判断是否单例。注意该方法时默认方法，返回true，也就是单例，如果不想为单例，则返回false</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> FactoryBean.<span class="hljs-built_in">super</span>.isSingleton();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后申明  <code>bean</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">直接申明该工厂类，即可创造出对应产品类</span><br><span class="hljs-comment">如果，需要引用产品类直接引用该bean即可</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.bean.ProductFactory&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>之后就可以通过  <code>id</code>  或者  <code>class</code>  获得  <code>bean</code></p><blockquote><p>实例化  <code>FactoryBean</code>  接口的被成为 工厂  <code>bean</code></p></blockquote><h4 id="beanfactory和factorybean的区别"><a class="markdownIt-Anchor" href="#beanfactory和factorybean的区别">#</a> BeanFactory 和 FactoryBean 的区别</h4><h5 id="beanfactory"><a class="markdownIt-Anchor" href="#beanfactory">#</a> BeanFactory</h5><p><code>Spring IoC</code>  容器的顶级对象， <code>BeanFactory</code>  被翻译为 “Bean 工厂”，在  <code>Spring</code>  的  <code>IoC</code>  容器中，“Bean 工厂” 负责创建  <code>Bean</code>  对象。</p><p><code>BeanFactory</code>  是工厂。</p><h5 id="factorybean"><a class="markdownIt-Anchor" href="#factorybean">#</a> FactoryBean</h5><p><code>FactoryBean</code> ：它是一个  <code>Bean</code>  ，是一个能够<strong>辅助 Spring</strong> 实例化其它  <code>Bean</code>  对象的一个  <code>Bean</code>  。</p><p>在  <code>Spring</code>  中， <code>Bean</code>  可以分为两类：</p><ul><li>第一类：普通 <code>Bean</code></li><li>第二类：工厂  <code>Bean</code> （记住：工厂  <code>Bean</code>  也是一种  <code>Bean</code>  ，只不过这种  <code>Bean</code>  比较特殊，它可以辅助  <code>Spring</code>  实例化其它  <code>Bean</code>  对象。）</li></ul><h3 id="bean的生命周期"><a class="markdownIt-Anchor" href="#bean的生命周期">#</a> bean 的生命周期</h3><h4 id="什么是bean的生命周期"><a class="markdownIt-Anchor" href="#什么是bean的生命周期">#</a> 什么是 Bean 的生命周期</h4><p>Spring 其实就是一个管理 Bean 对象的工厂。它负责对象的创建，对象的销毁等。</p><p>所谓的生命周期就是：对象从创建开始到最终销毁的整个过程。</p><p>什么时候创建 Bean 对象？创建 Bean 对象的前后会调用什么方法？Bean 对象什么时候销毁？Bean 对象的销毁前后调用什么方法？</p><h4 id="为什么要知道bean的生命周期"><a class="markdownIt-Anchor" href="#为什么要知道bean的生命周期">#</a> 为什么要知道 Bean 的生命周期</h4><p>其实生命周期的本质是：<strong>在哪个时间节点上调用了哪个类的哪个方法。</strong></p><p>我们需要充分的了解在这个生命线上，都有哪些特殊的时间节点。只有我们知道了特殊的时间节点都在哪，到时我们才可以确定代码写到哪。我们可能需要在某个特殊的时间点上执行一段特定的代码，这段代码就可以放到这个节点上。当生命线走到这里的时候，自然会被调用。</p><blockquote><p>Bean 生命周期的管理，可以参考  <code>Spring</code>  的源码： <strong> <code>AbstractAutowireCapableBeanFactory</code>  类的  <code>doCreateBean()</code>  方法 。</strong></p></blockquote><h4 id="bean的生命周期之5步"><a class="markdownIt-Anchor" href="#bean的生命周期之5步">#</a> Bean 的生命周期之 5 步</h4><p><code>Bean</code>  生命周期可以粗略的划分为五大步：</p><ul><li>第一步：实例化  <code>Bean</code></li><li>第二步： <code>Bean</code>  属性赋值</li><li>第三步：初始化  <code>Bean</code><ul><li>通过自定义一个方法进行初始化</li></ul></li><li>第四步：使用  <code>Bean</code></li><li>第五步：销毁  <code>Bean</code><ul><li>通过自定义一个方法进行销毁</li></ul></li></ul><img src="lifecycle5.png" alt="bean生命周期之5步"/><p>我们来看下面这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//我们定义了一个类，该类含有两个特殊的方法，initBean用来初始化bean，destroyBean用来销毁bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;第一步实例化bean&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;第二步属性赋值&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        System.out.printf(<span class="hljs-string">&quot;%s: &quot;</span>,<span class="hljs-string">&quot;第四步使用bean&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initBean</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;第三步初始化bean&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroyBean</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;第五步销毁bean&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义好这个类后，我们尝试将他注册为  <code>bean</code>  ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">光自定义初始化和摧毁方法不行，我们要让Spring知道这是哪些方法，这样Spring才能准确的回调他们</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.lifecycle.User&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;initBean&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroyBean&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>随后我们从  <code>ioc</code>  容器中取出这个  <code>bean</code>  然后打印这个  <code>bean</code>  :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    ConfigurableApplicationContext ioc= <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;lifecycle.xml&quot;</span>);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> ioc.getBean(User.class);<br>    System.out.println(user);<br>    <span class="hljs-comment">//此方法用于关闭ioc容器，销毁方法只有在ioc容器关闭后才会回调</span><br>    ioc.registerShutdownHook();<br>&#125;<br></code></pre></td></tr></table></figure><p>不出意外，你将会看到以下五个生命周期步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">第一步: 实例化bean<br>第二步: 属性赋值<br>第三步: 初始化<br>第四步: 使用bean: User&#123;name=&#x27;123&#x27;&#125;<br>第五步: 销毁bean<br></code></pre></td></tr></table></figure><h4 id="bean的生命周期之7步"><a class="markdownIt-Anchor" href="#bean的生命周期之7步">#</a> Bean 的生命周期之 7 步</h4><p>在以上的五步中，第三步是初始化 Bean，如果你还想在<strong>初始化前</strong>和<strong>初始化后</strong>添加代码，可以加入 **“Bean 后处理器”**。就形成了七个生命周期步骤。</p><img src="lifecycle7.png" alt="bean生命周期之7步"/><p>我们重新创建一个  <code>LogBeanPostProcessor</code>  类并实现  <code>BeanPostProcessor</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;第五步: BeanPostProcessor的after方法执行&quot;</span>);<br>        <span class="hljs-keyword">return</span> BeanPostProcessor.<span class="hljs-built_in">super</span>.postProcessAfterInitialization(bean, beanName);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;第三步: BeanPostProcessor的before方法执行&quot;</span>);<br>        <span class="hljs-keyword">return</span> BeanPostProcessor.<span class="hljs-built_in">super</span>.postProcessBeforeInitialization(bean, beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义好这个类后，我们尝试将他注册为  <code>bean</code>  ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">这将为这个xml文件代表的ioc容器创建一个全局的Bean后处理器，任何bean都会触发</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.lifecycle.LogBeanPostProcessor&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>随后我们从  <code>ioc</code>  容器中取出  <code>user</code>  然后打印这个  <code>bean</code>  :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    ConfigurableApplicationContext ioc= <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;lifecycle.xml&quot;</span>);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> ioc.getBean(User.class);<br>    System.out.println(user);<br>    <span class="hljs-comment">//此方法用于关闭ioc容器，销毁方法只有在ioc容器关闭后才会回调</span><br>    ioc.registerShutdownHook();<br>&#125;<br></code></pre></td></tr></table></figure><p>不出意外，你将会看到以下七个生命周期步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">第一步: 实例化bean<br>第二步: 属性赋值<br>第三步: BeanPostProcessor的before方法执行<br>第四步: 初始化<br>第五步: BeanPostProcessor的after方法执行<br>第六步使用bean: User&#123;name=&#x27;123&#x27;&#125;<br>第七步: 销毁bean<br></code></pre></td></tr></table></figure><h4 id="bean的生命周期之10步"><a class="markdownIt-Anchor" href="#bean的生命周期之10步">#</a> Bean 的生命周期之 10 步</h4><p>如果根据源码跟踪，可以划分更细粒度的步骤，我们通过  <code>*Aware</code>  接口、 <code>InitializingBean</code>  接口和  <code>DisposableBean</code>  来实现。</p><p><code>*Aware</code>  接口会在  <code>InitializingBean</code>  接口之前执行</p><p><code>InitializingBean</code>  接口会在初始方法调用前和  <code>BeanPostProcessor</code>  的  <code>before</code>  方法调用前执行。</p><p><code>DisposableBean</code>  接口会在销毁方法调用前和使用  <code>bean</code>  执行。</p><img src="lifecycle10.png" alt="bean生命周期之10步"/><p>仍然使用  <code>User</code>  类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanNameAware</span>, BeanClassLoaderAware, BeanFactoryAware, InitializingBean, DisposableBean &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;第一步: 实例化bean&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;第二步: 属性赋值&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        System.out.printf(<span class="hljs-string">&quot;%s: &quot;</span>,<span class="hljs-string">&quot;第八步使用bean&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initBean</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;第六步: 初始化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroyBean</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;第十步: 销毁bean&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//该方法为BeanClassLoaderAware的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanClassLoader</span><span class="hljs-params">(ClassLoader classLoader)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;第三步: BeanClassLoaderAware&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//该方法为BeanFactoryAware的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;第三步: BeanFactoryAware&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//该方法为BeanNameAware的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;第三步: BeanNameAware&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//该方法为DisposableBean的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;第九步: destroy执行&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//该方法为InitializingBean的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;第五步: afterPropertiesSet执行&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;第七步: BeanPostProcessor的after方法执行&quot;</span>);<br>        <span class="hljs-keyword">return</span> BeanPostProcessor.<span class="hljs-built_in">super</span>.postProcessAfterInitialization(bean, beanName);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;第三步: BeanPostProcessor的before方法执行&quot;</span>);<br>        <span class="hljs-keyword">return</span> BeanPostProcessor.<span class="hljs-built_in">super</span>.postProcessBeforeInitialization(bean, beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义好这两个类后，我们尝试将他注册为  <code>bean</code>  ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">这将为这个xml文件代表的ioc容器创建一个全局的Bean后处理器，任何bean都会触发</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.lifecycle.LogBeanPostProcessor&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">光自定义初始化和摧毁方法不行，我们要让Spring知道这是哪些方法，这样Spring才能准确的回调他们</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.lifecycle.User&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;initBean&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroyBean&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>随后我们从  <code>ioc</code>  容器中取出这个  <code>bean</code>  然后打印这个  <code>bean</code>  :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    ConfigurableApplicationContext ioc= <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;lifecycle.xml&quot;</span>);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> ioc.getBean(User.class);<br>    System.out.println(user);<br>    <span class="hljs-comment">//此方法用于关闭ioc容器，销毁方法只有在ioc容器关闭后才会回调</span><br>    ioc.registerShutdownHook();<br>&#125;<br></code></pre></td></tr></table></figure><p>不出意外，你将会看到以下十个生命周期步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">第一步: 实例化bean<br>第二步: 属性赋值<br>第三步: BeanNameAware<br>第三步: BeanClassLoaderAware<br>第三步: BeanFactoryAware<br>第四步: BeanPostProcessor的before方法执行<br>第五步: afterPropertiesSet执行<br>第六步: 初始化<br>第七步: BeanPostProcessor的after方法执行<br>第八步使用bean: User&#123;name=&#x27;123&#x27;&#125;<br>第九步: destroy执行<br>第十步: 销毁bean<br></code></pre></td></tr></table></figure><p><code>Spring</code>  提供了一系列的  <code>Aware</code>  回调接口，让  <code>Bean</code>  向容器表明它们需要某种基础设施的依赖性：</p><table><thead><tr><th style="text-align:left">接口名称</th><th style="text-align:left">注入的依赖性</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>ApplicationContextAware</code></td><td style="text-align:left">声明  <code>ApplicationContext</code> 。</td><td style="text-align:left"><a href="https://Springdoc.cn/Spring/core.html#beans-factory-aware">ApplicationContextAware 和 BeanNameAware</a></td></tr><tr><td style="text-align:left"><code>ApplicationEventPublisherAware</code></td><td style="text-align:left">封装了  <code>ApplicationContext</code>  的 Event publisher 。</td><td style="text-align:left"><a href="https://Springdoc.cn/Spring/core.html#context-introduction">ApplicationContex 的附加功能</a></td></tr><tr><td style="text-align:left"><code>BeanClassLoaderAware</code></td><td style="text-align:left">用来加载 Bean 类的类加载器（Class loader）。</td><td style="text-align:left"><a href="https://Springdoc.cn/Spring/core.html#beans-factory-class">实例化 Bean</a></td></tr><tr><td style="text-align:left"><code>BeanFactoryAware</code></td><td style="text-align:left">声明  <code>BeanFactory</code> 。</td><td style="text-align:left"><a href="https://Springdoc.cn/Spring/core.html#beans-beanfactory">BeanFactory API</a></td></tr><tr><td style="text-align:left"><code>BeanNameAware</code></td><td style="text-align:left">声明  <code>Bean</code>  的名称。</td><td style="text-align:left"><a href="https://Springdoc.cn/Spring/core.html#beans-factory-aware">ApplicationContextAware 和 BeanNameAware</a></td></tr><tr><td style="text-align:left"><code>LoadTimeWeaverAware</code></td><td style="text-align:left">定义了用于在加载时处理类定义的织入点。</td><td style="text-align:left"><a href="https://Springdoc.cn/Spring/core.html#aop-aj-ltw">在 Spring 框架中用 AspectJ 进行加载时织入（Load-time Weaving）</a></td></tr><tr><td style="text-align:left"><code>MessageSourceAware</code></td><td style="text-align:left">配置解析消息的策略（支持参数化和国际化）。</td><td style="text-align:left"><a href="https://Springdoc.cn/Spring/core.html#context-introduction">ApplicationContext 的附加功能</a></td></tr><tr><td style="text-align:left"><code>NotificationPublisherAware</code></td><td style="text-align:left"><code>Spring JMX notification publisher</code> 。</td><td style="text-align:left"><a href="https://Springdoc.cn/Spring/integration.html#jmx-notifications">Notifications</a></td></tr><tr><td style="text-align:left"><code>ResourceLoaderAware</code></td><td style="text-align:left">配置的加载器用于低级别的资源访问。</td><td style="text-align:left"><a href="https://Springdoc.cn/Spring/core.html#resources">资源（Resources）</a></td></tr><tr><td style="text-align:left"><code>ServletConfigAware</code></td><td style="text-align:left">容器所运行的当前  <code>ServletConfig</code> 。仅在 Web 感知的 Spring  <code>ApplicationContext</code>  中有效。</td><td style="text-align:left"><a href="https://Springdoc.cn/Spring/web.html#mvc">Spring MVC</a></td></tr></tbody></table><h4 id="不同作用域的生命周期"><a class="markdownIt-Anchor" href="#不同作用域的生命周期">#</a> 不同作用域的生命周期</h4><p>对于  <code>singleton</code>  作用域的  <code>Bean</code> ， <code>Spring</code>  能够精确地知道该  <code>Bean</code>  何时被创建，何时初始化完成，以及何时被销毁；</p><p>而对于  <code>prototype</code>  作用域的  <code>Bean</code>  ， <code>Spring</code>  只负责创建，当容器创建了  <code>Bean</code>  的实例并初始化后， <code>Bean</code>  的实例就交给客户端代码管理， <code>Spring</code>  容器将不再跟踪其生命周期。</p><p>依然是上面的  <code>user</code>  类，我们将这个类的作用域转换为  <code>prototype</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">第一步: 实例化bean<br>第二步: 属性赋值<br>第三步: BeanNameAware<br>第三步: BeanClassLoaderAware<br>第三步: BeanFactoryAware<br>第三步: ApplicationContextAware<br>第四步: BeanPostProcessor的before方法执行<br>第五步: afterPropertiesSet执行<br>第六步: 初始化<br>第七步: BeanPostProcessor的after方法执行<br>第八步: 使用bean: User&#123;name=&#x27;123&#x27;&#125;<br></code></pre></td></tr></table></figure><p>我们看到只执行到了第八步，也就是说  <code>Spring</code>  不再管理其的销毁程序。</p><h4 id="将自己实例化的对象加入到ioc容器"><a class="markdownIt-Anchor" href="#将自己实例化的对象加入到ioc容器">#</a> 将自己实例化的对象加入到 IoC 容器</h4><p>可以通过  <code>getBeanFactory()</code>  方法访问  <code>ApplicationContext</code>  的  <code>BeanFactory</code>  来实现，该方法返回  <code>DefaultListableBeanFactory</code>  实现。 <code>DefaultListableBeanFactory</code>  通过  <code>registerSingleton(..)</code>  和  <code>registerBeanDefinition(..)</code>  方法支持这种注册。</p><h3 id="bean的循环依赖"><a class="markdownIt-Anchor" href="#bean的循环依赖">#</a> bean 的循环依赖</h3><p>当我们创建  <code>bean</code>  的时候可能会遇到这个问题：两个对象互相依赖了对方，即  <code>A</code>  的属性包括  <code>B</code>  ,  <code>B</code>  的属性包括了  <code>A</code> 。</p><p>我们创建下面两个类  <code>Wife</code>  和  <code>Husband</code>  类：</p><img src="huswife.png" alt="Husband类和Wife类的关系"><p>由该图可知  <code>Husband</code>  和  <code>Wife</code>  构成了循环依赖</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Husband</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Wife wife;<br>    <span class="hljs-comment">// toString()方法重写时需要注意：不能直接输出wife，输出wife.getName()。要不然会出现递归导致的栈内存溢出错误。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Husband&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, wife=&quot;</span> + wife.getName() +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wife</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Husband husband;<br><br>    <span class="hljs-comment">// toString()方法重写时需要注意：不能直接输出husband，输出husband.getName()。要不然会出现递归导致的栈内存溢出错误。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Wife&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, husband=&quot;</span> + husband.getName() +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们将其配置成  <code>bean</code>  ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;husband&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.cycle.bean.Husband&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hello&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;wife&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;wife&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jhy.cycle.bean.Wife&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;wife&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;world&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;husband&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;husband&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过  <code>ioc</code>  容器获取这两个  <code>bean</code>  后，我们打印这两个类，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Husband&#123;name=&#x27;hello&#x27;, wife=world&#125;<br>Wife&#123;name=&#x27;world&#x27;, husband=hello&#125;<br></code></pre></td></tr></table></figure><p>可见这两个对象的属性都分配成功， <code>Spring</code>  成功解决了循环依赖问题，为什么会这样呢？</p><p>在上述情况下我们使用的是  <code>singleton</code>  和  <code>set</code>  注入的情况，下节将会回答这个问题。</p><h4 id="set注入的情况"><a class="markdownIt-Anchor" href="#set注入的情况">#</a> set 注入的情况</h4><h5 id="全部为singleton"><a class="markdownIt-Anchor" href="#全部为singleton">#</a> 全部为 singleton</h5><p>在此情况下  <code>Spring</code>  将  <code>bean</code>  的创建分成两个步骤：</p><ol><li><code>Spring</code>  会先将  <code>bean</code>  实例化了出来，此时  <code>bean</code>  的各个属性都没有赋值，处于 “曝光” 状态，意味着此时  <code>bean</code>  已经可以被其他  <code>bean</code>  知晓并使用。</li><li>被创建出来的  <code>bean</code>  通过  <code>setter</code>  方法进行赋值。</li></ol><p>因此，两个单例的  <code>bean</code>  再进行属性赋值的时候全部都已经存在，所以才不会存在循环依赖的问题。</p><p><code>Spring</code>  官方文档如下解释说：</p><blockquote><p>当容器被创建时， <code>Spring</code>  容器会验证每个  <code>Bean</code>  的配置。然而，在实际创建  <code>Bean</code>  之前， <code>Bean</code>  的属性本身不会被设置。当容器被创建时，那些具有单例作用域并被设置为预实例化的  <code>Bean</code> （默认）被创建。创建  <code>bean</code>  有可能导致创建  <code>bean</code>  图（graph），因为  <code>bean</code>  的依赖关系和它的依赖关系（等等）被创建和分配。请注意，这些依赖关系之间的解析不匹配可能会出现得很晚 — 也就是说，在第一次创建受影响的  <code>Bean</code>  时。</p></blockquote><h5 id="单个为singleton"><a class="markdownIt-Anchor" href="#单个为singleton">#</a> 单个为 singleton</h5><p>下面我们将  <code>wife bean</code>  改为  <code>prototype</code>  ，再次运行观察结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Husband&#123;name=&#x27;hello&#x27;, wife=world&#125;<br>Wife&#123;name=&#x27;world&#x27;, husband=hello&#125;<br></code></pre></td></tr></table></figure><p>仍然运行成功。可见，只要两个  <code>bean</code>  的作用域有一个为单例即可解决循环依赖问题。</p><p>我们知道作用域处于  <code>prototype</code>  的  <code>bean</code>  只有在被需要的时候才会被创建，所以当单例的  <code>bean</code>  需要一个原型的  <code>bean</code>  时，该原型的  <code>bean</code>  才会被创建，而该原型  <code>bean</code>  需要单例的  <code>bean</code>  的时候，该单例  <code>bean</code>  早已存在，所以循环依赖问题不会发生。</p><h5 id="全部为prototype"><a class="markdownIt-Anchor" href="#全部为prototype">#</a> 全部为 prototype</h5><p>作用域处于  <code>prototype</code>  的  <code>bean</code>  只有在被需要的时候才会被创建，且会返回不同的实例。我们以上面的  <code>Wife</code>  和  <code>Husband</code>  举例。</p><p>所以当  <code>Wife</code>  创建的时候，会去创建另一个  <code>Husband</code>  ；而当  <code>Husband</code>  创建时，会创建另一个  <code>Wife</code>  。由于原型每次创建新的  <code>bean</code>  的特性，每次创建的  <code>Husband</code>  和  <code>Wife</code>  都不相同，所以会一直创建下去。循环依赖问题并不会解决</p><p>当我们将  <code>bean</code>  的作用域全部改为  <code>prototype</code>  ，再次运行时会发现，程序抛出了下面的异常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">org.springframework.beans.factory.BeanCurrentlyInCreationException: <br>Error creating bean with name &#x27;husband&#x27;: <br>Requested bean is currently in creation: Is there an unresolvable circular reference?<br></code></pre></td></tr></table></figure><p>代表着循环依赖问题并没有解决</p><h4 id="构造器注入的情况"><a class="markdownIt-Anchor" href="#构造器注入的情况">#</a> 构造器注入的情况</h4><p>上面说过，只有实例化和注入的步骤分开的时候，循环依赖的情况才会解决，所以当使用构造器注入的时候，是实例化和注入同时进行，此时依赖的  <code>bean</code>  并没有创建，所以也不存在能解决循环问题的办法。因此，构造器注入无法解决循环依赖问题。</p><p>我们将注入改为构造器注入，运行后仍然会发现，程序抛出了  <code>BeanCreationException</code>  异常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">org.Springframework.beans.factory.BeanCreationException: <br>Error creating bean with name &#x27;husband&#x27; defined in class path resource [Spring.xml]: <br>Cannot resolve reference to bean &#x27;wife&#x27; while setting constructor argument<br></code></pre></td></tr></table></figure><h4 id="三级依赖解决循环依赖源码"><a class="markdownIt-Anchor" href="#三级依赖解决循环依赖源码">#</a> 三级依赖解决循环依赖 (源码)</h4><p>注意解决循环依赖问题建立在：单例和  <code>set</code>  注入的情况下。</p><p>让我们进入： <strong> <code>AbstractAutowireCapableBeanFactory</code>  类的  <code>doCreateBean()</code>  方法</strong> ，所有的单例  <code>bean</code>  都在这里创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br><span class="hljs-keyword">throws</span> BeanCreationException &#123;<br><br><span class="hljs-comment">// Instantiate the bean.下面就是在实例化bean</span><br><span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>instanceWrapper = <span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>&#125;<br><span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>instanceWrapper = createBeanInstance(beanName, mbd, args);<br>&#125;<br><span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> instanceWrapper.getWrappedInstance(); <span class="hljs-comment">//该方法就是已经获得了实例化的bean，此时该bean的所有属性均没有被赋值</span><br>Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass(); <br><span class="hljs-keyword">if</span> (beanType != NullBean.class) &#123;<br>mbd.resolvedTargetType = beanType;<br>&#125;<br>......<br><span class="hljs-comment">//注意下面的代码块</span><br><span class="hljs-comment">// Eagerly cache singletons to be able to resolve circular references</span><br>    <span class="hljs-comment">// 急切地缓存单例以便能够解决循环依赖</span><br><span class="hljs-comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br>    <span class="hljs-comment">// 甚至当被如BeanFactoryAware生命周期接口触发地时候</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-built_in">this</span>.allowCircularReferences &amp;&amp;<br>isSingletonCurrentlyInCreation(beanName)); <span class="hljs-comment">//判断是否要解决循环依赖问题</span><br><span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(<span class="hljs-string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +<br><span class="hljs-string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);<br>&#125;<br>            <span class="hljs-comment">//解决循环依赖地问题地办法就在这里，该方法位于DefaultSingletonBeanRegistry，让我们进入这个方法.....</span><br>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>&#125;<br>......<br>&#125;<br></code></pre></td></tr></table></figure><p><code>addSingletonFactory</code>  方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSingletonFactory</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br>Assert.notNull(singletonFactory, <span class="hljs-string">&quot;Singleton factory must not be null&quot;</span>);<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.singletonObjects.containsKey(beanName)) &#123; <br>                <span class="hljs-comment">/** 我们重点看这个表达式，它将bean的名字和创建这个bean的工厂放进了一个map集合里，</span><br><span class="hljs-comment">                也就是将这个对象提前曝光。这个map集合就是我们待会儿要说的三级缓存之一*/</span><br><span class="hljs-built_in">this</span>.singletonFactories.put(beanName, singletonFactory);<br><span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<br><span class="hljs-built_in">this</span>.registeredSingletons.add(beanName);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面就是  <code>DefaultSingletonBeanRegistry</code>  类的三个 map 集合属性，也就是–三级缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span><br><span class="hljs-comment">//三级缓存，单例工厂缓存。是bean名字和bean工厂的map集合。缓存创造对应bean的单例工厂，</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><br><span class="hljs-comment">/** Cache of early singleton objects: bean name to bean instance. */</span><br><span class="hljs-comment">//二级缓存，预实例化对象的缓存。是bean名字和预实例化的bean的map集合。缓存对应的属性未赋值的bean</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><br><span class="hljs-comment">/** Cache of singleton objects: bean name to bean instance. */</span><br><span class="hljs-comment">//一级缓存，单例对象的缓存。是bean名字和实例化后的bean的map集合。缓存对应的属性已经赋值的bean，也就是对象本身了。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br></code></pre></td></tr></table></figure><p>了解了三级缓存后，我们来到该类的另外一个方法  <code>getSingleton</code>  :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> allowEarlyReference)</span> &#123;<br>    <span class="hljs-comment">// 下面就是解决循环依赖的办法</span><br>    <span class="hljs-comment">// Quick check for existing instance without full singleton lock</span><br>    <span class="hljs-comment">//首先会从一级缓存中取该单例对象，看是否能取到</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>    <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br>        <span class="hljs-comment">//没有取到则去二级缓存取预实例化的单例对象</span><br>        singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br>        <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; allowEarlyReference) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>                <span class="hljs-comment">// Consistent creation of early reference within full singleton lock</span><br>                singletonObject = <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>                <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;              <br>                    singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br>                    <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">//最终都没有的话去三级缓存中去该对象的bean工厂</span><br>                        ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-built_in">this</span>.singletonFactories.get(beanName);<br>                        <span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">//然后通过该bean工厂回去对应的bean</span><br>                            singletonObject = singletonFactory.getObject();<br>                        <span class="hljs-comment">//加入二级缓存</span><br>                            <span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br>                        <span class="hljs-comment">//随后将该工厂移除</span><br>                            <span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singletonObject;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基于注解的ioc开发"><a class="markdownIt-Anchor" href="#基于注解的ioc开发">#</a> 基于注解的 Ioc 开发</h2><p><code>Spring</code>  提供了注解 + 扫描的方式来替代  <code>xml</code>  配置</p><h3 id="原理"><a class="markdownIt-Anchor" href="#原理">#</a> 原理</h3><p>现在让我们创建一个注解  <code>@Component</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Component &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><span class="hljs-comment">//将这个注解加到一个类上去</span><br><span class="hljs-meta">@Component(&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当我获得了这个类的包名并且想让标注了这个注解的类能被实例化，并添加至一个 map 集合里，那我们应该怎么做？答案是使用反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testComponentScan</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">packageName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.jhy.bean&quot;</span>; <span class="hljs-comment">//包名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">packagePath</span> <span class="hljs-operator">=</span> packageName.replaceAll(<span class="hljs-string">&quot;\\.&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>); <span class="hljs-comment">//将包名改成路径</span><br><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader().getResource(packagePath);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> resource.getPath();<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path); <span class="hljs-comment">//获得磁盘路径的File对象</span><br>        File[] files = file.listFiles(); <span class="hljs-comment">//查找该路径下的所有文件</span><br><br><span class="hljs-comment">//循环遍历</span><br>        Arrays.stream(files).forEach(f -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> packageName + <span class="hljs-string">&quot;.&quot;</span> + f.getName().split(<span class="hljs-string">&quot;\\.&quot;</span>)[<span class="hljs-number">0</span>]; <span class="hljs-comment">//获得类的全限定名</span><br>            Class&lt;?&gt; aClass = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                aClass = Class.forName(className); <span class="hljs-comment">//获得该类的字节码对象</span><br>                <span class="hljs-keyword">if</span> (aClass.isAnnotationPresent(Component.class)) &#123; <span class="hljs-comment">//判断是否标注了注解，标注了注解就通过反射实例化</span><br>                    <span class="hljs-type">Component</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> aClass.getAnnotation(Component.class);<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> annotation.value(); <span class="hljs-comment">//获得注解的值</span><br>                    Constructor&lt;?&gt; constructor = aClass.getConstructor();<br>                    <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> constructor.newInstance(); <span class="hljs-comment">//实例化</span><br>                    map.put(value,target); <span class="hljs-comment">//添加到一个map集合里</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        System.out.println(map); <span class="hljs-comment">//打印集合</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;user=com.jhy.bean.User@e580929&#125;<br></code></pre></td></tr></table></figure><p>如果你将这个注解添加至包下的更多类上，那么 map 结合中将会包含所有被标注了这个注解的实例。</p><p>如上就是  <code>IoC</code>  的注解开发的原理：扫描包下的所有类，将所有标注了指定注解的类通过反射调用进行实例化。</p><h3 id="注解"><a class="markdownIt-Anchor" href="#注解">#</a> 注解</h3><p><code>Spring</code>  提供了四个注解来进行注解开发：</p><ul><li><code>@Component</code> ：注解普通的类</li><li><code>@Controller</code> ：注解表示层的类</li><li><code>@Service</code> ：注解业务层的类</li><li><code>@Repository</code> ：注解数据访问层的类</li></ul><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Indexed</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Component &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The value may indicate a suggestion for a logical component name,</span><br><span class="hljs-comment"> * to be turned into a Spring bean name in case of an autodetected component.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span><br><span class="hljs-comment"> */</span><br>String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>&#125;<br><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Controller &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Alias for &#123;<span class="hljs-doctag">@link</span> Component#value&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AliasFor(annotation = Component.class)</span><br>String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>&#125;<br><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Service &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Alias for &#123;<span class="hljs-doctag">@link</span> Component#value&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AliasFor(annotation = Component.class)</span><br>String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>&#125;<br><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Repository &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Alias for &#123;<span class="hljs-doctag">@link</span> Component#value&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AliasFor(annotation = Component.class)</span><br>String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>除  <code>@Conponent</code>  的三个注解都被  <code>@Componet</code>  注解了，因此其余三个注解都是  <code>@Component</code>  的衍生注解，功能一样。</p></blockquote><p>上述注解的  <code>value()</code>  属性代表该类实例化后的  <code>id</code>  或者  <code>name</code>  ，如果省略，则以该类的首字母小写的类名作为实例化后的  <code>id</code>  或者  <code>name</code>  。</p><h4 id="使用注解"><a class="markdownIt-Anchor" href="#使用注解">#</a> 使用注解</h4><p>前面提到基于注解的  <code>IoC</code>  开发时采用的扫描 + 反射的原理进行的。所以，注解存在，下面我们来进行扫描：</p><p>如果使用  <code>xml</code>  进行扫描，就要使用  <code>context</code>  命名空间下的标签了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.Springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span> = <span class="hljs-string">&quot;http://www.Springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.Springframework.org/schema/beans </span></span><br><span class="hljs-string"><span class="hljs-tag">                           http://www.Springframework.org/schema/beans/Spring-beans.xsd </span></span><br><span class="hljs-string"><span class="hljs-tag">                           http://www.Springframework.org/schema/context http://www.Springframework.org/schema/context/Spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">使用context确保下面的约束存在</span><br><span class="hljs-comment">xmlns:context = &quot;http://www.Springframework.org/schema/context&quot;</span><br><span class="hljs-comment"> xsi:schemaLocation =  &quot;http://www.Springframework.org/schema/context </span><br><span class="hljs-comment">http://www.Springframework.org/schema/context/Spring-context.xsd&quot;</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">component-scan专门用来进行扫描</span><br><span class="hljs-comment">base-package则为扫描的包的范围，如果要扫描多个包，可以用逗号，分号，空格等进行分割</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package则为扫描的包</span>=<span class="hljs-string">&quot;com.jhy.anno.beans&quot;</span>/&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">如果你想选择性实例化一些Bean，可以禁用默认的包扫描过滤器：use-default-filters=&quot;false“，use-default-filters默认是true</span><br><span class="hljs-comment">然后自己去设计自定义的包含过滤器：&lt;context:include-filter&gt;用来指定包含的过滤器，type指定包含策略，expression指定策略的详细信息</span><br><span class="hljs-comment">如下的内容表示将会让被@Repository注解的类注册为bean</span><br><span class="hljs-comment">请注意：&lt;context:include-filter&gt;必须和use-default-filters=&quot;false&quot;使用才会生效</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package则为扫描的包</span>=<span class="hljs-string">&quot;com.jhy.anno.beans&quot;</span>  <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.Springframework.stereotype.Repository&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">如果你想选择性实例化一些Bean，也可以选择自定义排除过滤器，排除过滤器和use-default-filters=&quot;true&quot;一起工作</span><br><span class="hljs-comment">当然，use-default-filters默认为true，所以可以不写</span><br><span class="hljs-comment">&lt;context:exclude-filter&gt;排除过滤器 type指定排除策略，expression指定策略的详细信息</span><br><span class="hljs-comment">如下的内容表示不会将被@Service标注的类注解为bean</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package则为扫描的包</span>=<span class="hljs-string">&quot;com.jhy.anno.beans&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.Springframework.stereotype.Service&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如下为排除过滤器和包含过滤器的一些详细信息：</p><table><thead><tr><th style="text-align:left">Filter Type</th><th style="text-align:left">示例表达式</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">注解 (annotation) (默认)</td><td style="text-align:left"><code>org.example.SomeAnnotation</code></td><td style="text-align:left">一个注解在目标组件中的类型级别是 <em>present</em> 或 <em>meta-present</em>。</td></tr><tr><td style="text-align:left">可指定 (assignable)</td><td style="text-align:left"><code>org.example.SomeClass</code></td><td style="text-align:left">目标组件可分配给（继承或实现）的一个类（或接口）。</td></tr><tr><td style="text-align:left">aspectj</td><td style="text-align:left"><code>org.example..*Service+</code></td><td style="text-align:left">要被目标组件匹配的 AspectJ type 表达式。</td></tr><tr><td style="text-align:left">regex</td><td style="text-align:left"><code>org\.example\.Default.*</code></td><td style="text-align:left">一个与目标组件的类名相匹配的 regex expression。</td></tr><tr><td style="text-align:left">自定义 (custom)</td><td style="text-align:left"><code>org.example.MyTypeFilter</code></td><td style="text-align:left"><code>org.Springframework.core.type.TypeFilter</code>  接口的自定义实现。</td></tr></tbody></table><h4 id="自动装配"><a class="markdownIt-Anchor" href="#自动装配">#</a> 自动装配</h4><p>与  <code>xml</code>  的自动装配一样，注解式开发也提供了用于自动装配的注解</p><h5 id="value"><a class="markdownIt-Anchor" href="#value">#</a> @Value</h5><p><code>@Value</code>  用于简单类型的自动装配：</p><p><code>@Value</code>  的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE&#125;)</span> <span class="hljs-comment">//可以注解：属性、方法、参数、注解</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Value &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The actual value expression such as &lt;code&gt;#&#123;systemProperties.myProp&#125;&lt;/code&gt;</span><br><span class="hljs-comment"> * or property placeholder such as &lt;code&gt;$&#123;my.app.myProp&#125;&lt;/code&gt;.</span><br><span class="hljs-comment"> */</span><br>String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>; <span class="hljs-comment">//代表传入的简单类型字面值</span><br></code></pre></td></tr></table></figure><p>实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;123&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-meta">@Value(&quot;789&quot;)</span> String name)</span> &#123; <span class="hljs-comment">//通过构造器初始化</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Value(&quot;456&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>@Value</code> ：可以出现在：属性、构造器参数和  <code>setter</code>  方法上。注意当  <code>@Value</code>  出现在属性上时，不需要  <code>setter</code>  方法，因为反射的机理，导致能通过反射拿到值</p></blockquote><h5 id="autowired和qualifier"><a class="markdownIt-Anchor" href="#autowired和qualifier">#</a> @Autowired 和 @Qualifier</h5><p><code>@Autowired</code>  用来注解 “非简单类型”--  <code>Spring</code>  所认为的。</p><p><code>@Autowired</code>  的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-comment">//能注解：构造器、方法、参数、属性、注解</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Autowired &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Declares whether the annotated dependency is required.</span><br><span class="hljs-comment"> * &lt;p&gt;Defaults to &#123;<span class="hljs-doctag">@code</span> true&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">required</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//该属性代表该属性是否需要，默认为true则代表需要，也就是没找到能够注入的bean则会报错，如果为false则不会</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserService</span><span class="hljs-params">(<span class="hljs-meta">@Autowired</span> UserDao userDao)</span> &#123; <span class="hljs-comment">//通过构造器实例化</span><br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> UserDao <span class="hljs-title function_">getUserDao</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao;<br>    &#125;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(<span class="hljs-meta">@Autowired</span> UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">()</span>&#123;<br>        userDao.saveUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>特别的，当属性的名字和构造方法的参数名相同，且只有一个构造方法，那么不使用  <code>@Autowired</code>  也能完成自动装配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserService</span><span class="hljs-params">(UserDao userDao)</span> &#123; <span class="hljs-comment">//通过构造器实例化</span><br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>@Autowired</code>  能够注解在：属性、构造方法、参数、 <code>setter</code>  方法。且当  <code>@Autowired</code>  出现在属性上时，同样也不需要  <code>setter</code>  方法。</p><p>且注意  <code>@Autowired</code>  默认只能使用  <code>byType</code>  查找  <code>bean</code>  ，所以当容器中有多个相同类型的  <code>bean</code>  出现时，单使用  <code>@Autowired</code>  会报错。</p></blockquote><p>于是如果你想让  <code>@Autowired</code>  根据  <code>byName</code>  的方式查找  <code>bean</code>  的话，那么要和  <code>@Qualifier</code>  进行搭配使用。</p><p><code>@Qualifier</code>  的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-comment">//能够注解属性、方法、参数、类型</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Qualifier &#123;<br><br>String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">//代表某个bean的id</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;userDaoMysql&quot;)</span><br>    <span class="hljs-keyword">private</span> IUerDao userDao;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这样就会根据名字去查找  <code>id</code>  为  <code>userDaoMysql</code>  的  <code>bean</code></p></blockquote><p>或者如果你仍然想使用  <code>byType</code>  的方式查找那么可以使用  <code>@Primary</code>  注解</p><h5 id="primary"><a class="markdownIt-Anchor" href="#primary">#</a> @Primary</h5><p>因为按类型自动注入可能会导致多个候选者，所以经常需要对选择过程进行更多的控制。实现这一目标的方法之一是使用  <code>Spring</code>  的  <code>@Primary</code>  注解。 <code>@Primary</code>  表示，当多个 <code>bean</code>  是自动注入到一个单值（ <code>single value</code> ）依赖的候选者时，应该优先考虑一个特定的  <code>bean</code> 。如果在候选者中正好有一个主要（ <code>primary</code> ） <code>bean</code>  存在，它就会成为自动注入的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span> <span class="hljs-comment">//可以标注类型、方法</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Primary &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="resource"><a class="markdownIt-Anchor" href="#resource">#</a> @Resource</h5><p><code>@Resource</code>  注解也可以完成非简单类型注入。他有以下的特性：</p><ul><li><code>@Resource</code>  注解是  <code>JDK</code>  扩展包中的，也就是说属于  <code>JDK</code>  的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250 标准中制定的注解类型。JSR 是 Java 规范提案。)</li><li><strong> <code>@Resource</code>  注解默认根据名称装配  <code>byName</code>  ，未指定  <code>name</code>  时，使用属性名作为  <code>name</code>  。通过  <code>name</code>  找不到的话会自动启动通过类型  <code>byType</code>  装配。</strong></li><li><code>@Resource</code>  注解用在属性上、 <code>setter</code>  方法上。</li></ul><p>由于  <code>oracle</code>  在  <code>jdk9</code>  的时候将  <code>java ee</code>  捐献给了  <code>Apache</code>  基金会，并且改名  <code>jartarka ee</code>  ，所以引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.annotation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>@Resource</code>  的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;TYPE, FIELD, METHOD&#125;)</span> <span class="hljs-comment">//能注解类型、属性、方法</span><br><span class="hljs-meta">@Retention(RUNTIME)</span><br><span class="hljs-meta">@Repeatable(Resources.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Resource &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The JNDI name of the resource.  For field annotations,</span><br><span class="hljs-comment">     * the default is the field name.  For method annotations,</span><br><span class="hljs-comment">     * the default is the JavaBeans property name corresponding</span><br><span class="hljs-comment">     * to the method.  For class annotations, there is no default</span><br><span class="hljs-comment">     * and this must be specified.</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">//name属性用来接受bean的名称</span><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="全注解式开发"><a class="markdownIt-Anchor" href="#全注解式开发">#</a> 全注解式开发</h3><p>通过配置类取代  <code>xml</code>  文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.Springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.Springframework.context.annotation.ComponentScans;<br><span class="hljs-keyword">import</span> org.Springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//代表此类为一个配置类。</span><br><span class="hljs-meta">@ComponentScan(&#123;&quot;com.jhy.Spring6.dao&quot;, &quot;com.jhy.Spring6.service&quot;&#125;)</span> <span class="hljs-comment">//扫描包结构</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Spring6Configuration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@Configuration</code>  的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Component</span> <span class="hljs-comment">//@Configuration 被 @Component注解，代表该注解表示的类也会被注册为bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Configuration &#123;<br><span class="hljs-meta">@AliasFor(annotation = Component.class)</span><br>String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">//bean的名称</span><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>之前的  <code>ClassPathXmlApplicationContext</code>  也被  <code>AnnotationConfigApplicationContext</code>  取代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ioc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MyConfiguration.class); <span class="hljs-comment">//MyConfiguration.class为配置类的字节码对象</span><br></code></pre></td></tr></table></figure><h3 id="基于java的容器配置"><a class="markdownIt-Anchor" href="#基于java的容器配置">#</a> 基于 Java 的容器配置</h3><p>上面我们介绍了如何通过配置类的方式取代  <code>xml</code>  文件，那么下面我们介绍如何通过配置类配置  <code>bean</code>  以及一些额外信息。</p><p><code>Spring</code>  的  <code>Java</code>  配置支持的核心工件是  <code>@Configuration</code>  注解的类和  <code>@Bean</code>  注解的方法。</p><p><code>@Bean</code>  注解用来表示一个方法实例化、配置和初始化了一个新的对象，由  <code>Spring IoC</code>  容器管理。 <code>@Bean</code>  注解的作用与  <code>&lt;bean&gt;</code>  元素的作用相同。你可以在任何  <code>Spring</code>   <code>@Component</code>  中使用  <code>@Bean</code>  注解的方法。然而，它们最常被用于  <code>@Configuration</code>   <code>bean</code> 。</p><p>用  <code>@Configuration</code>  来注解一个类，表明它的主要目的是作为  <code>bean</code>  定义的来源。此外，  <code>@Configuration</code>  类允许通过调用同一个类中的其他  <code>@Bean</code>  方法来定义  <code>bean</code>  间的依赖关系。最简单的  <code>@Configuration</code>  类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyServiceImpl <span class="hljs-title function_">myService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServiceImpl</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面的  <code>AppConfig</code>  类等同于下面的 Spring  <code>&lt;beans/&gt;</code>  XML。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acme.services.MyServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="使用bean注解"><a class="markdownIt-Anchor" href="#使用bean注解">#</a> 使用 @Bean 注解</h4><p><code>@Bean</code>  是一个方法级注解，是 XML  <code>&lt;bean/&gt;</code>  元素的直接类似物。该注解支持  <code>&lt;bean/&gt;</code>  所提供的一些属性，例如：</p><ul><li><a href="#%E6%8E%A5%E6%94%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%9B%9E%E8%B0%83">init-method</a></li><li><a href="#%E6%8E%A5%E6%94%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%9B%9E%E8%B0%83">destroy-method</a></li><li>[autowiring](#Bean 依赖)</li><li><code>name</code></li></ul><p>你可以在  <code>@Configuration</code>  或  <code>@Component</code>  注解的类中使用  <code>@Bean</code>  注解。</p><h5 id="声明一个-bean"><a class="markdownIt-Anchor" href="#声明一个-bean">#</a> 声明一个 Bean</h5><p>为了声明一个 Bean，你可以用  <code>@Bean</code>  注解来注解一个方法。你可以用这个方法在  <code>ApplicationContext</code>  中注册一个 Bean 定义，该类型被指定为该方法的返回值。默认情况下，Bean 的名字和方法的名字是一样的。下面的例子显示了一个  <code>@Bean</code>  方法声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TransferServiceImpl <span class="hljs-title function_">transferService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面的配置完全等同于下面的 Spring XML。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transferService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这两个声明使  <code>ApplicationContext</code>  中一个名为  <code>transferService</code>  的 Bean 可用，并与  <code>TransferServiceImpl</code>  类型的对象实例绑定，正如下面的文字图片所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">transferService -&gt; com.acme.TransferServiceImpl<br></code></pre></td></tr></table></figure><p>你也可以使用  <code>default</code>  方法来定义  <code>bean</code> 。这允许通过在默认方法上实现带有  <code>bean</code>  定义的接口来组成  <code>bean</code>  配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BaseConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">default</span> TransferServiceImpl <span class="hljs-title function_">transferService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BaseConfig</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>你也可以用一个接口（或基类）的返回类型来声明你的  <code>@Bean</code>  方法，如下例所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TransferService <span class="hljs-title function_">transferService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="bean-依赖"><a class="markdownIt-Anchor" href="#bean-依赖">#</a> Bean 依赖</h5><p>一个  <code>@Bean</code>  注解的方法可以有任意数量的参数，描述构建该  <code>bean</code>  所需的依赖关系。例如，如果我们的  <code>TransferService</code>  需要一个  <code>AccountRepository</code> ，我们可以用一个方法参数将这种依赖关系具体化，如下例所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TransferService <span class="hljs-title function_">transferService</span><span class="hljs-params">(AccountRepository accountRepository)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>(accountRepository);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析机制与基于构造函数的依赖注入基本相同。</p><h5 id="接收生命周期的回调"><a class="markdownIt-Anchor" href="#接收生命周期的回调">#</a> 接收生命周期的回调</h5><p>任何用  <code>@Bean</code>  注解定义的类都支持常规的生命周期回调。 <code>@Bean</code>  注解支持指定任意的初始化和销毁回调方法，就像  <code>Spring XML</code>  在  <code>bean</code>  元素上的  <code>init-method</code>  和  <code>destroy-method</code>  属性一样，如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanOne</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// initialization logic</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanTwo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// destruction logic</span><br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean(initMethod = &quot;init&quot;)</span><br>    <span class="hljs-keyword">public</span> BeanOne <span class="hljs-title function_">beanOne</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanOne</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(destroyMethod = &quot;cleanup&quot;)</span><br>    <span class="hljs-keyword">public</span> BeanTwo <span class="hljs-title function_">beanTwo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanTwo</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>默认情况下，用  <code>Java</code>  配置定义的具有  <code>public</code>  的  <code>close</code>  或  <code>shutdown</code>  方法的 Bean 会自动被列入销毁回调。如果你有一个  <code>public</code>  的  <code>close</code>  或  <code>shutdown</code>  方法，并且你不希望它在容器关闭时被调用，你可以在你的  <code>bean</code>  定义中添加  <code>@Bean(destroyMethod = &quot;&quot;)</code>  来禁用默认  <code>(inferred)</code>  模式。</p></blockquote><p>就前文例子中的  <code>BeanOne</code>  而言，在构造过程中直接调用  <code>init()</code>  方法同样有效，正如下面的例子所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> BeanOne <span class="hljs-title function_">beanOne</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">BeanOne</span> <span class="hljs-variable">beanOne</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanOne</span>();<br>        beanOne.init();<br>        <span class="hljs-keyword">return</span> beanOne;<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="指定-bean-的-scope"><a class="markdownIt-Anchor" href="#指定-bean-的-scope">#</a> 指定 Bean 的 Scope</h5><p>Spring 包括  <code>@Scope</code>  注解，这样你就可以指定 Bean 的 scope。</p><h6 id="使用-scope-注解"><a class="markdownIt-Anchor" href="#使用-scope-注解">#</a> 使用  <code>@Scope</code>  注解</h6><p>你可以指定你用  <code>@Bean</code>  注解定义的  <code>bean</code>  应该有一个特定的  <code>scope</code> 。你可以指定任何一个标准  <code>scope</code> 。</p><p>默认的  <code>scope</code>  是  <code>singleton</code> ，但你可以用  <code>@Scope</code>  注解来覆盖它，如下例所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br>    <span class="hljs-keyword">public</span> Encryptor <span class="hljs-title function_">encryptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="自定义bean的命名"><a class="markdownIt-Anchor" href="#自定义bean的命名">#</a> 自定义 Bean 的命名</h5><p>默认情况下，配置类使用  <code>@Bean</code>  方法的名称作为结果 Bean 的名称。然而，这个功能可以通过  <code>name</code>  属性来重写，正如下面的例子所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean(&quot;myThing&quot;)</span><br>    <span class="hljs-keyword">public</span> Thing <span class="hljs-title function_">thing</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thing</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="bean-别名"><a class="markdownIt-Anchor" href="#bean-别名">#</a> Bean 别名</h5><p><code>@Bean</code>  注解的  <code>name</code>  属性接受一个  <code>String</code>  数组来实现这一目的。下面的例子展示了如何为一个  <code>bean</code>  设置若干别名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean(&#123;&quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;, &quot;subsystemB-dataSource&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// instantiate, configure and return DataSource bean...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="bean-描述description"><a class="markdownIt-Anchor" href="#bean-描述description">#</a> Bean 描述（Description）</h5><p>有时，为  <code>bean</code>  提供更详细的文本描述是有帮助的。为了给  <code>@Bean</code>  添加描述，你可以使用  <code>@Description</code>  注解，如下图所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Description(&quot;Provides a basic example of a bean&quot;)</span><br>    <span class="hljs-keyword">public</span> Thing <span class="hljs-title function_">thing</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thing</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用configuration注解"><a class="markdownIt-Anchor" href="#使用configuration注解">#</a> 使用 @Configuration 注解</h4><p><code>@Configuration</code>  是一个类级注解，表示一个对象是 Bean 定义的来源。 <code>@Configuration</code>  类通过  <code>@Bean</code>  注解的方法声明 bean。对  <code>@Configuration</code>  类上的  <code>@Bean</code>  方法的调用也可以用来定义 bean 间的依赖关系。</p><h5 id="注入bean间的依赖"><a class="markdownIt-Anchor" href="#注入bean间的依赖">#</a> 注入 bean 间的依赖</h5><p>当 Bean 相互之间有依赖关系时，表达这种依赖关系就像让一个  <code>bean</code>  方法调用另一个一样简单，正如下面的例子所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> BeanOne <span class="hljs-title function_">beanOne</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanOne</span>(beanTwo());<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> BeanTwo <span class="hljs-title function_">beanTwo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanTwo</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用componentscan"><a class="markdownIt-Anchor" href="#使用componentscan">#</a> 使用 @ComponentScan</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;org.example&quot;, //扫描的包</span><br><span class="hljs-meta">        includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),</span><br><span class="hljs-meta">        excludeFilters = @Filter(Repository.class))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面的列表显示了等效的 XML。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.example&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;regex&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;.*Stub.*Repository&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.Springframework.stereotype.Repository&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="代理"><a class="markdownIt-Anchor" href="#代理">#</a> 代理</h1><p>代理模式术语：</p><ul><li>代理类：包装目标类的类</li><li>目标类：被包装的类</li></ul><p>通过代理类包装目标类，代理类对客户端完全透明。客户端访问代理类，代理类再访问目标类，外界无法访问目标类。</p><p><code>GoF</code>  23 种设计模式之一的代理模式可用来进行一些功能操作：</p><ul><li>实现代码增强。目标对象只需要关注业务代码，额外的操作可以在代理对象中实现。</li><li>提高安全性。在完全进入目标对象前，由代理对象进行一系列的安全判断，以防安全问题或错误出现。</li></ul><p>在  <code>java</code>  中代理可分为静态代理和动态代理。代理必须通过接口完成。</p><h2 id="静态代理"><a class="markdownIt-Anchor" href="#静态代理">#</a> 静态代理</h2><p>现在有一个接口  <code>OrderService</code>  ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成订单</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">generate</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查看订单详情</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">detail</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改订单</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是它的实现类  <code>OrderServiceImpl</code>  也就是目标类，用于订单的一些操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generate</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;订单已生成&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detail</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;订单信息如下：******&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;订单已修改&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下就为目标类的代理类  <code>OrderServiceProxy</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span>&#123; <span class="hljs-comment">// 代理对象</span><br><br>    <span class="hljs-comment">// 目标对象</span><br>    <span class="hljs-keyword">private</span> OrderService orderService;<br><br>    <span class="hljs-comment">// 通过构造方法将目标对象传递给代理对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderServiceProxy</span><span class="hljs-params">(OrderService orderService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.orderService = orderService;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis(); <span class="hljs-comment">//计算开始时间</span><br>        <span class="hljs-comment">// 执行目标对象的目标方法</span><br>        orderService.generate();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis(); <span class="hljs-comment">//计算结束时间</span><br>        System.out.println(<span class="hljs-string">&quot;耗时&quot;</span>+(end - begin)+<span class="hljs-string">&quot;毫秒&quot;</span>); <span class="hljs-comment">//打印结束时间</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis(); <span class="hljs-comment">//计算开始时间</span><br>        <span class="hljs-comment">// 执行目标对象的目标方法</span><br>        orderService.detail();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis(); <span class="hljs-comment">//计算结束时间</span><br>        System.out.println(<span class="hljs-string">&quot;耗时&quot;</span>+(end - begin)+<span class="hljs-string">&quot;毫秒&quot;</span>); <span class="hljs-comment">//打印结束时间</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis(); <span class="hljs-comment">//计算开始时间</span><br>        <span class="hljs-comment">// 执行目标对象的目标方法</span><br>        orderService.modify();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis(); <span class="hljs-comment">//计算结束时间</span><br>        System.out.println(<span class="hljs-string">&quot;耗时&quot;</span>+(end - begin)+<span class="hljs-string">&quot;毫秒&quot;</span>); <span class="hljs-comment">//打印结束时间</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>可见代理类对目标类进行了一些功能增强，且使用了对象组合，大大降低了耦合度。</p><p>客户端通过访问该代理类，就可以访问目标类的功能，且能使用额外的功能</p></blockquote><p>以上就是代理模式中的静态代理，其中  <code>OrderService</code>  接口是代理类和目标类的共同接口。 <code>OrderServiceImpl</code>  是目标类。 <code>OrderServiceProxy</code>  是代理类。</p><p>静态代理的缺点：</p><ul><li>如果系统中业务接口很多，一个接口对应一个代理类，会导致类爆炸</li><li>增强代码荣誉无法复用</li></ul><h2 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理">#</a> 动态代理</h2><p>动态代理通过使用反射来解决静态代理的缺点。下面我们来介绍动态代理。</p><p><code>JDK</code>  中的  <code>java.lang.reflect</code>  中的  <code>Proxy</code>  专门用来处理动态代理。 <code>Proxy</code>  类使用静态方法  <code>newInstance()</code>  来动态创建代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> Proxy.newInstance(类加载器，接口，调用处理器) <span class="hljs-comment">//返回代理对象，可通过接口强转至目标接口的对象</span><br><span class="hljs-comment">/*类加载器： ClassLoader，动态创建代理类字节码后，需要用类加载器加载进JVM内存。</span><br><span class="hljs-comment">    代理类和目标类的类加载器必须相同，也就是应用类加载器。通过ClassLoader.getSystemClassLoader()获取默认的应用类加载器 */</span><br><span class="hljs-comment">//接口：Class，目标类的接口的字节码对象。</span><br><span class="hljs-comment">//调用处理器：InvocationHandler。用于真正调用目标对象。</span><br></code></pre></td></tr></table></figure><p>我们仍然使用  <code>OrderService</code>  和  <code>OrderServiceImpl</code>  来举例子。下面我们来看  <code>InvocationHandler</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">InvocationHandler只有一个方法也就是invoke，我们来分析这个方法的参数。</span><br><span class="hljs-comment">proxy：通过Proxy.newInstance()创建的代理对象。</span><br><span class="hljs-comment">method：被调用的方法对象，通过method调用真正的目标方法。</span><br><span class="hljs-comment">args：方法所用的参数数组。</span><br><span class="hljs-comment">-------------------------------------------------------------</span><br><span class="hljs-comment">在调用目标方法前后即可使用增强代码</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>让我们来实现  <code>InvocationHandler</code>  ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> OrderService orderService; <span class="hljs-comment">//获得目标对象，以用来调用目标对象的目标方法</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderInvocationHandler</span><span class="hljs-params">(OrderService orderService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.orderService = orderService;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis(); <span class="hljs-comment">//计算开始时间</span><br>        <br>        <span class="hljs-comment">// 执行目标对象的目标方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> method.invoke(orderService, args); <br>        <br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis(); <span class="hljs-comment">//计算结束时间</span><br>        System.out.println(<span class="hljs-string">&quot;耗时&quot;</span>+(end - begin)+<span class="hljs-string">&quot;毫秒&quot;</span>); <span class="hljs-comment">//打印结束时间</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成上述准备工作后，我们来创建代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">OrderService</span> <span class="hljs-variable">orderService</span> <span class="hljs-operator">=</span> (OrderService) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), OrderServiceImpl.class.getInterfaces(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderInvocationHandler</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderServiceImpl</span>()));<br>    <span class="hljs-comment">//调用代理对象的方法</span><br>    orderService.generate();<br>    orderService.detail();<br>    orderService.modify();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">订单已生成<br>耗时1毫秒<br>订单信息如下：******<br>耗时0毫秒<br>订单已修改<br>耗时0毫秒<br></code></pre></td></tr></table></figure><blockquote><p>可见动态代理解决了静态代理的类爆炸和代码冗余问题</p></blockquote><h3 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2">#</a> 原理</h3><p>下面我们来修改一下  <code>main</code>  方法的一些细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    System.getProperties().put(<span class="hljs-string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>    <span class="hljs-type">OrderService</span> <span class="hljs-variable">orderService</span> <span class="hljs-operator">=</span> (OrderService) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), OrderServiceImpl.class.getInterfaces(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderInvocationHandler</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderServiceImpl</span>()));<br>    <span class="hljs-comment">//调用代理对象的方法</span><br>    orderService.generate();<br>    orderService.detail();<br>    orderService.modify();<br>&#125;<br></code></pre></td></tr></table></figure><p>不出意外你将会在目录中看到  <code>jdk.proxy1.$proxy0</code>  的字节码文件，该文件即之前创造的代理对象。下面我们来看看这对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">$Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span> &#123; <span class="hljs-comment">/*</span><br><span class="hljs-comment">该类实现了OrderService，所以该对象可以强转为目标接口对象</span><br><span class="hljs-comment">且继承了Proxy，由于单继承，所有JDK的动态代理无法使用继承实现</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-comment">//代理类的所有属性均为Method常量。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Method m0;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Method m1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Method m2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Method m3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Method m4;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Method m5;<br>    <span class="hljs-comment">// 代理类的构造方法，以InvocationHandler为参数</span><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler var1) &#123;<br>        <span class="hljs-built_in">super</span>(var1);<br>    &#125;<br>    <span class="hljs-comment">//对代理对象的方法调用，最终都会转换成对InvocationHandler对象的invoke方法的调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        ......<br>            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m0, (Object[])<span class="hljs-literal">null</span>);<br>......<br>    &#125;<br><span class="hljs-comment">//对代理对象的方法调用，最终都会转换成对InvocationHandler对象的invoke方法的调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object var1)</span> &#123;<br>        ......<br>            <span class="hljs-keyword">return</span> (Boolean)<span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;var1&#125;);<br>        ......<br>    &#125;<br><span class="hljs-comment">//对代理对象的方法调用，最终都会转换成对InvocationHandler对象的invoke方法的调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        ......<br>            <span class="hljs-keyword">return</span> (String)<span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m2, (Object[])<span class="hljs-literal">null</span>);<br>        ......<br>    &#125;<br><span class="hljs-comment">//对代理对象的方法调用，最终都会转换成对InvocationHandler对象的invoke方法的调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generate</span><span class="hljs-params">()</span> &#123;<br>       ......<br>            <span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m3, (Object[])<span class="hljs-literal">null</span>);<br>       ......<br>    &#125;<br><span class="hljs-comment">//对代理对象的方法调用，最终都会转换成对InvocationHandler对象的invoke方法的调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detail</span><span class="hljs-params">()</span> &#123;<br>      ......<br>            <span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m4, (Object[])<span class="hljs-literal">null</span>);<br>       ......<br>    &#125;<br><span class="hljs-comment">//对代理对象的方法调用，最终都会转换成对InvocationHandler对象的invoke方法的调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">()</span> &#123;<br>       ......<br>            <span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m5, (Object[])<span class="hljs-literal">null</span>);<br>       ......<br>    &#125;<br>    ......<br>    <span class="hljs-comment">//代理类会获得Object的hashCode方法，equals方法、toString方法以及目标接口的所有方法的Method对象，然后重写他们</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        ......<br>            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br>            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>);<br>            m3 = Class.forName(<span class="hljs-string">&quot;com.jhy.proxy.OrderService&quot;</span>).getMethod(<span class="hljs-string">&quot;generate&quot;</span>);<br>            m4 = Class.forName(<span class="hljs-string">&quot;com.jhy.proxy.OrderService&quot;</span>).getMethod(<span class="hljs-string">&quot;detail&quot;</span>);<br>            m5 = Class.forName(<span class="hljs-string">&quot;com.jhy.proxy.OrderService&quot;</span>).getMethod(<span class="hljs-string">&quot;modify&quot;</span>);<br>        ......<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>JDK</code>  会在运行中动态创建名为  <code>$Proxy</code>  + 数字的代理类，并且让这个类继承  <code>Proxy</code>  类并且实现目标接口</p></blockquote><h1 id="aop"><a class="markdownIt-Anchor" href="#aop">#</a> AOP</h1><p><code>IoC</code>  使软件组件松耦合。 <code>AOP</code>  让你能够捕捉系统中经常使用的功能，把它转化成组件。</p><p><code>AOP（Aspect Oriented Programming）</code> ：面向切面编程，面向方面编程。（ <code>AOP</code>  是一种编程技术）</p><p><code>AOP</code>  是对  <code>OOP</code>  的补充延伸。 <code>AOP</code>  底层使用的就是动态代理来实现的。</p><p><code>Spring</code>  的  <code>AOP</code>  使用的动态代理是： <code>JDK</code>  动态代理 +  <code>CGLIB</code>  动态代理技术。 <code>Spring</code>  在这两种动态代理中灵活切换，如果是代理接口，会默认使用  <code>JDK</code>  动态代理，如果要代理某个类，这个类没有实现接口，就会切换使用  <code>CGLIB</code>  。当然，你也可以强制通过一些配置让  <code>Spring</code>  只使用  <code>CGLIB</code> 。</p><h2 id="aop介绍"><a class="markdownIt-Anchor" href="#aop介绍">#</a> AOP 介绍</h2><p>一般一个系统当中都会有一些系统服务，例如：日志、事务管理、安全等。这些系统服务被称为：<strong>交叉业务</strong></p><p>这些<strong>交叉业务</strong>几乎是通用的，不管你是做银行账户转账，还是删除用户数据。日志、事务管理、安全，这些都是需要做的。</p><p>如果在每一个业务处理过程当中，都掺杂这些交叉业务代码进去的话，存在两方面问题：</p><ul><li>第一：交叉业务代码在多个业务流程中反复出现，显然这个交叉业务代码没有得到复用。并且修改这些交叉业务代码的话，需要修改多处。</li><li>第二：程序员无法专注核心业务代码的编写，在编写核心业务代码的同时还需要处理这些交叉业务。</li></ul><p>使用  <code>AOP</code>  可以很轻松的解决以上问题。</p><img src="aop.png" alt="AOP图解"><h2 id="aop八大术语"><a class="markdownIt-Anchor" href="#aop八大术语">#</a> AOP 八大术语</h2><p>让我们首先定义一些核心的 AOP 概念和术语。这些术语并不是针对  <code>Spring</code>  的。</p><ul><li><code>Aspect</code> （切面）: 一个跨越多个类的关注点的模块化。事务管理是企业级 Java 应用中横切关注点的一个很好的例子。在  <code>Spring AOP</code>  中，切面是通过使用常规类（基于  <code>XML</code>  ）或使用  <code>@Aspect</code>  注解的常规类（  <code>@AspectJ</code>  风格）实现的。</li><li><code>Join point</code> （连接点）: 程序执行过程中的一个点，例如一个方法的执行或一个异常的处理。在  <code>Spring AOP</code>  中，一个连接点总是代表一个方法的执行。</li><li><code>Advice</code> （通知）: 一个切面在一个特定的连接点采取的行动。不同类型的 advice 包括 “around”、“before” 和 “after” 的 advice（Advice 类型将在后面讨论）。许多 AOP 框架，包括 Spring，都将 advice 建模为一个拦截器，并在连接点（Join point）周围维护一个拦截器链。</li><li><code>Pointcut</code> （切点）: 一个匹配连接点的谓词（predicate）。 <code>advice</code>  与一个切点表达式相关联，并在切点匹配的任何连接点上运行（例如，执行一个具有特定名称的方法）。由切点表达式匹配的连接点概念是  <code>AOP</code>  的核心，Spring 默认使用 AspectJ 的切点表达式语言。</li><li><code>Introduction</code> （引入）: 代表一个类型声明额外的方法或字段。Spring AOP 允许你为任何 advice 的对象引入新的接口（以及相应的实现）。例如，你可以使用引入来使一个 bean 实现  <code>IsModified</code>  接口，以简化缓存。（介绍在 AspectJ 社区中被称为类型间声明）。</li><li><code>Target object</code> （目标对象）: 被一个或多个切面所 advice 的对象。也被称为 “advised object”。由于 Spring AOP 是通过使用运行时代理来实现的，这个对象总是一个被代理的对象。</li><li><code>AOP proxy</code> （代理对象）: 一个由  <code>AOP</code>  框架创建的对象，以实现切面契约（ <code>advice</code>  方法执行等）。在  <code>Spring</code>  框架中， <code>AOP</code>  代理是一个  <code>JDK</code>  动态代理或  <code>CGLIB</code>  代理。</li><li><code>Weaving</code> （织入）: 将  <code>aspect</code>  与其他应用程序类型或对象连接起来，以创建一个  <code>advice</code>  对象。这可以在编译时（例如，使用  <code>AspectJ</code>  编译器）、加载时或运行时完成。 <code>Spring AOP</code>  和其他纯  <code>Java AOP</code>  框架一样，在运行时进行织入。</li></ul><p><code>Spring AOP</code>  包括以下类型的  <code>advice</code> 。</p><ul><li><code>Before advice</code> : 在连接点之前运行的 Advice ，但它不具备以下能力 阻止执行流进行到 join point 的能力（除非它抛出一个异常）。</li><li><code>After returning advice</code> : 在一个连接点正常完成后运行的 Advice （例如，如果一个方法返回时没有抛出一个异常）。</li><li><code>After (finally) advice</code> : 无论连接点以何种方式退出（正常或特殊返回），都要运行该 advice。</li><li><code>Around advice</code> : 围绕一个连接点的 advice，如方法调用。这是最强大的一种 advice。Around advice 可以在方法调用之前和之后执行自定义行为。它还负责选择是否继续进行连接点或通过返回自己的返回值或抛出一个异常来缩短 advice 方法的执行。</li></ul><h2 id="使用spring的aop"><a class="markdownIt-Anchor" href="#使用spring的aop">#</a> 使用 Spring 的 AOP</h2><p>Spring 对 AOP 的实现包括以下 3 种方式：</p><ul><li><strong>第一种方式：Spring 框架结合 AspectJ 框架实现的 AOP，基于注解方式。</strong></li><li><strong>第二种方式：Spring 框架结合 AspectJ 框架实现的 AOP，基于 XML 方式。</strong></li><li>第三种方式：Spring 框架自己实现的 AOP，基于 XML 配置方式。</li></ul><p>使用  <code>AOP</code>  必须含有以下注解：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="注解-2"><a class="markdownIt-Anchor" href="#注解-2">#</a> 注解</h3><p>使用注解的方式，必须要是有  <code>@Aspecj</code>  注解标注切面类。</p><h4 id="开启aspectj的支持"><a class="markdownIt-Anchor" href="#开启aspectj的支持">#</a> 开启 @AspectJ 的支持</h4><h5 id="通过-xml-开启"><a class="markdownIt-Anchor" href="#通过-xml-开启">#</a> 通过  <code>XML</code>  开启</h5><p>使用  <code>aop</code>  命名空间开启开启  <code>@AspectJ</code>  的支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">保证下面的约束存在</span><br><span class="hljs-comment">xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="hljs-comment">xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">配置启用 @AspectJ 支持，当然如果你想约束aop的底层代理实现你也可以使用proxy-target-class属性</span><br><span class="hljs-comment">proxy-target-class默认为false，代表使用cglib动态代理或jdk的动态代理</span><br><span class="hljs-comment">将proxy-target-class设置为true，则代表强制使用cglib动态代理</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="通过注解开启"><a class="markdownIt-Anchor" href="#通过注解开启">#</a> 通过注解开启</h5><p>在自定以的配置类中使用注解  <code>@EnableAspectJAutoProxy</code>  开启  <code>@AspectJ</code>  的支持：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="声明一个-aspect类"><a class="markdownIt-Anchor" href="#声明一个-aspect类">#</a> 声明一个 Aspect 类</h4><p>启用  <code>@AspectJ</code>  支持后，任何在你的  <code>application context</code>  中定义的  <code>bean</code>  ，其类是  <code>@AspectJ</code>  切面（有  <code>@Aspect</code>  注解），会被  <code>Spring</code>  自动检测到，并用于配置 <code>Spring AOP</code>  。接下来的两个例子展示了一个不怎么有用的切面所需的最小步骤。</p><p>两个例子中的第一个显示了  <code>application context</code>  中的一个普通  <code>Bean</code>  定义，它指向一个用  <code>@Aspect</code>  注解的  <code>Bean</code>  类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xyz.NotVeryUsefulAspect&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- configure properties of the aspect here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>两个例子中的第二个展示了  <code>NotVeryUsefulAspect</code>  类的定义，它被  <code>@Aspect</code>  注解了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xyz;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotVeryUsefulAspect</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="声明一个切点pointcut"><a class="markdownIt-Anchor" href="#声明一个切点pointcut">#</a> 声明一个切点（Pointcut）</h4><p><code>Pointcuts</code>  确定感兴趣的连接点（ <code>join points</code> ），从而使我们能够控制  <code>advice</code>  的运行时间。 <code>Spring AOP</code>  只支持  <code>Spring Bean</code>  的方法执行连接点，所以你可以把 <code>pointcut</code>  看作是对  <code>Spring Bean</code>  上的方法执行的匹配。一个切点声明有两个部分：一个由名称和任何参数组成的签名，以及一个切点表达式，它决定了我们到底对哪些方法的执行感兴趣。在  <code>AOP</code>  的  <code>@AspectJ</code>  注解式中，一个  <code>pointcut</code>  签名是由一个常规的方法定义提供的，而  <code>pointcut</code>  表达式是通过使用  <code>@Pointcut</code>  注解来表示的（作为 <code>pointcut</code>  签名的方法必须是一个  <code>void</code>  返回类型）。</p><p>一个例子可以帮助我们清楚地了解切点签名和切点表达式之间的区别。下面的例子定义了一个名为  <code>anyOldTransfer</code>  的切点，它匹配任何名为  <code>transfer</code>  的方法的执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(* transfer(..))&quot;)</span> <span class="hljs-comment">// the pointcut expression</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">anyOldTransfer</span><span class="hljs-params">()</span> &#123;&#125; <span class="hljs-comment">// the pointcut signature</span><br></code></pre></td></tr></table></figure><h5 id="支持的-pointcut-指定器"><a class="markdownIt-Anchor" href="#支持的-pointcut-指定器">#</a> 支持的  <code>Pointcut</code>  指定器</h5><p><code>Spring AOP</code>  支持以下  <code>AspectJ</code>  的切点指定器（  <code>PCD</code>  ），用于切点表达式中。</p><ul><li><code>execution</code> : 用于匹配方法执行的连接点。这是在使用  <code>Spring AOP</code>  时要使用的主要切点指定器。</li><li><code>within</code> : 将匹配限制在某些类型内的连接点（使用  <code>Spring AOP</code>  时，执行在匹配类型内声明的方法）。</li><li><code>this</code> : 将匹配限制在连接点（使用  <code>Spring AOP</code>  时方法的执行），其中  <code>bean</code>  引用（  <code>Spring AOP</code>  代理）是给定类型的实例。</li><li><code>target</code> : 将匹配限制在连接点（使用  <code>Spring AOP</code>  时方法的执行），其中目标对象（被代理的应用程序对象）是给定类型的实例。</li><li><code>args</code> : 将匹配限制在连接点（使用  <code>Spring AOP</code>  时方法的执行），其中参数是给定类型的实例。</li><li><code>@target</code> : 限制匹配到连接点（使用  <code>Spring AOP</code>  时方法的执行），其中执行对象的类有一个给定类型的注解。</li><li><code>@args</code> : 将匹配限制在连接点（使用  <code>Spring AOP</code>  时方法的执行），其中实际传递的参数的运行时类型有给定类型的注解。</li><li><code>@within</code> : 将匹配限制在具有给定注解的类型中的连接点（使用  <code>Spring AOP</code>  时，执行在具有给定注解的类型中声明的方法）。</li><li><code>@annotation</code> : 将匹配限制在连接点的主体（  <code>Spring AOP</code>  中正在运行的方法）具有给定注解的连接点上。</li></ul><p>切点表达式用来定义通知（  <code>Advice</code>  ）往哪些方法上切入。</p><h6 id="切点表达式"><a class="markdownIt-Anchor" href="#切点表达式">#</a> 切点表达式</h6><p>切入点表达式语法格式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execution</span><span class="hljs-params">([访问控制权限修饰符] 返回值类型 [全限定类名]方法名(形式参数列表)</span></span> <span class="hljs-selector-attr">[异常]</span>)<br></code></pre></td></tr></table></figure><p>访问控制权限修饰符：</p><ul><li>可选项。</li><li>没写，就是 4 个权限都包括。</li><li>写 public 就表示只包括公开的方法。</li></ul><p>返回值类型：</p><ul><li>必填项。</li><li>* 表示返回值类型任意。</li></ul><p>全限定类名：</p><ul><li>可选项。</li><li>两个点 “…” 代表当前包以及子包下的所有类。</li><li>省略时表示所有的类。</li></ul><p>方法名：</p><ul><li>必填项。</li><li>* 表示所有方法。</li><li>set * 表示所有的 set 方法。</li></ul><p>形式参数列表：</p><ul><li><p>必填项</p></li><li><p>() 表示没有参数的方法</p></li><li><p>(…) 参数类型和个数随意的方法</p></li><li><p>(*) 只有一个参数的方法</p></li><li><p>(*, String) 第一个参数类型随意，第二个参数是 String 的。</p></li></ul><p>异常：</p><ul><li>可选项。</li><li>省略时表示任意异常类型。</li></ul><h6 id="组合切点pointcut表达式"><a class="markdownIt-Anchor" href="#组合切点pointcut表达式">#</a> 组合切点（Pointcut）表达式</h6><p>你可以通过使用  <code>&amp;&amp;</code> 、 <code>||</code>  和  <code>!</code>  来组合  <code>pointcut</code>  表达式。你也可以通过名称来引用  <code>pointcut</code>  表达式。下面的例子显示了三个  <code>pointcut</code>  表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xyz;<br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pointcuts</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span> <span class="hljs-comment">//1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publicMethod</span><span class="hljs-params">()</span> &#123;&#125; <br><br>    <span class="hljs-meta">@Pointcut(&quot;within(com.xyz.trading..*)&quot;)</span> <span class="hljs-comment">//2</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inTrading</span><span class="hljs-params">()</span> &#123;&#125; <br><br>    <span class="hljs-meta">@Pointcut(&quot;publicMethod() &amp;&amp; inTrading()&quot;)</span> <span class="hljs-comment">//3</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tradingOperation</span><span class="hljs-params">()</span> &#123;&#125; <br>&#125;<br></code></pre></td></tr></table></figure><ol><li>如果一个方法执行连接点代表任何  <code>public</code>  方法的执行，则  <code>publicMethod</code>  匹配。</li><li><code>inTrading</code>  匹配一个方法的执行是否在  <code>trading</code>  模块中。</li><li>如果一个方法的执行代表了  <code>trading</code>  模块中的任何  <code>public</code>  方法，则  <code>tradingOperation</code>  匹配</li></ol><p>如上所示，从较小的命名的切点程序中建立更复杂的切点程序表达式是一种最佳做法。当通过名称来引用点切时，正常的  <code>Java</code>  可见性规则适用（你可以看到同一类型中的  <code>private</code>  切点、层次结构中的  <code>protected</code>  切点、任何地方的  <code>public</code>  切点，等等）。可见性并不影响切点的匹配。</p><h4 id="声明-advice"><a class="markdownIt-Anchor" href="#声明-advice">#</a> 声明 Advice</h4><p><code>Advice</code>  与一个切点表达式相关联，在切点匹配的方法执行之前、之后或周围（around）运行。切点表达式可以是一个内联切点，也可以是对一个 <a href="https://springdoc.cn/spring/core.html#aop-common-pointcuts">命名切点</a> 的引用</p><h5 id="before-advice"><a class="markdownIt-Anchor" href="#before-advice">#</a> Before Advice</h5><p>你可以通过使用  <code>@Before</code>  注解在一个切面中声明  <code>before advice</code> 。</p><p>下面的例子使用了一个内联的切点表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeforeExample</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(* com.xyz.dao.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAccessCheck</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们使用一个 <a href="https://springdoc.cn/spring/core.html#aop-common-pointcuts">命名的切点</a>，我们可以把前面的例子改写成如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeforeExample</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;com.xyz.CommonPointcuts.dataAccessOperation()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAccessCheck</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="after-returning-advice"><a class="markdownIt-Anchor" href="#after-returning-advice">#</a> After Returning Advice</h5><p>当一个匹配的方法执行正常返回时， <code>After returning advice</code>  运行。你可以通过使用  <code>@AfterReturning</code>  注解来声明它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterReturningExample</span> &#123;<br><br>    <span class="hljs-meta">@AfterReturning(&quot;execution(* com.xyz.dao.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAccessCheck</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>你可以有多个 advice 声明（也可以有其他成员），都在同一个切面。我们在这些例子中只展示了一个 advice 声明，以集中展示每个 advice 的效果。</p></blockquote><p>有时，你需要在  <code>advice body</code>  中访问被返回的实际值。你可以使用绑定返回值的  <code>@AfterReturning</code>  的形式来获得这种访问权，正如下面的例子所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterReturningExample</span> &#123;<br><br>    <span class="hljs-meta">@AfterReturning(</span><br><span class="hljs-meta">        pointcut=&quot;execution(* com.xyz.dao.*.*(..))&quot;,</span><br><span class="hljs-meta">        returning=&quot;retVal&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAccessCheck</span><span class="hljs-params">(Object retVal)</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>returning</code>  属性中使用的名称必须与 advice 方法中的参数名称相对应。当一个方法执行返回时，返回值会作为相应的参数值传递给  <code>advice</code>  方法。 <code>returning</code>  子句也限制了匹配，只匹配那些返回指定类型的值的方法执行（在这种情况下是  <code>Object</code> ，它匹配任何返回值）。</p><h5 id="after-throwing-advice"><a class="markdownIt-Anchor" href="#after-throwing-advice">#</a> After Throwing Advice</h5><p>当一个匹配的方法执行通过抛出异常退出时， <code>After throwing advice</code>  运行。你可以通过使用  <code>@AfterThrowing</code>  注解来声明它，如下例所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterThrowingExample</span> &#123;<br><br>    <span class="hljs-meta">@AfterThrowing(&quot;execution(* com.xyz.dao.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRecoveryActions</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常情况下，你希望  <code>advice</code>  只在给定类型的异常被抛出时运行，而且你也经常需要在  <code>advice body</code>  中访问被抛出的异常。你可以使用  <code>throwing</code>  属性来限制匹配（如果需要的话 — 否则使用  <code>Throwable</code>  作为异常类型），并将抛出的异常绑定到  <code>advice</code>  参数上。下面的例子展示了如何做到这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterThrowingExample</span> &#123;<br><br>    <span class="hljs-meta">@AfterThrowing(</span><br><span class="hljs-meta">        pointcut=&quot;execution(* com.xyz.dao.*.*(..))&quot;,</span><br><span class="hljs-meta">        throwing=&quot;ex&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRecoveryActions</span><span class="hljs-params">(DataAccessException ex)</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在  <code>throwing</code>  属性中使用的名称必须与 advice 方法中的参数名称相对应。当一个方法的执行通过抛出一个异常退出时，该异常将作为相应的参数值传递给 advice 方法。 <code>throwing</code>  子句也限制了匹配，只能匹配那些抛出指定类型的异常的方法执行（本例中是  <code>DataAccessException</code> ）。</p><blockquote><p>注意， <code>@AfterThrowing</code>  并不表示一般的异常处理回调。具体来说， <code>@AfterThrowing advice</code>  方法只应该接收来自连接点（用户声明的目标方法）本身的异常，而不是来自附带的  <code>@After</code> / <code>@AfterReturning</code>  方法。</p></blockquote><h5 id="after-finally-advice"><a class="markdownIt-Anchor" href="#after-finally-advice">#</a> After (Finally) Advice</h5><p>当一个匹配的方法执行退出时，After (finally) advice 会运行。它是通过使用  <code>@After</code>  注解来声明的。After advice 必须准备好处理正常和异常的返回条件。它通常被用于释放资源和类似的目的。下面的例子展示了如何使用 After finally advice。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterFinallyExample</span> &#123;<br><br>    <span class="hljs-meta">@After(&quot;execution(* com.xyz.dao.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>请注意， <code>AspectJ</code>  中的  <code>@After</code>   <code>advice</code>  被定义为 “after finally advice”，类似于  <code>try-catch</code>  语句中的  <code>finally</code>  块。它将对任何结果、正常返回或从连接点（用户声明的目标方法）抛出的异常进行调用，这与  <code>@AfterReturning</code>  不同，后者只适用于成功的正常返回。</p></blockquote><h5 id="around-advice"><a class="markdownIt-Anchor" href="#around-advice">#</a> Around Advice</h5><p>最后一种  <code>Advice</code>  是  <code>Around Advice</code> 。 “围绕” 一个匹配的方法的执行而运行。它有机会在方法运行之前和之后进行工作，并决定何时、如何、甚至是否真正运行该方法。如果你需要以线程安全的方式分享方法执行前后的状态，例如启动和停止一个定时器，那么  <code>Around advice</code>  经常被使用。</p><blockquote><p>始终使用符合你要求的最不强大的  <code>advice</code>  形式。例如，如果  <code>before advice</code>  足以满足你的需要，就不要使用  <code>around advice</code> 。</p></blockquote><p><code>Around advice</code>  是通过用  <code>@Around</code>  注解来声明一个方法的。该方法应该声明  <code>Object</code>  为其返回类型，并且该方法的第一个参数必须是  <code>ProceedingJoinPoint</code>  类型。在 advice 方法的 body 中，你必须在  <code>ProceedingJoinPoint</code>  上调用  <code>proceed()</code> ，以使底层方法运行。在没有参数的情况下调用  <code>proceed()</code>  将导致调用者的原始参数在底层方法被调用时被提供给它。对于高级用例，有一个重载的  <code>proceed()</code>  方法，它接受一个参数数组（ <code>Object[]</code> ）。当底层方法被调用时，数组中的值将被用作该方法的参数。</p><p><code>around advice</code>  返回的值是方法的调用者看到的返回值。例如，一个简单的缓存切面可以从缓存中返回一个值（如果有的话），或者调用  <code>proceed()</code>  （并返回该值），如果没有的话。请注意，  <code>proceed</code>  可以被调用一次，多次，或者根本就不在  <code>around advice</code>  的  <code>body</code>  中调用。所有这些都是合法的。</p><blockquote><p>如果你将  <code>around advice</code>  方法的返回类型声明为  <code>void</code> ，那么将总是返回给调用者  <code>null</code> ，有效地忽略了任何调用  <code>proceed()</code>  的结果。因此，我们建议  <code>around advice</code>  方法声明一个  <code>Object</code>  的返回类型。该  <code>advice</code>  方法通常应该返回调用  <code>proceed()</code>  所返回的值，即使底层方法的返回类型为  <code>void</code> 。然而， <code>advice</code>  可以根据使用情况选择性地返回一个缓存的值、一个封装的值或一些其他的值。</p></blockquote><p>下面的例子显示了如何使用  <code>around advice</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AroundExample</span> &#123;<br><br>    <span class="hljs-meta">@Around(&quot;execution(* com.xyz..service.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doBasicProfiling</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// start stopwatch</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">retVal</span> <span class="hljs-operator">=</span> pjp.proceed();<br>        <span class="hljs-comment">// stop stopwatch</span><br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="advice-参数"><a class="markdownIt-Anchor" href="#advice-参数">#</a> Advice 参数</h5><p><code>Spring</code>  提供了完全类型化的  <code>advice</code>  ，这意味着你可以在  <code>advice</code>  签名中声明你需要的参数（就像我们在前面看到的返回和抛出的例子一样），而不是一直用  <code>Object[]</code>  数组工作。我们将在本节后面看到如何使参数和其他上下文值对  <code>advice</code>  主体可用。首先，我们看一下如何编写通用  <code>advice</code>  ，它可以找出  <code>advice</code>  当前所  <code>advice</code>  的方法。</p><h6 id="访问当前的-joinpoint"><a class="markdownIt-Anchor" href="#访问当前的-joinpoint">#</a> 访问当前的  <code>JoinPoint</code></h6><p>任何  <code>advice method</code>  都可以声明一个  <code>org.aspectj.lang.JoinPoint</code>  类型的参数作为其第一个参数。请注意， <code>around advice</code>  方法需要声明一个  <code>ProceedingJoinPoint</code>  类型的第一个参数，它是  <code>JoinPoint</code>  的一个子类。</p><p><code>JoinPoint</code>  接口提供了许多有用的方法。</p><ul><li><code>getArgs()</code> : 返回方法的参数。</li><li><code>getThis()</code> : 返回代理对象。</li><li><code>getTarget()</code> : 返回目标对象。</li><li><code>getSignature()</code> : 返回正在被  <code>advice</code>  的方法的描述。</li><li><code>toString()</code> : 打印对所  <code>advice</code>  的方法的有用描述。</li></ul><h6 id="向-advice-传递参数"><a class="markdownIt-Anchor" href="#向-advice-传递参数">#</a> 向 Advice 传递参数</h6><p>我们已经看到了如何绑定返回值或异常值（使用  <code>after returning</code>  和  <code>after throwing advice</code>  ）。为了使参数值对  <code>advice body</code>  可用，你可以使用  <code>args</code>  的绑定形式。如果你在  <code>args</code>  表达式中使用参数名来代替类型名，那么当  <code>advice</code>  被调用时，相应参数的值将作为参数值被传递。一个例子可以让我们更清楚地了解这一点。假设你想  <code>advice</code>  执行以一个  <code>Account</code>  对象为第一参数的 DAO 操作，并且你需要在  <code>advice body</code>  中访问该  <code>account</code>  。你可以写如下内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com.xyz.dao.*.*(..)) &amp;&amp; args(account,..)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validateAccount</span><span class="hljs-params">(Account account)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>pointcut</code>  表达式的  <code>args(account,..)</code>  部分有两个作用。首先，它将匹配限制在方法的执行上，即方法至少需要一个参数，并且传递给该参数的参数是一个  <code>Account</code>  的实例。其次，它使实际的  <code>Account</code>  对象通过  <code>account</code>  参数对  <code>advice</code>  可用。</p><p>另一种写法是声明一个 pointcut，当它与一个连接点匹配时 “提供”  <code>Account</code>  对象的值，然后从 advice 中引用命名的 pointcut。这看起来就像这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(* com.xyz.dao.*.*(..)) &amp;&amp; args(account,..)&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accountDataAccessOperation</span><span class="hljs-params">(Account account)</span> &#123;&#125;<br><br><span class="hljs-meta">@Before(&quot;accountDataAccessOperation(account)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validateAccount</span><span class="hljs-params">(Account account)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>更多细节请参见 AspectJ 编程指南。</p><p>代理对象（ <code>this</code> ）、目标对象（ <code>target</code> ）和注解（ <code>@within</code> 、 <code>@target</code> 、 <code>@annotation</code>  和  <code>@args</code> ）都可以用类似的方式绑定。接下来的一组例子展示了如何匹配执行带有  <code>@Auditable</code>  注解的方法，并提取审计代码。</p><p>下面是  <code>@Auditable</code>  注解的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Auditable &#123;<br>    AuditCode <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面显示了与  <code>@Auditable</code>  方法的执行相匹配的 advice。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;com.xyz.Pointcuts.publicMethod() &amp;&amp; @annotation(auditable)&quot;)</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">audit</span><span class="hljs-params">(Auditable auditable)</span> &#123;<br>    <span class="hljs-type">AuditCode</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> auditable.value();<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>引用 “<a href="https://springdoc.cn/spring/core.html#aop-pointcuts-combining">组合切点（Pointcut）表达式</a>” 中定义的  <code>publicMethod</code>  命名的  <code>pointcut</code> 。</p></blockquote><h6 id="advice-参数和泛型"><a class="markdownIt-Anchor" href="#advice-参数和泛型">#</a> Advice 参数和泛型</h6><p>Spring AOP 可以处理类声明和方法参数中使用的泛型。假设你有一个像下面这样的泛型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sample</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleGenericMethod</span><span class="hljs-params">(T param)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleGenericCollectionMethod</span><span class="hljs-params">(Collection&lt;T&gt; param)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以将方法类型的拦截限制在某些参数类型上，办法是将 advice 参数与你想拦截方法的参数类型联系起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeSampleMethod</span><span class="hljs-params">(MyType param)</span> &#123;<br>    <span class="hljs-comment">// Advice implementation</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法对泛型集合不起作用。所以你不能像下面这样定义一个 pointcut。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeSampleMethod</span><span class="hljs-params">(Collection&lt;MyType&gt; param)</span> &#123;<br>    <span class="hljs-comment">// Advice implementation</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了实现这一点，我们必须检查集合中的每一个元素，这是不太合理的，因为我们也无法决定如何处理一般的  <code>null</code> 。为了实现与此类似的东西，你必须将参数输入到  <code>Collection&lt;?&gt;</code>  中，并手动检查元素的类型。</p><h6 id="确定参数名称"><a class="markdownIt-Anchor" href="#确定参数名称">#</a> 确定参数名称</h6><p><code>advice</code>  调用中的参数绑定依赖于将在切点表达式中使用的名称与 advice 和切点方法签名中声明的参数名称相匹配。</p><p><code>Spring AOP</code>  使用以下  <code>ParameterNameDiscoverer</code>  实现来确定参数名称。每个 discoverers 将有机会发现参数名称，第一个成功的发现者获胜。如果没有一个注册的 discoverers 能确定参数名称，那么将抛出一个异常。</p><ul><li><p><code>AspectJAnnotationParameterNameDiscoverer</code></p><p>使用用户通过相应的 advice 或指向性注解中的  <code>argNames</code>  属性明确指定的参数名称。详见 <a href="https://springdoc.cn/spring/core.html#aop-ataspectj-advice-params-names-explicit">明确的参数名称</a>。</p></li><li><p><code>KotlinReflectionParameterNameDiscoverer</code></p><p>使用  <code>Kotlin</code>  反射 API 来确定参数名称。只有在 classpath 上存在这种 API 时，才会使用这个 discoverer。</p></li><li><p><code>StandardReflectionParameterNameDiscoverer</code></p><p>使用标准的  <code>java.lang.reflect.Parameter</code>  API 来确定参数名称。需要用  <code>javac</code>  的  <code>-parameters</code>  标志来编译代码。建议在 Java 8 + 上采用这种方法。</p></li><li><p><code>LocalVariableTableParameterNameDiscoverer</code></p><p>分析 advice 类的字节码中可用的局部变量表，从 debug 信息中确定参数名称。需要用 debug 参数（至少是  <code>-g:vars</code> ）编译代码。从 Spring Framework 6.0 开始被弃用，在 Spring Framework 6.1 中被移除，以支持用  <code>-parameters</code>  编译代码。在 GraalVM 原生镜像中不支持。</p></li><li><p><code>AspectJAdviceParameterNameDiscoverer</code></p><p>从  <code>pointcut</code>  表达式、 <code>returning</code> , 和  <code>throwing</code>  子句中推导出参数名称。关于所用算法的细节，请参见 <a href="https://docs.spring.io/spring-framework/docs/6.0.8-SNAPSHOT/javadoc-api/org/springframework/aop/aspectj/AspectJAdviceParameterNameDiscoverer.html">javadoc</a>。</p></li></ul><h6 id="明确的参数名称"><a class="markdownIt-Anchor" href="#明确的参数名称">#</a> 明确的参数名称</h6><p><code>@AspectJ</code>  advice 和 pointcut 注解有一个可选的  <code>argNames</code>  属性，你可以用它来指定被注解方法的参数名称。</p><blockquote><p>如果一个 @AspectJ 切面已经被 AspectJ 编译器（ <code>ajc</code> ）编译，即使没有 debug 信息，你也不需要添加  <code>argNames</code>  属性，因为编译器会保留需要的信息。同样地，如果一个 @AspectJ 切面已经用  <code>javac</code>  的  <code>-parameters</code>  标志进行了编译，你就不需要添加  <code>argNames</code>  属性，因为编译器会保留所需的信息。</p></blockquote><p>下面的例子显示了如何使用  <code>argNames</code>  属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(</span><br><span class="hljs-meta">    value = &quot;com.xyz.Pointcuts.publicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;, </span><br><span class="hljs-meta">    argNames = &quot;bean,auditable&quot;)</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">audit</span><span class="hljs-params">(Object bean, Auditable auditable)</span> &#123;<br>    <span class="hljs-type">AuditCode</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> auditable.value();<br>    <span class="hljs-comment">// ... use code and bean</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>引用 “<a href="https://springdoc.cn/spring/core.html#aop-pointcuts-combining">组合切点（Pointcut）表达式</a>” 中定义的  <code>publicMethod</code>  命名的 pointcut。声明  <code>bean</code>  和  <code>auditable</code>  为参数名。</p></blockquote><p>如果第一个参数是  <code>JoinPoint</code> 、 <code>ProceedingJoinPoint</code>  或  <code>JoinPoint.StaticPart</code>  类型，你可以在  <code>argNames</code>  属性的值中省略参数的名称。例如，如果你修改前面的 advice 来接收连接点（join point）对象， <code>argNames</code>  属性不需要包括它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(</span><br><span class="hljs-meta">    value = &quot;com.xyz.Pointcuts.publicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;, </span><br><span class="hljs-meta">    argNames = &quot;bean,auditable&quot;)</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">audit</span><span class="hljs-params">(JoinPoint jp, Object bean, Auditable auditable)</span> &#123;<br>    <span class="hljs-type">AuditCode</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> auditable.value();<br>    <span class="hljs-comment">// ... use code, bean, and jp</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>引用 “<a href="https://springdoc.cn/spring/core.html#aop-pointcuts-combining">组合切点（Pointcut）表达式</a>” 中定义的  <code>publicMethod</code>  命名的 pointcut。声明  <code>bean</code>  和  <code>auditable</code>  为参数名。</p></blockquote><p>给予  <code>JoinPoint</code> 、 <code>ProceedingJoinPoint</code>  或  <code>JoinPoint.StaticPart</code>  类型的第一个参数的特殊处理，对于不收集任何其他连接点上下文的 advice 方法特别方便。在这种情况下，你可以省略  <code>argNames</code>  属性。例如，下面的 advice 不需要声明  <code>argNames</code>  属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;com.xyz.Pointcuts.publicMethod()&quot;)</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">audit</span><span class="hljs-params">(JoinPoint jp)</span> &#123;<br>    <span class="hljs-comment">// ... use jp</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>引用 “<a href="https://springdoc.cn/spring/core.html#aop-pointcuts-combining">组合切点（Pointcut）表达式</a>” 中定义的  <code>publicMethod</code>  命名的 pointcut。</p></blockquote><h1 id="事务"><a class="markdownIt-Anchor" href="#事务">#</a> 事务</h1><h2 id="事务概述"><a class="markdownIt-Anchor" href="#事务概述">#</a> 事务概述</h2><p>在一个业务流程当中，通常需要多条  <code>DML</code>  语句共同联合才能完成，这多条  <code>DML</code>  语句必须同时成功，或者同时失败，这样才能保证数据的安全。</p><p>事务的四个处理过程：</p><ol><li>开启事务 ( <code>start transaction</code> )</li><li>执行核心业务代码</li><li>提交事务（如果核心业务处理过程中没有出现异常）( <code>commit transaction</code> )</li><li>回滚事务（如果核心业务处理过程中出现异常）( <code>rollback transaction</code> )</li></ol><h2 id="spring对事务的支持"><a class="markdownIt-Anchor" href="#spring对事务的支持">#</a> Spring 对事务的支持</h2><ul><li><p>编程式事务</p><ul><li>通过编写代码的方式来实现事务的管理。</li></ul></li><li><p>声明式事务</p><ul><li><p>基于注解方式</p></li><li><p>基于 XML 配置方式</p></li></ul></li></ul><p><code>Spring</code>   专门针对事务开发了一套  <code>API</code> ， <code>API</code>  的核心接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PlatformTransactionManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TransactionManager</span> &#123;<br><br>    TransactionStatus <span class="hljs-title function_">getTransaction</span><span class="hljs-params">(TransactionDefinition definition)</span> <span class="hljs-keyword">throws</span> TransactionException;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>PlatformTransactionManager</code>  接口： <code>spring</code>   事务管理器的核心接口。在 ** <code>Spring6</code> ** 中它有两个实现：</p><ul><li><code>DataSourceTransactionManager</code> ：支持 <code>JdbcTemplate</code> 、 <code>MyBatis</code> 、 <code>Hibernate</code>  等事务管理。</li><li><code>JtaTransactionManager</code> ：支持分布式事务管理。</li></ul><h2 id="声明式事务"><a class="markdownIt-Anchor" href="#声明式事务">#</a> 声明式事务</h2><p><code>Spring</code>  框架的声明式事务管理是通过  <code>Spring</code>  面向切面编程（ <code>AOP</code> ）实现的。然而，由于事务方面的代码是随  <code>Spring</code>  框架的发布而来，并且可以以模板的方式使用，所以一般不需要理解  <code>AOP</code>  的概念来有效地使用这些代码。</p><h3 id="注解实现"><a class="markdownIt-Anchor" href="#注解实现">#</a> 注解实现</h3><p>使用注解  <code>@Transactional</code>  注解方法或者类，则可以为方法添加事务管理。</p><h4 id="xml配置"><a class="markdownIt-Anchor" href="#xml配置">#</a> xml 配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置数据源--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--通过数据源配置DataSourceTransactionManager--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--对指定事务管理器开启声明式事务注解--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="配置类配置"><a class="markdownIt-Anchor" href="#配置类配置">#</a> 配置类配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">        basePackages = &#123;&quot;com.jhy.bank&quot;&#125;,</span><br><span class="hljs-meta">        excludeFilters = &#123;</span><br><span class="hljs-meta">            @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = &#123;Data.class&#125;)</span><br><span class="hljs-meta">        &#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">@PropertySource(&quot;jdbc.properties&quot;)</span><br><span class="hljs-meta">@EnableTransactionManagement</span> <span class="hljs-comment">//开启声明式事务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driver;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-comment">//配置数据源</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DruidDataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">druidDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        druidDataSource.setUrl(url);<br>        druidDataSource.setDriverClassName(driver);<br>        druidDataSource.setUsername(username);<br>        druidDataSource.setPassword(password);<br>        <span class="hljs-keyword">return</span> druidDataSource;<br>    &#125;<br><br><span class="hljs-comment">//通过数据源配置DataSourceTransactionManager</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSourceTransactionManager <span class="hljs-title function_">transactionManager</span><span class="hljs-params">(DataSource dataSource)</span>&#123;<br>        <span class="hljs-type">DataSourceTransactionManager</span> <span class="hljs-variable">dataSourceTransactionManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>();<br>        dataSourceTransactionManager.setDataSource(dataSource);<br>        <span class="hljs-keyword">return</span> dataSourceTransactionManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>然后就可以使用注解  <code>@Transactional</code>  开启声明式事务</p></blockquote><h4 id="transactional设置"><a class="markdownIt-Anchor" href="#transactional设置">#</a> @Transactional 设置</h4><p>默认的  <code>@Transactional</code>  设置如下：</p><ul><li><code>propagation</code>  （传播）设置为  <code>PROPAGATION_REQUIRED</code> 。</li><li>隔离级别是  <code>ISOLATION_DEFAULT</code> 。</li><li>事务是读写的。</li><li>事务超时默认为底层事务系统的默认超时，如果不支持超时，则默认为无。</li><li>任何  <code>RuntimeException</code>  或  <code>Error</code>  都会触发回滚，而任何被检查的  <code>Exception</code>  则不会。</li></ul><p>你可以改变这些默认设置。下表总结了  <code>@Transactional</code>  注解的各种属性：</p><table><thead><tr><th>属性</th><th style="text-align:left">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td><a href="https://springdoc.cn/spring/data-access.html#tx-multiple-tx-mgrs-with-attransactional">value</a></td><td style="text-align:left"><code>String</code></td><td style="text-align:left">可选的  <code>qualifier</code> ，指定要使用的事务管理器。</td></tr><tr><td><code>transactionManager</code></td><td style="text-align:left"><code>String</code></td><td style="text-align:left"><code>value</code>  别名。</td></tr><tr><td><code>label</code></td><td style="text-align:left"><code>String</code>  标签数组，用于为事务添加表达式描述。</td><td style="text-align:left">标签可以由事务管理器评估，以便将特定于实现的行为与实际事务联系起来。</td></tr><tr><td>[propagation](# 事务传播（Propagation）)</td><td style="text-align:left"><code>enum</code> :  <code>Propagation</code></td><td style="text-align:left">可选的  <code>propagation</code>  （传播）设置。</td></tr><tr><td><a href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%88Isolation%EF%BC%89">isolation</a></td><td style="text-align:left"><code>enum</code> :  <code>Isolation</code></td><td style="text-align:left">可选的隔离级别。仅适用于  <code>REQUIRED</code>  或  <code>REQUIRES_NEW</code>  的传播值。</td></tr><tr><td><a href="#%E4%BA%8B%E5%8A%A1%E8%B6%85%E6%97%B6%EF%BC%88timeout%EF%BC%89">timeout</a></td><td style="text-align:left"><code>int</code>  (以秒为单位的粒度)</td><td style="text-align:left">可选的事务超时。仅适用于  <code>REQUIRED</code>  或  <code>REQUIRES_NEW</code>  的传播值。</td></tr><tr><td><code>timeoutString</code></td><td style="text-align:left"><code>String</code>  (以秒为单位的粒度)</td><td style="text-align:left">用于指定以秒为单位的  <code>timeout</code> ，作为  <code>String</code>  值的替代方案，例如，作为占位符。</td></tr><tr><td><a href="#%E5%8F%AA%E8%AF%BB%E4%BA%8B%E5%8A%A1%EF%BC%88readOnly%EF%BC%89">readOnly</a></td><td style="text-align:left"><code>boolean</code></td><td style="text-align:left">读写事务与只读事务。只适用于  <code>REQUIRED</code>  或  <code>REQUIRES_NEW</code>  的值。</td></tr><tr><td><a href="#%E5%BC%82%E5%B8%B8%E5%9B%9E%E6%BB%9A%EF%BC%88rollbackFor%EF%BC%89">rollbackFor</a></td><td style="text-align:left"><code>Class</code>  对象的数组，必须从  <code>Throwable</code>  派生。</td><td style="text-align:left">可选的必然会引起回滚的异常类型数组</td></tr><tr><td><code>rollbackForClassName</code></td><td style="text-align:left">异常名称模式（pattern）的数组。</td><td style="text-align:left">可选的必然会引起回滚异常名称模式（ <code>patterns</code> ）数组。</td></tr><tr><td><a href="#%E5%BC%82%E5%B8%B8%E4%B8%8D%E5%9B%9E%E6%BB%9A%EF%BC%88rollbackFor">noRollbackFor</a></td><td style="text-align:left">必须从  <code>Throwable</code>  派生的  <code>Class</code>  对象的数组。</td><td style="text-align:left">可选的不会引起回滚的  <code>exception</code>  类型数组</td></tr><tr><td><code>noRollbackForClassName</code></td><td style="text-align:left">异常名称模式（pattern）的数组。</td><td style="text-align:left">可选的不会引起回滚异常名称模式（ <code>patterns</code> ）数组。</td></tr></tbody></table><h5 id="事务传播propagation"><a class="markdownIt-Anchor" href="#事务传播propagation">#</a> 事务传播（Propagation）</h5><p>一共有七种传播行为：</p><ul><li>REQUIRED：支持当前事务，如果不存在当前事务就新建一个 (默认)<strong>【没有就新建，有就加入】</strong></li><li>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行 **【有就加入，没有就不管了】**</li><li>MANDATORY：必须运行在一个事务中，如果当前没有事务，就会抛出一个异常 **【有就加入，没有就抛异常】**</li><li>REQUIRES_NEW：开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起 **【不管有没有，直接开启一个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起】**</li><li>NOT_SUPPORTED：以非事务方式运行，如果当前有事务存在，则挂起当前事务 **【不支持事务，存在就挂起】**</li><li>NEVER：以非事务方式运行，如果有一个事务存在，抛出异常 **【不支持事务，存在就抛异常】**</li><li>NESTED：如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于外层事务进行提交或回滚。如果外层事务不存在，行为就像 REQUIRED 一样。<strong>【有事务的话，就在这个事务里再嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚。没有事务就和 REQUIRED 一样。】</strong></li></ul><h5 id="事务隔离级别isolation"><a class="markdownIt-Anchor" href="#事务隔离级别isolation">#</a> 事务隔离级别（Isolation）</h5><p>数据库中读取数据存在的三大问题：（三大读问题）</p><ul><li><strong>脏读：读取到没有提交到数据库的数据，叫做脏读。</strong><ul><li><code>a</code>  先进来修改了数据但未提交，此时切换至 <code>b</code> ， <code>b</code>  读取该数据，此后切换至 <code>a</code>  提交</li></ul></li><li><strong>不可重复读：在同一个事务当中，第一次和第二次读取的数据不一样。</strong><ul><li><code>a</code>  先进来读取了数据，然后切换至 <code>b</code>  修改了数据并进行提交，此后切换至 <code>a</code>  重新读取了数据</li></ul></li><li><strong>幻读：读到的数据是假的。</strong><ul><li><code>a</code>  先进来但未开始读取数据，然后切换至 <code>b</code>  修改了数据并提交，此后切换至 <code>a</code>  开始读取数据</li></ul></li></ul><p>事务隔离级别包括四个级别，分别解决上述问题：</p><ul><li><p>读未提交： <code>READ_UNCOMMITTED</code></p><ul><li>这种隔离级别，存在脏读问题，所谓的脏读 (dirty read) 表示能够读取到其它事务未提交的数据。</li></ul></li><li><p>读提交： <code>READ_COMMITTED</code></p><ul><li>解决了脏读问题，其它事务提交之后才能读到，但存在不可重复读问题。</li></ul></li><li><p>可重复读： <code>REPEATABLE_READ</code></p><ul><li>解决了不可重复读，可以达到可重复读效果，只要当前事务不结束，读取到的数据一直都是一样的。但存在幻读问题。</li></ul></li><li><p>序列化： <code>SERIALIZABLE</code></p><ul><li>解决了幻读问题，事务排队执行。不支持并发。</li></ul><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th></tr></thead><tbody><tr><td>读未提交</td><td><strong>有</strong></td><td><strong>有</strong></td><td><strong>有</strong></td></tr><tr><td>读提交</td><td>无</td><td><strong>有</strong></td><td><strong>有</strong></td></tr><tr><td>可重复读</td><td>无</td><td>无</td><td><strong>有</strong></td></tr><tr><td>序列化</td><td>无</td><td>无</td><td>无</td></tr></tbody></table></li></ul><p>在  <code>Spring</code>  中事务隔离有 <strong>5</strong> 种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Isolation</span> &#123;<br><span class="hljs-comment">//默认，数据库未Mysql则为可重复读，Oracle则为读未提交</span><br>DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),<br><span class="hljs-comment">//读未提交</span><br>READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),<br><span class="hljs-comment">//读可提交</span><br>READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),<br><span class="hljs-comment">//可重复度</span><br>REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),<br><span class="hljs-comment">//序列化</span><br>SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);<br></code></pre></td></tr></table></figure><h5 id="事务超时timeout"><a class="markdownIt-Anchor" href="#事务超时timeout">#</a> 事务超时（timeout）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(timeout = 10)</span><br></code></pre></td></tr></table></figure><p>以秒为单位，如果<strong>指定时间</strong>内  <code>DML</code>  语句还未执行完成 <strong>最终结果会选择回滚。</strong>，那么则会抛出错误。默认值 - 1，表示没有时间限制。</p><blockquote><p>指定时间：指的是从最后一条事务语句结束之前的时间，在这后的时间都不算</p></blockquote><h5 id="只读事务readonly"><a class="markdownIt-Anchor" href="#只读事务readonly">#</a> 只读事务（readOnly）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(readOnly = true)</span><br></code></pre></td></tr></table></figure><p>将当前事务设置为只读事务，在该事务执行过程中只允许  <code>select</code>  语句执行，其余的  <code>DML</code>  语句均不会允许执行。</p><h5 id="异常回滚rollbackfor"><a class="markdownIt-Anchor" href="#异常回滚rollbackfor">#</a> 异常回滚（rollbackFor）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(rollbackFor = RuntimeException.class)</span><br></code></pre></td></tr></table></figure><p>设置发生了哪些异常才会回滚</p><h5 id="异常不回滚rollbackfor"><a class="markdownIt-Anchor" href="#异常不回滚rollbackfor">#</a> 异常不回滚（rollbackFor）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(noRollbackFor = NullPointerException.class)</span><br></code></pre></td></tr></table></figure><p>设置发生哪些异常不会回滚</p><h1 id="测试"><a class="markdownIt-Anchor" href="#测试">#</a> 测试</h1><p><code>Spring</code>  提供了一套  <code>API</code>  对  <code>junit</code>  进行了整合</p><h2 id="spring对junit4的支持"><a class="markdownIt-Anchor" href="#spring对junit4的支持">#</a> Spring 对 JUnit4 的支持</h2><p>首先需要以下的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Spring整合JUnit的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--junit4依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:spring.xml&quot;)</span> <span class="hljs-comment">//@ContextConfiguration(classes = MyConfiguration.class) 配置类的形式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringJUnit4Test</span> &#123;<br>    <br>  <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> User user;    <br>    <br>   <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFoo</span><span class="hljs-params">()</span>&#123;<br>        ......<br>    &#125;<br> .....<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spring对junit5的支持"><a class="markdownIt-Anchor" href="#spring对junit5的支持">#</a> Spring 对 JUnit5 的支持</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Spring整合JUnit的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--junit5依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.10.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExtendWith(SpringExtension.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:spring.xml&quot;)</span> <span class="hljs-comment">//@ContextConfiguration(classes = MyConfiguration.class) 配置类的形式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringJUnit4Test</span> &#123;<br>    <br>  <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> User user;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFoo</span><span class="hljs-params">()</span>&#123;<br>        ......<br>    &#125;<br> .....<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>现在你不需要像以前那样获取  <code>IoC</code>  容器之后再获取  <code>bean</code>  ，而是可以通过自动装配的方式来获取  <code>bean</code></p></blockquote><h1 id="整合mybtias"><a class="markdownIt-Anchor" href="#整合mybtias">#</a> 整合 Mybtias</h1><p>将步骤分为 <strong>11</strong> 步：</p><ol><li>导入依赖</li><li>编写三层架构</li><li>创建  <code>pojo</code></li><li><a href="#%E7%BC%96%E5%86%99Mybatis%E7%9A%84%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">编写 Mybatis 的核心配置文件</a><ul><li>该文件可以没有，大部分的配置可以转移到  <code>Spring</code>  配置文件中。</li></ul></li><li>编写  <code>mapper</code>  映射文件</li><li>配置  <code>IoC</code>  容器中三层架构的  <code>bean</code></li><li><a href="#%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90">配置数据源</a></li><li><a href="#%E9%85%8D%E7%BD%AESqlSessionFactoryBean">配置 SqlSessionFactoryBean</a><ul><li>用于生产  <code>SqlSessionFactory</code></li></ul></li><li><a href="#%E9%85%8D%E7%BD%AEmapper%E6%8E%A5%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8">配置 mapper 接口扫描器</a><ul><li>用于将  <code>mapper</code>  接口的代理类注册为  <code>bean</code></li></ul></li><li><a href="#%E9%85%8D%E7%BD%AE%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8">配置事务管理器</a></li><li><a href="#%E5%BC%80%E5%90%AF%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1">开启声明式事务</a></li></ol><h2 id="编写mybatis的核心配置文件"><a class="markdownIt-Anchor" href="#编写mybatis的核心配置文件">#</a> 编写 Mybatis 的核心配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-comment">&lt;!--mybatis的总配置文件--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">关于Mybatis环境、数据源等移动至Spring配置文件</span><br><span class="hljs-comment">核心设置必须在该配置文件中配置</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="配置数据源"><a class="markdownIt-Anchor" href="#配置数据源">#</a> 配置数据源</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="配置sqlsessionfactorybean"><a class="markdownIt-Anchor" href="#配置sqlsessionfactorybean">#</a> 配置 SqlSessionFactoryBean</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--注入数据源--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--配置文件所在位置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeAliasesPackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.jhy.acct.entity&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--起别名--&gt;</span><br>    <span class="hljs-comment">&lt;!--如果mapper映射文件和接口不在同一目录要设置该属性--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com/jhy/acct/mapper/*.xml&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--mapper映射文件所在地--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="配置mapper接口扫描器"><a class="markdownIt-Anchor" href="#配置mapper接口扫描器">#</a> 配置 mapper 接口扫描器</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.jhy.acct.mapper&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--mapper接口的包路径--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><code>Spring</code>  会默认扫描指定包下的  <code>Mapper</code>  接口，并根据命名规则自动加载对应的  <code>Mapper</code>  映射文件</p></blockquote><h2 id="配置事务管理器"><a class="markdownIt-Anchor" href="#配置事务管理器">#</a> 配置事务管理器</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="开启声明式事务"><a class="markdownIt-Anchor" href="#开启声明式事务">#</a> 开启声明式事务</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="依赖"><a class="markdownIt-Anchor" href="#依赖">#</a> 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mysql驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.33<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--spring上下文，同时引入aop，bean，core，expression--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--druid数据源--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引入mybatis官方提供的mybatis与spring整合的依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--引入spring-jdbc，包括事务管理器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引入junit依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引入spring-test--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引入jakarta的注解，包括@Resource--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.annotation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引入mybatis本体依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习</title>
    <link href="/2024/02/17/git/"/>
    <url>/2024/02/17/git/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="起步"><a class="markdownIt-Anchor" href="#起步">#</a> 起步</h1><h2 id="关于版本控制"><a class="markdownIt-Anchor" href="#关于版本控制">#</a> 关于版本控制</h2><p>什么是 “版本控制”？我为什么要关心它呢？ 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特 定版本修订情况的系统。</p><p>如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴 望拥有的功能），采用版本控制系统（VCS）是个明智的选择。 有了它你就可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地 方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 使用版本控制系统通常还意 味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。 但额外增加 的工作量却微乎其微。</p><h2 id="本地版本控制系统"><a class="markdownIt-Anchor" href="#本地版本控制系统">#</a> 本地版本控制系统</h2><p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p><p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p><img src="local_vcs.png" alt="本地版本控制"/><h2 id="集中化的版本控制系统"><a class="markdownIt-Anchor" href="#集中化的版本控制系统">#</a> 集中化的版本控制系统</h2><p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，** 集中化的版本控制系统 （Centralized Version Control Systems，简称 CVCS）** 应运而生。 这类系统，诸如  <code>CVS</code> 、 <code>Subversion</code>  以及  <code>Perforce</code>  等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。</p><img src="centry_vcs.png" alt="集中化的版本控制"/><p>这种做法带来了许多好处，特别是相较于老式的本地  <code>VCS</code>  来说。 现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个  <code>CVCS</code>  要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>事分两面，有好有坏。 这么做最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据 —— 包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p><h2 id="分布式版本控制系统"><a class="markdownIt-Anchor" href="#分布式版本控制系统">#</a> 分布式版本控制系统</h2><p>于是 ** 分布式版本控制系统（Distributed Version Control System，简称 DVCS）** 面世了。 在这类系统中，像  <code>Git</code> 、 <code>Mercurial</code> 、 <code>Bazaar</code>  以及  <code>Darcs</code>  等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p><img src="distributed_vcs.png" alt="分布式版本控制"/><p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p><h1 id="git的一些特点"><a class="markdownIt-Anchor" href="#git的一些特点">#</a> Git 的一些特点</h1><h2 id="基于快照而非差异"><a class="markdownIt-Anchor" href="#基于快照而非差异">#</a> 基于快照，而非差异</h2><p><code>Git</code>  和其它版本控制系统（包括  <code>Subversion</code>  和近似工具）的主要差别在于  <code>Git</code>  对待数据的方式。 从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统（ <code>CVS</code> 、 <code>Subversion</code> 、 <code>Perforce</code> 、 <code>Bazaar</code>  等等）将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异（它们通常称作<strong>基于差异（delta-based）的版本控制</strong>）。</p><p>基于差异的版本控制系统工作流如下：</p><img src="vcs_diff.png" alt="基于差异的版本控制系统" /><p>基于快照的版本控制系统工作流如下：</p><img src="vcs_git.png" alt="基于快照的版本控制系统" /><p><code>Git</code>  不按照以上方式对待或保存数据。反之， <code>Git</code>  更像是把数据看作是对小型文件系统的一系列快照。 在  <code>Git</code>  中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改， <code>Git</code>  不再重新存储该文件，而是只保留一个链接指向之前存储的文件。  <code>Git</code>  对待数据更像是一个<strong>快照流</strong>。</p><blockquote><p><code>Git</code>  更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的  <code>VCS</code></p></blockquote><h2 id="近乎所有操作都是本地执行"><a class="markdownIt-Anchor" href="#近乎所有操作都是本地执行">#</a> 近乎所有操作都是本地执行</h2><p>离线时可以本地进行更新或提交，联网后再提交至远程仓库。</p><h2 id="保证完整性"><a class="markdownIt-Anchor" href="#保证完整性">#</a> 保证完整性</h2><p><code>Git</code>  中所有的数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在  <code>Git</code>  不知情时更改任何文件内容或目录内容。 <code>Git</code>  用以计算校验和的机制叫做  <code>SHA-1</code>  散列（ <code>hash</code> ，哈希）。这是一个由  <code>40</code>  个十六进制字符（ <code>0-9</code>  和  <code>a-f</code> ）组 成的字符串，基于  <code>Git</code>  中文件的内容或目录结构计算出来。  <code>SHA-1</code>  哈希看起来是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powerpowershell">24b9da6552252987aa493b52f8696cd6d3b00373<br></code></pre></td></tr></table></figure><p><code>Git</code>  数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p><h2 id="git一般只添加不删除"><a class="markdownIt-Anchor" href="#git一般只添加不删除">#</a> Git 一般只添加不删除</h2><p>你执行的  <code>Git</code>  操作，几乎只往  <code>Git</code>  数据库中添加数据。你很难使用  <code>Git</code>  从数据库中删除数据，也就是说  <code>Git</code>  几乎不会执行任何可能导致文件不可恢复的操作。一旦提交快照到  <code>Git</code>  中，就难以丢失数据，特别是如果你定期的推送数据库到其它仓库的话，但是未提交更新时有可能丢失或弄乱修改的内容的风险。</p><p>更深度探讨  <code>Git</code>  如何保存数据及恢复丢失数据的话题，请参考<a href="#%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C">撤销操作</a></p><h2 id="三种状态"><a class="markdownIt-Anchor" href="#三种状态">#</a> 三种状态</h2><p><code>Git</code>  有三种状态，你的文件可能处于其中之一：  <code>已提交（committed）</code> 、 <code>已修改（modified）</code> 和  <code>已暂存（staged</code> ）。</p><ul><li><p>已修改表示修改了文件，但还没保存到数据库中。</p></li><li><p>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p></li><li><p>已提交表示数据已经安全地保存在本地数据库中。</p></li></ul><p>这会让我们的  <code>Git</code>  项目拥有三个阶段：工作区、暂存区以及  <code>Git</code>  目录。</p><img src="git_container.png" alt="工作目录、暂存区域以及 Git 仓库" /><p>工作区是对项目的某个版本独立提取出来的内容。 这些从  <code>Git</code>  仓库的压缩数据库中提取出来的文件，放在磁盘上 供你使用或修改。</p><p>暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在  <code>Git</code>  仓库目录中。 按照  <code>Git</code>  的术语叫做 “索引”，不过一般说法还是叫 “暂存区”。</p><p><code>Git</code>  仓库目录是  <code>Git</code>  用来保存项目的元数据和对象数据库的地方。 这是  <code>Git</code>  中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。</p><h3 id="git流程"><a class="markdownIt-Anchor" href="#git流程">#</a>  <code>Git</code>  流程</h3><ol><li>在工作区<strong>修改文件 (modified)</strong></li><li>将下次提交的更改选择性暂存，将部分更改<strong>添加到暂存区 (staged)</strong></li><li>提交更新，找到暂存区的文件，将快照永久性地<strong>存储到 Git 目录 (committed)</strong></li></ol><p>如果  <code>Git</code>  目录中保存着特定版本的文件，就属于<strong>已提交</strong>状态。 如果文件已修改并放入暂存区，就属于<strong>已暂存</strong>状态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是<strong>已修改</strong>状态</p><h1 id="git配置"><a class="markdownIt-Anchor" href="#git配置">#</a> Git 配置</h1><h2 id="初次运行配置"><a class="markdownIt-Anchor" href="#初次运行配置">#</a> 初次运行配置</h2><p><code>Git</code>  自带  <code>git config</code>  工具来帮助设置  <code>Git</code>  外观和行为配置变量，变量分别存储在 3 个不同地文件中</p><ol><li><code>/etc/gitconfig</code>  文件：位于  <code>Git</code>  目录下，包含系统上每一个用户以及仓库的通用配置。执行 <code>git config --list --system</code> 访问该文件</li><li><code>~/.gitconfig</code>  或  <code>~/.config/config</code>  文件（ <code>windows</code>  中位于  <code>%USERPROFILE%</code>  目录下的  <code>.gitconfig</code>  文件）：只针对当前用户。执行 <code>git config --list --global</code> 访问该文件，<strong>这会对你系统上所有的仓库生效</strong>。</li><li>当前使用仓库的  <code>Git</code>  目录中的  <code>.config</code>  文件  <code>.config</code>  ：只针对该仓库。执行 <code>git config --list --local</code> 访问该文件。默认情况使用。</li></ol><p>配置文件会通过 <code>3 &gt; 2 &gt; 1</code>  的顺序进行配置覆盖</p><p>可以执行 <code>git config --list --show-origin</code> 查看所有的配置变量以及它们所在的文件</p><h2 id="配置用户信息"><a class="markdownIt-Anchor" href="#配置用户信息">#</a> 配置用户信息</h2><p>每一次  <code>Git</code>  提交都会将这些信息写入提交中且<strong>不可更改</strong>。邮箱可以不存在，只是用来标识某个用户</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git config <span class="hljs-literal">--global</span> user.name &lt;username&gt; <span class="hljs-comment">#设置提交用户名</span><br>git config <span class="hljs-literal">--global</span> user.email &lt;emai&gt; <span class="hljs-comment">#设置提交邮箱</span><br></code></pre></td></tr></table></figure><p>可以通过  <code>git config &lt;key&gt;</code>  的 方式查看某一变量</p><h2 id="配置文本编辑器"><a class="markdownIt-Anchor" href="#配置文本编辑器">#</a> 配置文本编辑器</h2><p><code>git config --global core.editor &lt;editor&gt;</code> ，若在 windows 中则需添加绝对路径 <code>$ git config --global core.editor &lt;path/to/editor&gt;</code></p><h2 id="检查配置信息"><a class="markdownIt-Anchor" href="#检查配置信息">#</a> 检查配置信息</h2><p>使用  <code>git config --list</code>  命令查看所有配置的变量，Git 会读取所有  <code>.gitconfig</code>  文件，可能会包含相同变量，Git 只使用最后被找到的变量。</p><h2 id="获取帮助"><a class="markdownIt-Anchor" href="#获取帮助">#</a> 获取帮助</h2><p>下面是三种等价配置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git help &lt;verb&gt;<br>git &lt;verb&gt; <span class="hljs-literal">--help</span><br><span class="hljs-built_in">man</span> git-&lt;verb&gt;<br></code></pre></td></tr></table></figure><p>若不想获取太详细的信息，则使用 <code>git &lt;verb&gt; -h</code></p><p>例如，要想获得  <code>git config</code>  命令的手册，执行  <code>git help config</code></p><h1 id="git基础"><a class="markdownIt-Anchor" href="#git基础">#</a> Git 基础</h1><h2 id="获取仓库"><a class="markdownIt-Anchor" href="#获取仓库">#</a> 获取仓库</h2><p>两种方式：</p><ol><li><p>将尚未成为仓库的文件夹变成仓库</p><ol><li><p>通过 cd 命令进入文件夹</p></li><li><p>执行  <code>git init</code>  将该文件夹变为仓库</p><ul><li>该命令将创建一个名为  <code>.git</code>  的子目录，默认为隐藏目录</li></ul></li><li><p>创建并编写文件</p></li><li><p>添加文件至暂存区</p> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git add .<br></code></pre></td></tr></table></figure></li><li><p>可以执行以下命令进行提交</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git commit <span class="hljs-literal">-m</span> <span class="hljs-string">&#x27;initial project version&#x27;</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>从其他服务器克隆一个已存在的 Git 仓库</p><ul><li>运行  <code>git clone &lt;url&gt; [name]</code>  命令获取 Git 仓库<ul><li><code>[name]</code>  ：设置  <code>clone</code>  之后的本地仓库名</li></ul></li></ul></li></ol><h2 id="更新记录至仓库"><a class="markdownIt-Anchor" href="#更新记录至仓库">#</a> 更新记录至仓库</h2><p>工作目录下的文件有且只有<strong>已跟踪</strong>和<strong>未跟踪</strong>两种状态。</p><p><strong>已跟踪</strong>指已被纳入版本控制的文件，在上一次快照有记录。工作一段时间后它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是  <code>Git</code>  已经知道的文件。</p><p>工作目录中除<strong>已跟踪</strong>文件外的其它所有文件都属于<strong>未跟踪</strong>文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为  <code>Git</code>  刚刚检出了它们，而你尚未编辑过它们。</p><p>编辑过某些文件之后，由于自上次提交后你对它们做了修改， <code>Git</code>  将它们标记为已修改文件。 在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。</p><p>文件周期变化如下：</p><img src="git_wk.png" alt="文件的状态变化周期" /><p>使用 <code>git add</code>  命令后即代表该文件被追踪</p><h2 id="检查当前文件状态"><a class="markdownIt-Anchor" href="#检查当前文件状态">#</a> 检查当前文件状态</h2><p>运行 <code>git status</code>  命令查看哪些文件处于什么状态。如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br>On branch master #分支名默认为master<br>Your branch is up-to-date with &#x27;origin/master&#x27;. #该分支同远程服务器上对应的分支没有偏离<br>nothing to commit, working directory clean <br></code></pre></td></tr></table></figure><p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则  <code>Git</code>  会在<a href="#%E6%96%B0%E6%B7%BB%E5%8A%A0%E8%B7%9F%E8%B8%AA%E6%96%87%E4%BB%B6">新添加跟踪文件</a>中列出来</p><h3 id="新添加跟踪文件"><a class="markdownIt-Anchor" href="#新添加跟踪文件">#</a> 新添加跟踪文件</h3><p>例：新建 README.txt 文件</p><p>运行 <code>git status</code>  命令，会出现以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br>On branch master<br>Your branch is up-to-date with &#x27;origin/master&#x27;.<br>Untracked files:<br>  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br>  README.txt<br>nothing added to commit but untracked files present (use &quot;git add&quot; to track)<br></code></pre></td></tr></table></figure><p>在状态报告中可以看到新建的  <code>README.txt</code>  文件出现在  <code>Untracked files</code>  下面，代表其未被跟踪。即未曾出现在快照中。</p><h3 id="跟踪新文件"><a class="markdownIt-Anchor" href="#跟踪新文件">#</a> 跟踪新文件</h3><p>运行 <code>git add README.txt</code>  命令，会出现以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br>On branch master<br>Your branch is up-to-date with &#x27;origin/master&#x27;.<br>Changes to be committed:<br>  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)<br>  new file: README.txt<br></code></pre></td></tr></table></figure><p><strong>Changes to be committed</strong> 代表该文件已被放入<strong>暂存区 (staged)</strong>，现在已被跟踪</p><h3 id="暂存已经修改的文件"><a class="markdownIt-Anchor" href="#暂存已经修改的文件">#</a> 暂存已经修改的文件</h3><p>例：该目录中有一被跟踪的  <code>README.md</code>  文件，我们对其修改后，会出现以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br>On branch master<br>Your branch is up-to-date with &#x27;origin/master&#x27;.<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br>  new file: README<br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working<br>directory)<br>  modified: README.md<br></code></pre></td></tr></table></figure><p>文件  <code>README.md</code>  出现在  <code>Changes not staged for commit</code>  这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。再次运行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git add README.md <span class="hljs-comment">#添加README.md至暂存区</span><br>git status<br></code></pre></td></tr></table></figure><p>会出现以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">On branch master<br>Your branch is up-to-date with &#x27;origin/master&#x27;.<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br>  new file: README.txt<br>  modified: README.md<br></code></pre></td></tr></table></figure><p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。</p><p>此时若你再次修改  <code>README.md</code>  或  <code>README.txt</code>  会出现以下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br>On branch master<br>Your branch is up-to-date with &#x27;origin/master&#x27;.<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br>  new file: README.txt<br>  modified: README.md<br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working<br>directory)<br>  modified: README.md<br></code></pre></td></tr></table></figure><p>代表着  <code>Git</code>  只不过暂存了你运行  <code>git add</code>  命令时的版本。如果你现在提交，版本将会是你最后一次运行  <code>git add</code>  命令时的那个版本，而不是你运行  <code>git commit</code>  时，在工作目录中的当前版本。所以，运行了  <code>git add</code>  之后又作了修订的文件，需要重新运行  <code>git add</code>  把最新版本重新暂存起来：</p><h2 id="状态简览"><a class="markdownIt-Anchor" href="#状态简览">#</a> 状态简览</h2><p><code>git status -s</code>  或 <code>git status --short</code>  可简略查看信息，例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status -s</span><br> M README<br>MM Rakefile<br>A lib/git.rb<br>M lib/simplegit.rb<br>?? LICENSE.txt<br></code></pre></td></tr></table></figure><p><code>??</code>  标记：新添加的未跟踪文件</p><p><code> A</code>  标记：新添加到暂存区中的文件</p><p><code>M </code>  标记：修改过的文件</p><p>输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示：  <code>README</code>  文件 在工作区已修改但尚未暂存，而  <code>lib/simplegit.rb</code>  文件已修改且已暂存。  <code>Rakefile</code>  文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p><h2 id="忽略文件"><a class="markdownIt-Anchor" href="#忽略文件">#</a> 忽略文件</h2><p>忽略文件  <code>.gitignore</code>  的格式规范如下：</p><ul><li>所有空行或者以  <code>#</code>  开头的行都会被 Git 忽略。</li><li>可以使用标准的  <code>glob</code>  模式匹配，它会递归地应用在整个工作区中。 (shell 所使用的简化了的正则表达式)<ul><li><code>*</code>  匹配零个或多个任意字符</li><li><code>[]</code>  匹配括号中的任一字符<ul><li><code>[0-9a-z]</code>  表示可以匹配到  <code>0-9</code>  ，或者  <code>a-z</code>  的任一字符</li></ul></li><li><code>?</code>  匹配任意一个字符</li><li><code>**</code>  表示匹配零个或多个中间目录</li></ul></li><li>匹配模式可以以  <code>/</code>  开头防止递归。 匹配模式可以以  <code>/</code>  结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号  <code>!</code>  取反。</li></ul><h2 id="查看已暂存和未暂存的修改"><a class="markdownIt-Anchor" href="#查看已暂存和未暂存的修改">#</a> 查看已暂存和未暂存的修改</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git <span class="hljs-built_in">diff</span> <span class="hljs-comment">#当前做的哪些更新尚未暂存？</span><br>git <span class="hljs-built_in">diff</span> <span class="hljs-literal">--staged</span> <span class="hljs-comment">#有哪些更新已暂存并准备好下次提交？</span><br></code></pre></td></tr></table></figure><h2 id="提交更新"><a class="markdownIt-Anchor" href="#提交更新">#</a> 提交更新</h2><p>执行  <code>git commit</code>  命令将暂存区的文件提交至仓库。此时 Git 会启动默认的编辑器，编辑器包含首行为一个空行 — 用于写入提示信息，其余为最后一次执行  <code>git add</code>  命令的注释信息内容。关闭编辑器后， <code>Git</code>  会丢弃注释信息，用输入的提交说明完成一次提交。也可直接执行  <code>git commit -m &quot;&lt;msg&gt;&quot;</code>  。成功后， <code>Git</code>  会提示你当前位于哪个分支，本 次提交的完整  <code>SHA-1</code>  校验和是什么，以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p><p>执行  <code>git commit -a</code>  可以跳过暂存区，直接将未放入暂存区的已跟踪文件进行提交。</p><h2 id="移除文件"><a class="markdownIt-Anchor" href="#移除文件">#</a> 移除文件</h2><p>要从  <code>Git</code>  中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用  <code>git rm</code>  命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><ul><li><p>单纯删除工作区文件</p><ul><li><p>使用  <code>linux</code>  命令 <code>rm</code>  就能解决</p></li><li><p>使用  <code>git status</code>  后会出现如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br>On branch master<br>Your branch is up-to-date with &#x27;origin/master&#x27;.<br>Changes not staged for commit:<br>  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working<br>directory)<br>  deleted: 文件名<br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br></code></pre></td></tr></table></figure></li><li><p>必须再次使用  <code>git rm</code>  命令记录这次移除文件操作。下一次提交时，该文件不再列入版本管理，可以说该文件在  <code>Git</code>  仓库中的新版本已经不存在了。</p></li></ul></li><li><p>删除已放入暂存区的文件或已经修改的文件</p> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> &lt;file&gt; <span class="hljs-comment">#会将已放入暂存区的文件删除(工作区的文件将会一并删除)，会暂存一条删除的变化，用于提交</span><br>git <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-literal">--cached</span> &lt;file&gt; <span class="hljs-comment">#会将已放入暂存区的文件删除但仍会保留工作区的文件</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="移动文件修改文件名称"><a class="markdownIt-Anchor" href="#移动文件修改文件名称">#</a> 移动文件 (修改文件名称)</h2><p>不像其它的  <code>VCS</code>  系统， <code>Git</code>  并不显式跟踪文件移动操作。 如果在  <code>Git</code>  中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过  <code>Git</code>  非常聪明，它会推断出究竟发生了什么。</p><p>要在  <code>Git</code>  中对文件改名，使用下面的命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git <span class="hljs-built_in">mv</span> &lt;old<span class="hljs-operator">-file</span><span class="hljs-literal">-name</span>&gt; &lt;<span class="hljs-built_in">new-file</span><span class="hljs-literal">-name</span>&gt;<br></code></pre></td></tr></table></figure><p>它会恰如预期般正常工作。 实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">mv</span> README.md README</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br>On branch master<br>Your branch is up-to-date with &#x27;origin/master&#x27;.<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br>  renamed: README.md -&gt; README<br></code></pre></td></tr></table></figure><p>其实，运行  <code>git mv</code>  就相当于运行了下面三条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mv</span> README.md README</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">rm</span> README.md</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add README</span><br></code></pre></td></tr></table></figure><p>如此分开操作， <code>Git</code>  也会意识到这是一次重命名，所以不管何种方式结果都一样。 两者唯一的区别在于， <code>git mv</code>  是一条命令而非三条命令，直接使用  <code>git mv</code>  方便得多。 不过在使用其他工具重命名文件时，记得在提交前  <code>git rm</code>  删除旧文件名，再  <code>git add</code>  添加新文件名。</p><h2 id="查看提交历史"><a class="markdownIt-Anchor" href="#查看提交历史">#</a> 查看提交历史</h2><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。完成这个任务最简单而又有效的工具是  <code>git log</code>  命令。</p><p>我们使用一个非常简单的 “simplegit” 项目作为示例。 运行下面的命令获取该项目：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git clone https://github.com/schacon/simplegit<span class="hljs-literal">-progit</span><br></code></pre></td></tr></table></figure><p>当你在此项目中运行  <code>git log</code>  命令时，可以看到下面的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span></span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date: Mon Mar 17 21:52:11 2008 -0700<br>  changed the version number<br>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date: Sat Mar 15 16:40:33 2008 -0700<br>  removed unnecessary test<br>commit a11bef06a3f659402fe7563abf99ad00de2209e6<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date: Sat Mar 15 10:31:28 2008 -0700<br>  first commit<br></code></pre></td></tr></table></figure><p>不传入任何参数的默认情况下， <code>git log</code>  会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 <strong>SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明</strong>。</p><h3 id="补丁式的提交历史"><a class="markdownIt-Anchor" href="#补丁式的提交历史">#</a> 补丁式的提交历史</h3><p>使用下面的命令查看补丁：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git log <span class="hljs-literal">-p</span>|<span class="hljs-literal">--patch</span> [-<span class="hljs-type">n</span>] <span class="hljs-comment">#以补丁的方式查看提交历史，n用来限制的日志条目数量</span><br></code></pre></td></tr></table></figure><p>例如显示前两条日志条目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> -p -2</span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date: Mon Mar 17 21:52:11 2008 -0700<br>  changed the version number<br>diff --git a/Rakefile b/Rakefile<br>index a874b73..8f94139 100644<br>--- a/Rakefile<br>+++ b/Rakefile<br>@@ -5,7 +5,7 @@ require &#x27;rake/gempackagetask&#x27;<br> spec = Gem::Specification.new do |s|<br>  s.platform = Gem::Platform::RUBY<br>  s.name = &quot;simplegit&quot;<br>- s.version = &quot;0.1.0&quot;<br>+ s.version = &quot;0.1.1&quot;<br>  s.author = &quot;Scott Chacon&quot;<br>  s.email = &quot;schacon@gee-mail.com&quot;<br>  s.summary = &quot;A simple gem for using Git in Ruby code.&quot;<br>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date: Sat Mar 15 16:40:33 2008 -0700<br>  removed unnecessary test<br>diff --git a/lib/simplegit.rb b/lib/simplegit.rb<br>index a0a60ae..47c6340 100644<br>--- a/lib/simplegit.rb<br>+++ b/lib/simplegit.rb<br>@@ -18,8 +18,3 @@ class SimpleGit<br>  end<br> end<br>-<br>-if $0 == __FILE__<br>- git = SimpleGit.new<br>- puts git.show<br>-end<br></code></pre></td></tr></table></figure><p>该选项除了显示基本信息之外，还附带了每次提交的变化。</p><h3 id="统计式的提交历史"><a class="markdownIt-Anchor" href="#统计式的提交历史">#</a> 统计式的提交历史</h3><p>你也使用以下命令为  <code>git log</code>  显示一系列简略的统计信息：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git log <span class="hljs-literal">--stat</span><br></code></pre></td></tr></table></figure><p>该命令会有以下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span></span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date: Mon Mar 17 21:52:11 2008 -0700<br>  changed the version number<br> Rakefile | 2 +-<br> 1 file changed, 1 insertion(+), 1 deletion(-)<br>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date: Sat Mar 15 16:40:33 2008 -0700<br>  removed unnecessary test<br> lib/simplegit.rb | 5 -----<br> 1 file changed, 5 deletions(-)<br>commit a11bef06a3f659402fe7563abf99ad00de2209e6<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date: Sat Mar 15 10:31:28 2008 -0700<br>  first commit<br> README | 6 ++++++<br> Rakefile | 23 +++++++++++++++++++++++<br> lib/simplegit.rb | 25 +++++++++++++++++++++++++<br> 3 files changed, 54 insertions(+)<br></code></pre></td></tr></table></figure><h3 id="格式化式的提交历史"><a class="markdownIt-Anchor" href="#格式化式的提交历史">#</a> 格式化式的提交历史</h3><p><code>git log</code>  的  <code>--pretty</code>  选项会提供一系列不同的格式化输出</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git log <span class="hljs-literal">--pretty</span>=[<span class="hljs-type">short</span>|<span class="hljs-type">full</span>|<span class="hljs-type">fully</span>|<span class="hljs-type">oneline</span>]<br><span class="hljs-comment">#--short: 包括提交哈希值、分支、作者、提交信息</span><br><span class="hljs-comment">#--full: 包括提交哈希值、分支、作者、提交者、提交信息 </span><br><span class="hljs-comment">#--fuller: 包括提交哈希值、分支、作者、写作日期、提交者、提交日期、提交信息</span><br><span class="hljs-comment">#--oneline: 每次提交总共一行：包括提交哈希值、分支、提交信息</span><br></code></pre></td></tr></table></figure><p>除了上述操作， <code>--pretty</code>  选项提供了更强大的格式参数  <code>format</code>  ：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git log <span class="hljs-literal">--pretty</span>=format:<span class="hljs-string">&quot;&lt;format&gt;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="常用选项"><a class="markdownIt-Anchor" href="#常用选项">#</a> 常用选项</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>%H</code></td><td>提交的完整哈希值</td></tr><tr><td><code>%h</code></td><td>提交的简写哈希值</td></tr><tr><td><code>%T</code></td><td>树的完整哈希值</td></tr><tr><td><code>%t</code></td><td>树的简写哈希值</td></tr><tr><td><code>%P</code></td><td>父提交的完整哈希值</td></tr><tr><td><code>%p</code></td><td>父提交的简写哈希值</td></tr><tr><td><code>%an</code></td><td>作者名字</td></tr><tr><td><code>%ae</code></td><td>作者的电子邮件地址</td></tr><tr><td><code>%ad</code></td><td>作者修订日期（可以用 --date = 选项 来定制格式）</td></tr><tr><td><code>%ar</code></td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td><code>%cn</code></td><td>提交者的名字</td></tr><tr><td><code>%ce</code></td><td>提交者的电子邮件地址</td></tr><tr><td><code>%cd</code></td><td>提交日期</td></tr><tr><td><code>%cr</code></td><td>提交日期（距今多长时间）</td></tr><tr><td><code>%s</code></td><td>提交说明</td></tr></tbody><tbody><tr><td>选项</td><td>说明</td></tr><tr><td>-----------------</td><td>------------------------------------------------------------</td></tr><tr><td><code>-p</code></td><td>按补丁格式显示每个提交引入的差异</td></tr><tr><td><code>--stat</code></td><td>显示每次提交的文件修改统计信息</td></tr><tr><td><code>--shortstat</code></td><td>只显示  <code>--stat</code>  中最后的行数修改添加移除统计</td></tr><tr><td><code>--name-only</code></td><td>仅在提交信息后显示已修改的文件清单</td></tr><tr><td><code>--name-status</code></td><td>显示新增、修改、删除的文件清单</td></tr><tr><td><code>--abbrev-commit</code></td><td>仅显示  <code>SHA-1</code>  校验和所有 40 个字符中的前几个字符</td></tr><tr><td><code>--relative-date</code></td><td>使用较短的相对时间而不是完整格式显示日期（比如 “2 weeks ago”）</td></tr><tr><td><code>--graph</code></td><td>在日志旁以  <code>ASCII</code>  图形显示分支与合并历史</td></tr><tr><td><code>--pretty</code></td><td>使用其他格式显示历史提交信息。可用的选项包括  <code>oneline</code> 、 <code>short</code> 、 <code>full</code> 、 <code>fuller </code> 和  <code>format</code> （用来定义自己的格式）</td></tr><tr><td><code>--oneline</code></td><td><code>--pretty=oneline --abbrev-commit</code>  合用的简写</td></tr></tbody></table><h3 id="限制日志输出数量"><a class="markdownIt-Anchor" href="#限制日志输出数量">#</a> 限制日志输出数量</h3><p>使用如下方式限制日志输出数量：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git log &lt;<span class="hljs-literal">-n</span>&gt; <span class="hljs-comment">#限制n条日志的输出</span><br></code></pre></td></tr></table></figure><h4 id="通过日期限制日志输出数量"><a class="markdownIt-Anchor" href="#通过日期限制日志输出数量">#</a> 通过日期限制日志输出数量</h4><p>使用以下命令限制日志输出数量：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git log &lt;<span class="hljs-literal">--since</span>|<span class="hljs-literal">--until</span>&gt;=&lt;n&gt;.&lt;seconds|minutes|hours|days|monthes|years&gt;<br><span class="hljs-comment">#代表自现在n秒|分钟|小时|日|月份|年的日志</span><br></code></pre></td></tr></table></figure><p>该命令可用的格式十分丰富 —— 可以是类似 “2008-01-15” 的具体的某一天，也可以是类似 “2 years 1 day 3 minutes ago” 的相对日期。</p><p>还可以过滤出匹配指定条件的提交。 用  <code>--author</code>  选项显示指定作者的提交，用  <code>--grep</code>  选项搜索提交说明中 的关键字。</p><blockquote><p>[!Important]</p><p>你可以指定多个  <code>--author</code>  和  <code>--grep</code>  搜索条件，这样会只输出匹配 任意  <code>--author</code>  模式和任意  <code>--grep</code>  模式的提交。然而，如果你添加了  <code>--all-match</code>  选项， 则只会输出匹配所有  <code>--grep</code>  模式的提交。</p></blockquote><p>另一个非常有用的过滤器是  <code>-S</code> （俗称 “pickaxe” 选项，取 “用鹤嘴锄在土里捡石头” 之意）， 它接受一个字符串参数，并且只会显示那些添加或删除了该字符串的提交。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git log <span class="hljs-literal">-s</span> &lt;<span class="hljs-string">&quot;content&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>最后一个很实用的  <code>git log</code>  选项是路径（path）， 如果只关心某些文件或者目录的历史提交，可以在  <code>git log</code>  选项的最后指定它们的路径。 因为是放在最后位置上的选项，所以用两个短划线（–）隔开之前的选项和后面限 定的路径名。</p><h4 id="常用选项-2"><a class="markdownIt-Anchor" href="#常用选项-2">#</a> 常用选项</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-&lt;n&gt;</code></td><td>仅显示最近的  <code>n</code>  条提交</td></tr><tr><td><code>--since</code> ,  <code>--after</code></td><td>仅显示指定时间之后的提交。</td></tr><tr><td><code>--until</code> ,  <code>--before</code></td><td>仅显示指定时间之前的提交。</td></tr><tr><td><code>--author</code></td><td>仅显示作者匹配指定字符串的提交。</td></tr><tr><td><code>--committer</code></td><td>仅显示提交者匹配指定字符串的提交。</td></tr><tr><td><code>--grep</code></td><td>仅显示提交说明中包含指定字符串的提交。</td></tr><tr><td><code>-S</code></td><td>仅显示添加或删除内容匹配指定字符串的提交。</td></tr></tbody></table><h2 id="撤销操作"><a class="markdownIt-Anchor" href="#撤销操作">#</a> 撤销操作</h2><p>在任何一个阶段，你都有可能想要撤消某些操作。 这里，我们将会学习几个撤消你所做修改的基本工具。 注意，有些撤消操作是不可逆的。 这是在使用  <code>Git</code>  的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</p><h3 id="撤销提交"><a class="markdownIt-Anchor" href="#撤销提交">#</a> 撤销提交</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git commit <span class="hljs-literal">--amend</span> <span class="hljs-comment">#该命令会将暂存区中的文件加入上次提交中，同时可以对上次所写的提示信息进行修改。第二次提交将会修改第一次提交</span><br></code></pre></td></tr></table></figure><h3 id="取消暂存的文件"><a class="markdownIt-Anchor" href="#取消暂存的文件">#</a> 取消暂存的文件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git restore <span class="hljs-literal">--staged</span> &lt;file&gt; <span class="hljs-comment">#将暂存区的文件变为恢复至为暂存的状态，并保留使用add命令之后的修改。</span><br>git reset HEAD &lt;file&gt; <span class="hljs-comment">#将暂存区的文件变为恢复至为暂存的状态，并保留使用add命令之后的修改。</span><br></code></pre></td></tr></table></figure><blockquote><p>[!Caution]</p><p><code>git reset</code>  确实是个危险的命令，如果加上了  <code>--hard</code>  选项则更是如此。 然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。</p><p>到目前为止这个神奇的调用就是你需要对  <code>git reset</code>  命令了解的全部。 我们将会在<a href="#%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86">重置揭密</a>中了解 reset 的 更多细节以及如何掌握它做一些真正有趣的事。</p></blockquote><h3 id="撤销文件的修改"><a class="markdownIt-Anchor" href="#撤销文件的修改">#</a> 撤销文件的修改</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git checkout <span class="hljs-literal">--</span> &lt;file&gt; <span class="hljs-comment">#将工作区的文件恢复至最后一次提交的状态。</span><br>git restore &lt;file&gt; <span class="hljs-comment">#将工作区的文件恢复至最后一次提交的状态。</span><br></code></pre></td></tr></table></figure><blockquote><p>[!Caution]</p><p>请务必记得  <code>git checkout --</code>  是一个危险的命令。 你对那个文件在本地的任何修改都会消失 ——  <code>Git</code>  会用最近提交的版本覆盖掉它。除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</p></blockquote><blockquote><p>记住，在  <code>Git</code>  中任何已提交的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用  <code>--amend</code>  选项覆盖的提交也可以恢复（阅读<a href="#%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D">数据恢复</a>了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。</p></blockquote><h2 id="远程仓库"><a class="markdownIt-Anchor" href="#远程仓库">#</a> 远程仓库</h2><p>远程仓库是指托管在因特网或其他网络中的你的项目的版本库。你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git clone &lt;url&gt; <span class="hljs-comment"># Git 会自动为该 URL 创建一个名为 origin 的仓库名。</span><br></code></pre></td></tr></table></figure><h3 id="查看远程仓库"><a class="markdownIt-Anchor" href="#查看远程仓库">#</a> 查看远程仓库</h3><p>使用如下命令，会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到  <code>origin</code>  —— 这是  <code>Git</code>  给你克隆的仓库服务器的默认名字</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git remote <span class="hljs-comment">#查看已创建的仓库名</span><br>git remote <span class="hljs-literal">-v</span> <span class="hljs-comment">#可以查看需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</span><br></code></pre></td></tr></table></figure><h4 id="查看单个远程仓库"><a class="markdownIt-Anchor" href="#查看单个远程仓库">#</a> 查看单个远程仓库</h4><p>如果想要查看某一个远程仓库的更多信息，可以运行以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git remote show &lt;repo&gt; <span class="hljs-comment">#查看某个指定仓库</span><br></code></pre></td></tr></table></figure><p>它同样会列出远程仓库的  <code>URL</code>  与跟踪分支的信息。 这些信息非常有用，它告诉你正处于哪个分支，并且如果运行  <code>git pull</code> ， 就会抓取所有的远程引用，然后将远程  <code>master</code>  分支合并到本地  <code>master</code>  分支。 它也会列出拉取到的所有远程引用。</p><p>这个命令会列出当你在特定的分支上执行  <code>git push</code>  会自动地推送到哪一个远程分支。它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行  <code>git pull</code>  时哪些本地分支可以与它跟踪的远程分支自动合并。</p><h3 id="添加远程仓库"><a class="markdownIt-Anchor" href="#添加远程仓库">#</a> 添加远程仓库</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git remote add &lt;repo&gt; &lt;url&gt; <span class="hljs-comment">#为指定的 URL 创建仓库</span><br></code></pre></td></tr></table></figure><h3 id="远程仓库的重命名与移除"><a class="markdownIt-Anchor" href="#远程仓库的重命名与移除">#</a> 远程仓库的重命名与移除</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git remote rename &lt;old<span class="hljs-literal">-repo</span>&gt; &lt;<span class="hljs-built_in">new-repo</span>&gt; <span class="hljs-comment">#重命名,值得注意的是这同样也会修改你所有远程跟踪的分支名字</span><br>git remote remove &lt;repo&gt; <span class="hljs-comment">#删除某个远程仓库，所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除</span><br></code></pre></td></tr></table></figure><h3 id="推送到远程仓库"><a class="markdownIt-Anchor" href="#推送到远程仓库">#</a> 推送到远程仓库</h3><p>当你想分享你的项目时，必须将其推送到上游，使用以下命令推送至远程仓库</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git push &lt;repo&gt; &lt;branch&gt; <span class="hljs-comment">#向指定仓库推送指定的分支</span><br></code></pre></td></tr></table></figure><h3 id="从远程仓库中抓取与拉取"><a class="markdownIt-Anchor" href="#从远程仓库中抓取与拉取">#</a> 从远程仓库中抓取与拉取</h3><p>从远程仓库中获得数据，可以执行如下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git fetch &lt;repo&gt; <span class="hljs-comment">#拉取远程仓库的默认分支的最新内容</span><br></code></pre></td></tr></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><blockquote><p>[!Caution]</p><p>必须注意  <code>git fetch</code>  命令只会将数据下载到你的本地仓库 ——<strong> 它并不会自动合并或修改你当前的工作</strong>。当准备好时你必须手动将其合并入你的工作。</p></blockquote><p>如果你的当前分支设置了跟踪远程分支（阅读下一节<a href="#%E5%88%86%E6%94%AF"> Git 分支</a>了解更多信息），那么可以用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下， <code>git clone</code>  命令会自动设置本地  <code>master</code>  分支跟踪克隆的远程仓库的  <code>master</code>  分支（或其它名字的默认分支）。运行  <code>git pull</code>  通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git pull &lt;repo&gt; <span class="hljs-comment">#拉取远程仓库的默认分支的最新内容并合并分支</span><br></code></pre></td></tr></table></figure><h2 id="打标签"><a class="markdownIt-Anchor" href="#打标签">#</a> 打标签</h2><p>像其他版本控制系统（ <code>VCS</code> ）一样， <code>Git</code>  可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（  <code>v1.0</code>  、 <code>v2.0</code>  等等）。</p><h3 id="列出标签"><a class="markdownIt-Anchor" href="#列出标签">#</a> 列出标签</h3><p>在 Git 中列出已有的标签非常简单，只需要输入如下命令，就能按字母顺序列出标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git tag [-l]|[--list]</span><br>v1.0<br>v2.0<br></code></pre></td></tr></table></figure><p>你也可以按照特定的模式查找标签。 例如， <code>Git</code>  自身的源代码仓库包含标签的数量超过  <code>500</code>  个。 如果只对  <code>1.8.5</code>  系列感兴趣，可以运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git tag -l <span class="hljs-string">&quot;v1.8.5*&quot;</span></span><br>v1.8.5<br>v1.8.5-rc0<br>v1.8.5-rc1<br>v1.8.5-rc2<br>v1.8.5-rc3<br>v1.8.5.1<br>v1.8.5.2<br>v1.8.5.3<br>v1.8.5.4<br>v1.8.5.5<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git tag <span class="hljs-literal">-l</span> &lt;regex&gt; <span class="hljs-comment">#按照正则模式查找标签</span><br></code></pre></td></tr></table></figure><blockquote><p>[!Important]</p><p>按照通配符列出标签需要  <code>-l</code>  或  <code>--list</code>  选项，如果你只想要完整的标签列表，那么运行  <code>git tag</code>  就会默认假定你想要一个列表，它会直接给你列出来， 此时的  <code>-l</code>  或  <code>--list</code>  是可选的。 然而，如果你提供了一个匹配标签名的通配模式，那么  <code>-l</code>  或  <code>--list</code>  就是强制使用的。</p></blockquote><h3 id="创建标签"><a class="markdownIt-Anchor" href="#创建标签">#</a> 创建标签</h3><p>Git 支持两种标签：<strong>轻量标签（lightweight</strong>）与 <strong>附注标签（annotated）</strong>。</p><p>轻量标签很像一个不会改变的分支 —— 它只是某个特定提交的引用。</p><p>附注标签是存储在  <code>Git</code>  数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件 地址、日期时间，此外还有一个标签信息，并且可以使用  <code>GNU Privacy Guard （GPG）</code> 签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。</p><h4 id="附注标签"><a class="markdownIt-Anchor" href="#附注标签">#</a> 附注标签</h4><p>使用以下方式添加附注标签：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git tag <span class="hljs-literal">-a</span> &lt;tagname&gt; <span class="hljs-literal">-m</span> <span class="hljs-string">&quot;&lt;msg&gt;&quot;</span><br></code></pre></td></tr></table></figure><p><code>-m</code>  选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息， <code>Git</code>  会启动编辑器要求你输入信息。</p><p>通过使用  <code>git show</code>  命令可以看到标签信息和与之对应的提交信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git show v1.4</span><br>tag v1.4<br>Tagger: Ben Straub &lt;ben@straub.cc&gt;<br>Date: Sat May 3 20:19:12 2014 -0700<br>my version 1.4<br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date: Mon Mar 17 21:52:11 2008 -0700<br>  changed the version number<br></code></pre></td></tr></table></figure><h4 id="轻量标签"><a class="markdownIt-Anchor" href="#轻量标签">#</a> 轻量标签</h4><p>轻量标签本质上是将提交校验和存储到一个文件中 —— 没有保存任何其他信息。 创建轻量标签，不需要使用  <code>-a</code> 、 <code>-s</code>  或  <code>-m</code>  选项，只需要提供标签名字：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git tag &lt;tagname&gt;<br></code></pre></td></tr></table></figure><p>这时，如果在标签上运行  <code>git show</code> ，你不会看到额外的标签信息。 命令只会显示出提交信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git show v1.4-lw</span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date: Mon Mar 17 21:52:11 2008 -0700<br>  changed the version number<br></code></pre></td></tr></table></figure><h4 id="后期打标签"><a class="markdownIt-Anchor" href="#后期打标签">#</a> 后期打标签</h4><p>你也可以对过去的提交打标签。 假设提交历史是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> --pretty=oneline</span><br>15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#x27;experiment&#x27;<br>a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support<br>0d52aaab4479697da7686c15f77a3d64d9165190 one more thing<br>6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#x27;experiment&#x27;<br>0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function<br>4682c3261057305bdd616e23b64b0857d832627b added a todo file<br>166ae0c4d3f420721acbb115cc33848dfcc2121a started write support<br>9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile<br>964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo<br>8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme<br></code></pre></td></tr></table></figure><p>现在，假设在  <code>v1.2</code>  时你忘记给项目打标签，也就是在 “ <code>updated rakefile</code> ” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git tag <span class="hljs-literal">-a</span> v1.<span class="hljs-number">2</span> <span class="hljs-number">9</span>fceb02<br></code></pre></td></tr></table></figure><h3 id="共享标签"><a class="markdownIt-Anchor" href="#共享标签">#</a> 共享标签</h3><p>默认情况下， <code>git push</code>  命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 —— 你可以运行以下命令来推送标签：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git push &lt;repo&gt; &lt;tagname&gt; <span class="hljs-comment">#推送标签至远程仓库</span><br>git push &lt;repo&gt; <span class="hljs-literal">--tags</span> <span class="hljs-comment">#推送所有不在远程仓库服务器上的标签至远程仓库</span><br></code></pre></td></tr></table></figure><blockquote><p>[!Important]</p><p><code>git push</code>  推送两种标签 使用  <code>git push  --tags</code>  推送标签并不会区分轻量标签和附注标签， 没有简单的选项能够让你只选择推送一种标签。</p></blockquote><h3 id="删除标签"><a class="markdownIt-Anchor" href="#删除标签">#</a> 删除标签</h3><p>要删除掉你本地仓库上的标签，可以使用如下名命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git tag <span class="hljs-literal">-d</span> &lt;tagname&gt;<br></code></pre></td></tr></table></figure><p>注意上述命令并不会从任何远程仓库中移除这个标签，你必须用如下命令来更新远程仓库：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; <span class="hljs-comment">#这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。</span><br></code></pre></td></tr></table></figure><p>另外一种高效的删除方式为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git push &lt;repo&gt; <span class="hljs-literal">--delete</span> &lt;tagname&gt;<br></code></pre></td></tr></table></figure><h3 id="检出标签"><a class="markdownIt-Anchor" href="#检出标签">#</a> 检出标签</h3><p>如果你想查看某个标签所指向的文件版本，可以使用如下命令，</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git checkout &lt;tagname&gt;<br></code></pre></td></tr></table></figure><blockquote><p>[!Caution]</p><p>这个操作使你的仓库处于 “ <strong>分离头指针（detached HEAD）</strong>” 的状态 —— 这个状态有些不好的副作用</p><p>在 “分离头指针” 状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支</p></blockquote><h3 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作">#</a> 基本操作</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git tag [-<span class="hljs-type">l</span>]|[--<span class="hljs-type">list</span>] <span class="hljs-comment">#以字母顺序展示标签</span><br>git tag <span class="hljs-literal">-l</span>|<span class="hljs-literal">--list</span> &lt;regx&gt; <span class="hljs-comment">#通过正则表达式查找标签</span><br>git show &lt;tag&gt; <span class="hljs-comment">#查看某个标签的内容</span><br>git tag <span class="hljs-literal">-d</span> &lt;tag&gt; <span class="hljs-comment">#删除本地某个标签</span><br>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; <span class="hljs-comment">#删除远程仓库的指定标签</span><br>git push &lt;remote&gt; <span class="hljs-literal">--delete</span> &lt;remote&gt; <span class="hljs-comment">#删除远程仓库的指定标签</span><br>git push &lt;remote&gt; tags <span class="hljs-comment">#向远程仓库推送所有标签</span><br></code></pre></td></tr></table></figure><h2 id="git别名"><a class="markdownIt-Anchor" href="#git别名">#</a> Git 别名</h2><p><code>Git</code>  并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的  <code>Git</code>  命令，可以通过  <code>git config</code>  文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git config <span class="hljs-literal">--global</span> alias.co checkout<br>git config <span class="hljs-literal">--global</span> alias.br branch<br>git config <span class="hljs-literal">--global</span> alias.ci commit<br>git config <span class="hljs-literal">--global</span> alias.st status<br></code></pre></td></tr></table></figure><p>现在你你可以使用如下别名来代替一些命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git co <span class="hljs-comment">#git checkout</span><br>git br <span class="hljs-comment">#git branch</span><br>git ci <span class="hljs-comment">#git commit</span><br>git st <span class="hljs-comment">#git status</span><br></code></pre></td></tr></table></figure><p>可以看出， <code>Git</code>  只是简单地将别名替换为对应的命令。</p><p>然而，你可能想要执行外部命令，而不是一个  <code>Git</code>  子命令。 如果是那样的话，可以在命令前面加入 <code>!</code>  符号。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git config <span class="hljs-literal">--global</span> alias.l <span class="hljs-string">&#x27;!ls&#x27;</span><br></code></pre></td></tr></table></figure><p>这样当你执行  <code>git l</code>  命令时，实际上会执行  <code>ls</code>  命令</p><h1 id="git分支"><a class="markdownIt-Anchor" href="#git分支">#</a> Git 分支</h1><p>几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。在很多版本控制系统中，这是一个略微低效的过程 —— 常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p><p>然而  <code>Git</code>  处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同， <code>Git</code>  鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。理解和精通这一特性，你便会意识到  <code>Git</code>  是如此的强大而又独特，并且从此真正改变你的开发方式。</p><h2 id="分支简介"><a class="markdownIt-Anchor" href="#分支简介">#</a> 分支简介</h2><p>在进行提交操作时， <code>Git</code>  会保存一个<strong>提交对象（commit object）</strong>。 知道了  <code>Git</code>  保存数据的方式，我们可以很自然的想到 —— 该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。 首次提交产生的提交对象没有父对象，<strong>普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象</strong>。</p><p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用我们在<a href="#%E4%BF%9D%E8%AF%81%E5%AE%8C%E6%95%B4%E6%80%A7">完整性</a>中提到的 <strong>SHA-1 哈希算法</strong>），然后会把当前版本的文件快照保存到  <code>Git</code>  仓库中 （ <code>Git</code>  使用  <code>blob</code>  对象来保存它们），最终将校验和加入到暂存区域等待提交。</p><p>当使用  <code>git commit</code>  进行提交操作时， <code>Git</code>  会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后 在  <code>Git</code>  仓库中这些校验和保存为树对象。随后， <code>Git</code>  便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个<strong>树对象（项目根目录）<strong>的</strong>指针</strong>。 如此一来， <code>Git</code>  就可以在需要的时候重现此次保存的快照。 现在， <code>Git</code>  仓库中有五个对象：三个 <strong>blob 对象（保存着文件快照）</strong>、一个 ** 树对象（记录着目录结构和 blob 对 象索引）** 以及一个 <strong>提交对象（包含着指向前述树对象的指针和所有提交信息）</strong>。</p><p>首次提交对象及其树结构如下：</p><img src="ct_first.png" alt="首次提交对象及其树结构" /><p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针：</p><img src="ct.png" alt="提交对象及其父对象" /><h2 id="git-分支本质"><a class="markdownIt-Anchor" href="#git-分支本质">#</a> Git 分支本质</h2><p>指向提交对象的可移动<strong>指针</strong>，默认名字为  <code>master</code>  。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的  <code>master</code>  分支。  <code>master</code>  分支会在每次提交时自动向前移动。</p><blockquote><p>[!Note]</p><p><code>Git</code>  的  <code>master</code>  分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有  <code>master</code>  分支，是因为  <code>git init</code>  命令默认创建它，并且大多数人都懒得去改动它。</p></blockquote><img src="git_history.png" alt="分支及其提交历史"><h2 id="分支新建"><a class="markdownIt-Anchor" href="#分支新建">#</a> 分支新建</h2><p>使用如下命令创建一个分支：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git branch &lt;branch&gt; <span class="hljs-comment">#这会在当前所在的提交对象上创建一个指针</span><br></code></pre></td></tr></table></figure><p>当然上述命令并不会让你切换至新创建的分支</p><p>例如：当我想创建一个  <code>testing</code>  分支，使用如下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git branch testing<br></code></pre></td></tr></table></figure><p>提交历史会如下显示：</p><img src="git_new_branch.png" alt="两个指向相同提交历史的分支"><p>那么， <code>Git</code>  又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为  <code>HEAD</code>  的特殊指针。<strong>指向当前所在的本地分支</strong>。</p><img src="git_head.png" alt="HEAD 指向当前所在的分支"><h2 id="分支切换"><a class="markdownIt-Anchor" href="#分支切换">#</a> 分支切换</h2><p>执行如下命令切换至对应分支：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git checkout &lt;branch&gt;<br></code></pre></td></tr></table></figure><p>这样  <code>HEAD</code>  就会指向指定的分支了。当你再次提交时，指定的分支和  <code>HEAD</code>  将会向前移动，其他分支将会留在原地。</p><blockquote><p>[!Important]</p><p>分支切换会改变你工作目录中的文件。在切换分支时，一定要注意<strong>你工作目录里的文件会被改变</strong>。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果  <code>Git</code>  不能干净利落地完成这个任务，它将禁止切换分支。</p></blockquote><p>若你想在创建分支的时候自动切换至新分支，可以执行如下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git checkout <span class="hljs-literal">-b</span> &lt;branch&gt;<br></code></pre></td></tr></table></figure><h3 id="分支分叉查看"><a class="markdownIt-Anchor" href="#分支分叉查看">#</a> 分支分叉查看</h3><p>当你再新创建的分支和旧分支上都做了提交，这个项目的提交历史就会产生分叉，例如：</p><img src="branch_split.png" alt="项目分叉历史"><p>执行如下命令，查看提交历史、各个分支的指向以及项目的分支分叉情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> --oneline --decorate --graph --all</span><br>* c2b9e (HEAD, master) made other changes<br>| * 87ab2 (testing) made a change<br>|/<br>* f30ab add feature #32 - ability to add new formats to the<br>* 34ac2 fixed bug #1328 - stack overflow under certain conditions<br>* 98ca9 initial commit of my project<br></code></pre></td></tr></table></figure><blockquote><p>[!Important]</p><p>由于  <code>Git</code>  的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？</p></blockquote><h2 id="分支删除"><a class="markdownIt-Anchor" href="#分支删除">#</a> 分支删除</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git branch <span class="hljs-literal">-d</span> &lt;branch&gt; <span class="hljs-comment">#删除指定分支</span><br>git branch <span class="hljs-literal">-D</span> &lt;branch&gt; <span class="hljs-comment">#可以强制删除处于未合并状态的分支</span><br></code></pre></td></tr></table></figure><h2 id="分支的合并"><a class="markdownIt-Anchor" href="#分支的合并">#</a> 分支的合并</h2><p>如果你想将两个分支合并在一起，使用如下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git checkout &lt;branch<span class="hljs-literal">-from</span>&gt;<br>git merge &lt;branch<span class="hljs-literal">-to</span>&gt; <span class="hljs-comment">#将&lt;branch-from&gt;分支合并到&lt;branch-to&gt;</span><br></code></pre></td></tr></table></figure><p>当你成功合并后，就可以删除你不要的分支：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git branch <span class="hljs-literal">-d</span> &lt;branch&gt;<br></code></pre></td></tr></table></figure><h4 id="简单分支合并"><a class="markdownIt-Anchor" href="#简单分支合并">#</a> 简单分支合并</h4><p>这种情况是，想合并的分支是所处的分支的直接后继。</p><p>执行合并分支命令后， <code>Git</code>  会提醒你 <strong>Fast-forward (快进)</strong> ，这意为简单的移动分支指针。</p><blockquote><p><strong>Fast-forward (快进)</strong> ：当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么  <code>Git</code>  在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧。</p></blockquote><h4 id="复杂分支合并"><a class="markdownIt-Anchor" href="#复杂分支合并">#</a> 复杂分支合并</h4><p>想合并的分支不为所处的分支的直接后继。换言之，想和并的分支在所处分支之前就已经<strong>分叉开 (diverged)<strong> 了，即两个分支同时拥有一个</strong>共同的祖先</strong>。</p><p>这时当执行合并命令时，Git 会将<strong>共同祖先的快照</strong>，<strong>所处分支的快照</strong>，<strong>想合并分支的快照</strong>进行一个简单的三方合并。 <code>Git</code>  会创建一个新的快照，并同时创建一个提交对象指向它，随后移动所处分支至该提交对象处。此时这个提交对象拥有两个祖先 (所处分支和想和并分支指向的提交对象)。移动所处分支至新的提交对象。</p><h4 id="遇到冲突时的分支合并"><a class="markdownIt-Anchor" href="#遇到冲突时的分支合并">#</a> 遇到冲突时的分支合并</h4><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修 改， <code>Git</code>  就没法干净的合并它们。</p><p>此时  <code>Git</code>  做了合并，但是没有自动地创建一个新的合并提交。  <code>Git</code>  会暂停下来，等待你去解决合并产生的冲突。</p><p>你可以在合并冲突后的任意时刻使用  <code>git status</code>  命令来查看那些因包含合并冲突而处于 ** 未合并（unmerged）** 状态的文件。</p><p><code>Git</code>  会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html<br>&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;<br>=======<br>&lt;div id=&quot;footer&quot;&gt;<br> please contact us at support@github.com<br>&lt;/div&gt;<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></code></pre></td></tr></table></figure><p>在冲突文件中， <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>  以下， <code>=======</code>  以上为  <code>HEAD</code>  所指向的分支的内容， <code>=======</code>  以下， <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;branch&gt;</code>  以上为想合并的分支的内容。为了解决冲突，你必须选择使用由  <code>=======</code>  分割的两部分中的一个，或者你也可以自行合并这些内容。并且删除  <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>  ,  <code>=======</code>  , 和  <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>  这些内容。</p><p>在你解决了所有文件里的冲突之后，对每个文件使用  <code>git add</code>  命令来将其标记为冲突已解决。或者使用或者 <code>git mergetool</code>  命令通过  <code>Git</code>  自带的可视化程序执行修改。一旦暂存这些原本有冲突的文件， <code>Git</code>  就会将它们标记为冲突已解决。</p><p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入  <code>git commit</code>  来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">Merge branch &#x27;iss53&#x27;<br>Conflicts:<br>  index.html<br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># It looks like you may be committing a merge.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">If this is not correct, please remove the file</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">.MERGE_HEAD</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">and try again.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Please enter the commit message <span class="hljs-keyword">for</span> your changes. Lines starting</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">with <span class="hljs-string">&#x27;#&#x27;</span> will be ignored, and an empty message aborts the commit.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">On branch master</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">All conflicts fixed but you are still merging.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Changes to be committed:</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">modified: index.html</span><br><span class="hljs-meta prompt_">#</span><br></code></pre></td></tr></table></figure><h2 id="分支管理"><a class="markdownIt-Anchor" href="#分支管理">#</a> 分支管理</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git branch <span class="hljs-comment">#可查看已有分支。其中带*号的为HEAD指向的分支</span><br>git branch <span class="hljs-literal">-v</span> <span class="hljs-comment">#查看各个分支的最后一次提交。</span><br>git branch <span class="hljs-literal">--merged</span>|<span class="hljs-literal">--no-merged</span> [<span class="hljs-type">branch</span>] <span class="hljs-comment">#查看&lt;已|未&gt;合并到[当前|指定]分支的分支</span><br>git branch <span class="hljs-literal">-M</span> &lt;branch&gt; <span class="hljs-comment">#将当前分支重命名未&lt;branch&gt;</span><br></code></pre></td></tr></table></figure><h2 id="远程分支"><a class="markdownIt-Anchor" href="#远程分支">#</a> 远程分支</h2><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过如下命令来显式地获得远程引用的完整列表：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git <span class="hljs-built_in">ls</span><span class="hljs-literal">-remote</span> &lt;remote&gt;<br></code></pre></td></tr></table></figure><p>或者通过如下命令获得远程分支的更多信息：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git remote show &lt;remote&gt;<br></code></pre></td></tr></table></figure><p>然而，一个更常见的做法是利用<strong>远程跟踪分支</strong>。</p><h3 id="远程跟踪分支"><a class="markdownIt-Anchor" href="#远程跟踪分支">#</a> 远程跟踪分支</h3><p><strong>远程跟踪分</strong>支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信，  <code>Git</code>  就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。</p><p>它们以  <code>&lt;remote&gt;/&lt;branch&gt;</code>  的形式命名。 例如，如果你想要看你最后一次与远程仓库  <code>origin</code>  通信时  <code>master</code>  分支的状态，你可以查看  <code>origin/master</code>  分支。 你与同事合作解决一个问题并且他们推送了一个  <code>iss53</code>  分支，你可能有自己的本地  <code>iss53</code>  分支， 然而在服务器上的分支会以  <code>origin/iss53</code>  来表示。 这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在  <code>git.ourcompany.com</code>  的  <code>Git</code>  服 务器。 如果你从这里克隆， <code>Git</code>  的  <code>clone</code>  命令会为你自动将其命名为  <code>origin</code> ，拉取它的所有数据， 创建一个指向它的  <code>master</code>  分支的指针，并且在本地将其命名为  <code>origin/master</code> 。  <code>Git</code>  也会给你一个与  <code>origin</code>  的 m <code>aster</code>  分支在指向同一个地方的本地  <code>master</code>  分支，这样你就有工作的基础。</p><img src="after_clone.png" alt="克隆之后的服务器与本地仓库"/><p>如果你在本地的  <code>master</code>  分支做了一些工作，在同一段时间内有其他人推送提交到  <code>git.ourcompany.com</code>  并且更新了它的  <code>master</code>  分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与  <code>origin</code>  服务器连接（并拉取数据），你的  <code>origin/master</code>  指针就不会移动。</p><img src="remote_local.png" alt="本地与远程的工作可以分叉"/><p>如果要与给定的远程仓库同步数据，使用以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git fetch &lt;remote&gt;<br>git fetch origin <span class="hljs-comment">#本例中</span><br></code></pre></td></tr></table></figure><p>这个命令查找 “origin” 是哪一个服务器（在本例中，它是  <code>git.ourcompany.com</code> ），从中抓取本地没有的数据，并且更新本地数据库，移动  <code>origin/master</code>  指针到更新之后的位置。</p><img src="fetch.png" alt=" git fetch 更新你的远程跟踪分支"><h3 id="推送"><a class="markdownIt-Anchor" href="#推送">#</a> 推送</h3><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。本地的分支并不会自动与远程仓库同步 —— 你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p><p>使用如下命令进行推送：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git push &lt;remote&gt; &lt;branch&gt;<br></code></pre></td></tr></table></figure><p>这里有些工作被简化了。  <code>Git</code>  自动将  <code>&lt;branch&gt;</code>  分支名字展开为：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">refs/heads/&lt;branch&gt;<span class="hljs-symbol">:refs/heads/&lt;branch&gt;</span><br></code></pre></td></tr></table></figure><p>你也可以运行以下命令进行推送：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git push origin &lt;branch&gt;:&lt;branch&gt;<br></code></pre></td></tr></table></figure><p>它会做同样的事 —— 也就是说 “推送本地的  <code>&lt;branch&gt;</code>  分支，将其作为远程仓库的  <code>&lt;branch&gt;</code>  分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。</p><p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支  <code>&lt;remote&gt;/&lt;branch&gt;</code> ，指向服务器的  <code>&lt;branch&gt;</code>  分支的引用。</p><p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的  <code>&lt;branch&gt;</code>  分支 —— 只有一个不可以修改的  <code>&lt;remote&gt;/&lt;branch&gt;</code>  指针。</p><p>可以运行合并命令将这些工作合并到当前所在的分支。 如果想要在自己的本地分支上工作，可以将其建立在远程跟踪分支之上：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git checkout <span class="hljs-literal">-b</span> &lt;<span class="hljs-built_in">new-branch</span>&gt; &lt;old<span class="hljs-literal">-sbranch</span>&gt;<br></code></pre></td></tr></table></figure><p>这会给你一个用于工作的本地分支，并且起点位于  <code>&lt;old-sbranch&gt;</code> 。</p><h3 id="跟踪分支"><a class="markdownIt-Anchor" href="#跟踪分支">#</a> 跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的 “跟踪分支”（它跟踪的分支叫做 “上游分支”）。跟踪分支是与远程分支有直接关系的本地分支。如果在一个跟踪分支上输入  <code>git pull</code> ， <code>Git</code>  能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><p>当克隆一个仓库时，它通常会自动地创建一个跟踪  <code>origin/master</code>  的  <code>master</code>  分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪  <code>master</code>  分支。 最简单的实例就是像之前看到的那样，运行 <code>git checkout -b &lt;new-branch&gt; &lt;old-sbranch&gt;</code></p><p>这是一个十分常用 的操作所以 Git 提供了  <code>--track</code>  快捷方式：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git checkout <span class="hljs-literal">--track</span> &lt;remote&gt;/&lt;branch&gt; <span class="hljs-comment">#创建一个跟踪&lt;remote&gt;/&lt;branch&gt;的跟踪分支</span><br></code></pre></td></tr></table></figure><p>由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么  <code>Git</code>  就会为你创建一个跟踪分支：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git checkout &lt;branch&gt;<br></code></pre></td></tr></table></figure><p>如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git checkout <span class="hljs-literal">-b</span> &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;<br></code></pre></td></tr></table></figure><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用  <code>-u</code>  或  <code>--set-upstream-to</code>  选项运行  <code>git branch</code>  来显式地设置：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git branch <span class="hljs-literal">-u</span> &lt;remote&gt;/&lt;branch&gt;<br></code></pre></td></tr></table></figure><blockquote><p>[!Important]</p><p>上游快捷方式</p><p>当设置好跟踪分支后，可以通过简写  <code>@&#123;upstream&#125;</code>  或  <code>@&#123;u&#125;</code>  来引用它的上游分支。 所以处于  <code>master</code>  分支时并且它正在跟踪  <code>origin/master</code>  时，如果愿意的话可以使用  <code>git merge @&#123;u&#125;</code>  来取代  <code>git merge origin/master</code> 。</p></blockquote><p>如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -vv</span><br>  iss53 7e424c3 [origin/iss53: ahead 2] forgot the brackets<br>  master 1ae2a45 [origin/master] deploying index fix<br>* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this<br>should do it<br>  testing 5ea463a trying something new<br></code></pre></td></tr></table></figure><p>这里可以看到  <code>iss53</code>  分支正在跟踪  <code>origin/iss53</code>  并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。也能看到  <code>master</code>  分支正在跟踪  <code>origin/master</code>  分支并且是最新的。接下来可以看到  <code>serverfix</code>  分支正在跟踪  <code>teamone</code>  服务器上的  <code>server-fix-good</code>  分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到  <code>testing</code>  分支并没有跟踪任何远程分支。</p><p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。如果想要统计最新的领先与落后数字，需要在运行此命令前抓 取所有的远程仓库。 可以像这样做：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git fetch <span class="hljs-literal">--all</span><br>git branch <span class="hljs-literal">-vv</span><br></code></pre></td></tr></table></figure><h3 id="拉取"><a class="markdownIt-Anchor" href="#拉取">#</a> 拉取</h3><p>当  <code>git fetch</code>  命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然 后让你自己合并。 然而，有一个命令叫作  <code>git pull</code>  在大多数情况下它的含义是一个  <code>git fetch</code>  紧接着一个  <code>git merge</code>  命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过  <code>clone</code>  或  <code>checkout</code>  命令为你创建的， <code>git pull</code>  都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。 由于  <code>git pull</code>  的魔法经常令人困惑所以通常单独显式地使用  <code>fetch</code>  与  <code>merge</code>  命令会更好一些。</p><h3 id="删除远程分支"><a class="markdownIt-Anchor" href="#删除远程分支">#</a> 删除远程分支</h3><p>假设你已经通过远程分支做完所有的工作了 —— 也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的  <code>master</code>  分支（或任何其他稳定代码分支）。 可以运行带有 - <code>-delete</code>  选项的  <code>git push</code>  命令 来删除一个远程分支。 如果想要从服务器上删除  <code>serverfix</code>  分支，运行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin --delete serverfix</span><br>To https://github.com/schacon/simplegit<br> - [deleted] serverfix<br></code></pre></td></tr></table></figure><p>基本上这个命令做的只是从服务器上移除这个指针。  <code>Git</code>  服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p><h2 id="变基"><a class="markdownIt-Anchor" href="#变基">#</a> 变基</h2><p>在  <code>Git</code>  中整合来自不同分支的修改主要有两种方法： <code>merge</code>  以及  <code>rebase</code> 。 在本节中我们将学习什么是 “变基”，怎样使用 “变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p><h3 id="变基的基本操作"><a class="markdownIt-Anchor" href="#变基的基本操作">#</a> 变基的基本操作</h3><p>请考虑下面一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p><img src="branch_split.png" alt="分叉的提交历史"/><p>之前介绍过，整合分支最容易的方法是  <code>merge</code>  命令。 它会把两个分支的最新快照（ <code>C3</code>  和  <code>C4</code> ）以及二者最近的共同祖先（ <code>C2</code> ）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p><img src="merge.png" alt="通过合并操作来整合分叉的历史"/><p>其实，还有一种方法：你可以提取在  <code>C4</code>  中引入的补丁和修改，然后在  <code>C3</code>  的基础上应用一次。 在  <code>Git</code>  中，这种 操作就叫做<strong>变基（rebase）</strong>。你可以使用  <code>rebase</code>  命令将提交到某一分支上的所有修改都移至另一分支上，就好像 “重新播放” 一样。在这个例子中，你可以检出  <code>experiment</code>  分支，然后将它变基到  <code>master</code>  分支上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout experiment</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git rebase master</span><br>First, rewinding head to replay your work on top of it...<br>Applying: added staged command<br></code></pre></td></tr></table></figure><img src="rebase.png" alt="将 C4 中的修改变基到 C3 上"/><p>它的原理是首先找到这两个分支（即当前分支  <code>experiment</code> 、变基操作的目标基底分支  <code>master</code> ） 的最近共同 祖先  <code>C2</code> ，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向 目标基底  <code>C3</code> , 最后以此将之前另存为临时文件的修改依序应用。</p><p>现在回到  <code>master</code>  分支，进行一次快进合并。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout master</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge experiment</span><br></code></pre></td></tr></table></figure><img src="rebase_merge.png" alt="master 分支的快进合并"/><p>这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p><p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁 —— 例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到  <code>origin/master</code>  上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p><p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不 同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p><h3 id="更有趣的变基例子"><a class="markdownIt-Anchor" href="#更有趣的变基例子">#</a> 更有趣的变基例子</h3><p>在对两个分支进行变基时，所生成的 “重放” 并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 考虑下面的例子：</p><img src="rebase_example.png" alt="从一个主题分支里再分出一个主题分支的提交历史"/><p>假设你希望将  <code>client</code>  中的修改合并到主分支并发布，但暂时并不想合并  <code>server</code>  中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用  <code>git rebase</code>  命令的  <code>--onto</code>  选项， 选中在  <code>client</code>  分支里但不在  <code>server</code>  分支里的修改（即  <code>C8</code>  和  <code>C9</code> ），将它们在  <code>master</code>  分支上重放：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git rebase <span class="hljs-literal">--onto</span> master server client<br></code></pre></td></tr></table></figure><p>以上命令的意思是：取出  <code>client</code>  分支，找出它从  <code>server</code>  分支分歧之后的补丁， 然后把这些补丁在  <code>master</code>  分支上重放一遍，让  <code>client</code>  看起来像直接基于  <code>master</code>  修改一样。这理解起来有一点复杂，不过效果非常酷。</p><img src="rebase_example2.png" alt="截取主题分支上的另一个主题分支，然后变基到其他分支"/><p>现在可以快进合并  <code>master</code>  分支了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git checkout master<br>git merge client<br></code></pre></td></tr></table></figure><img src="rebase_example3.png" alt="快进合并 master 分支，使之包含来自 client 分支的修改"/><p>接下来你决定将  <code>server</code>  分支中的修改也整合进来。 使用  <code>git rebase</code>  命令可以直接将主题分支（即本例中的  <code>server</code> ）变基到目标分支（即  <code>master</code> ）上。这样做能省去你先切换到  <code>server</code>  分支，再对其执行变基命令的多个步骤。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git rebase master server<br></code></pre></td></tr></table></figure><img src="rebase_example4.png" alt="快进合并 master 分支，使之包含来自 client 分支的修改"/><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git checkout master<br>git merge server<br></code></pre></td></tr></table></figure><p>至此， <code>client</code>  和  <code>server</code>  分支中的修改都已经整合到主分支里了， 你可以删除这两个分支，最终提交历史会变成如下所示：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git branch <span class="hljs-literal">-d</span> client<br>git branch <span class="hljs-literal">-d</span> server<br></code></pre></td></tr></table></figure><img src="rebase_example5.png" alt="快进合并 master 分支，使之包含来自 client 分支的修改"/><h3 id="变基的风险"><a class="markdownIt-Anchor" href="#变基的风险">#</a> 变基的风险</h3><p>奇妙的变基也并非完美无缺，要用它得遵守一条准则： <strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基</strong>。</p><h1 id="git工具"><a class="markdownIt-Anchor" href="#git工具">#</a> Git 工具</h1>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis</title>
    <link href="/2024/01/28/mybatis/"/>
    <url>/2024/01/28/mybatis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="getting-started"><a class="markdownIt-Anchor" href="#getting-started">#</a> Getting Started</h1><h2 id="所需依赖"><a class="markdownIt-Anchor" href="#所需依赖">#</a> 所需依赖</h2><p><code>MyBatis</code>  依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>x.x.x<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>数据库驱动：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>x.x.x<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件">#</a> 配置文件</h2><p><code>MyBatis</code>  中有两个 <code>XML</code>  配置文件。</p><p><code>MyBatis</code>  的核心配置文件用于配置数据源等信息 ———— <code>Mybatis-config.xml</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>MyBatis</code>  映射文件用于配置 <code>sql</code>  语句 ———— <code>xxxMmapper.xml</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>[!Note]</p><p>注意，上述配置文件的名字不是固定的，但一般取为 <code>Mybatis-config.xml</code>  和 <code>xxxMmapper.xml</code> 。</p><p>放置的位置也不是固定的，但一般为 <code>resources</code>  下</p></blockquote><h2 id="建表"><a class="markdownIt-Anchor" href="#建表">#</a> 建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> t_user(<br>    id <span class="hljs-type">bigint</span> <span class="hljs-keyword">primary</span> key auto_increment comment <span class="hljs-string">&#x27;主键自增&#x27;</span>,<br>    car_num <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) comment <span class="hljs-string">&#x27;汽车编号&#x27;</span>,<br>    brand <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) comment <span class="hljs-string">&#x27;品牌&#x27;</span>,<br>    guide_price <span class="hljs-type">decimal</span> comment <span class="hljs-string">&#x27;厂家指导价&#x27;</span>,<br>    produce_time <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;生产时间&#x27;</span>,<br>    car_type <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) comment <span class="hljs-string">&#x27;汽车类型&#x27;</span><br>);<br></code></pre></td></tr></table></figure><h2 id="配置数据库"><a class="markdownIt-Anchor" href="#配置数据库">#</a> 配置数据库</h2><p>在核心配置文件中的 <code>&lt;datasource&gt;</code>  标签中的 <code>&lt;property&gt;</code>  标签，填入连接数据库的 <code>driver</code> 、 <code>url</code> 、 <code>username</code> 、 <code>password</code> 。</p><hr><p>或者在 <code>&lt;configuration&gt;</code>  中的开头填入以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>/&gt;</span> #此标签的作用是引入资源文件<br></code></pre></td></tr></table></figure><p>随后在 <code>jdbc.properties</code>  中填入：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driver</span>=<span class="hljs-string"></span><br><span class="hljs-attr">url</span>=<span class="hljs-string"></span><br><span class="hljs-attr">username</span>=<span class="hljs-string"></span><br><span class="hljs-attr">password</span>=<span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h2 id="连接核心配置文件和映射文件"><a class="markdownIt-Anchor" href="#连接核心配置文件和映射文件">#</a> 连接核心配置文件和映射文件</h2><p>当你创建好映射文件后，需要在核心配置文件申明你所创建的映射文件的位置。</p><p>在 <code>&lt;mappers&gt;</code>  标签中中填入映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>[!Note]</p><p><code>resource</code>  从项目根目录进行查询。</p></blockquote><h2 id="编写映射文件"><a class="markdownIt-Anchor" href="#编写映射文件">#</a> 编写映射文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.jhy.demo1.mapper.CarMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertCar&quot;</span>&gt;</span><br>        insert into t_car values(null,&#x27;1002&#x27;,&#x27;奔驰&#x27;,20.00,current_date(),&#x27;燃油车&#x27;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="如何连接数据库"><a class="markdownIt-Anchor" href="#如何连接数据库">#</a> 如何连接数据库？</h2><p><code>Mybatis</code>  通过 <code>SqlSession</code>  实例建立连接数据库的一次会话。通过会话，就可以操控数据库</p><p><code>SqlSession</code>  实例通过 <code>SqlSessionFactory</code>  实例创建，而 <code>SqlSessionFactory</code>  实例通过 <code>SqlSessionBuilder</code>  实例创建。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>))&#123;<br>        <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">sqlSessionFactoryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> sqlSessionFactoryBuilder.build(inputStream);<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br>        <span class="hljs-type">CarMapper</span> <span class="hljs-variable">carMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(CarMapper.class);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> carMapper.insertCar(); <span class="hljs-comment">//insert，update，delete返回值是影响的行数</span><br>        System.out.println(<span class="hljs-string">&quot;影响行数：&quot;</span> + res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li><code>Resouces</code> ： <code>Mybatis</code>  提供的获取核心配置文件的类<ul><li><code>Resources.getResourceAsStream()</code> ：将对应的配置文件封装为输入流，同样也是从项目根路径开始查找</li></ul></li><li><code>sqlSessionFactoryBuilder.build(inputStream)</code> ：通过该配置文件创建出 <code>SqlSessionFactory</code>  实例</li><li><code>sessionFactory.openSession()</code> ：生产 <code>SqlSession</code>  实例</li></ul></blockquote><h2 id="执行sql语句"><a class="markdownIt-Anchor" href="#执行sql语句">#</a> 执行 Sql 语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>))&#123;<br>        <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">sqlSessionFactoryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> sqlSessionFactoryBuilder.build(inputStream);<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> sqlSession.insert(<span class="hljs-string">&quot;insertCar&quot;</span>) <span class="hljs-comment">//insertCar为映射文件中insert块的id</span><br>        System.out.println(<span class="hljs-string">&quot;影响行数：&quot;</span> + res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!Important]</p><p>运行上述代码，如果前面配置没有出错，则你会在控制台看见输出：影响行数：1</p><p>但前往数据库并没有发现有记录的增加。</p><p>因为 <code>Mybatis</code>  本身的事务是不会自动提交的。需要显式提交</p></blockquote><p>可以使用下面的语句显式提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sqlSession.commit(); <span class="hljs-comment">//提交事务</span><br></code></pre></td></tr></table></figure><h1 id="获得输入流的几种方法"><a class="markdownIt-Anchor" href="#获得输入流的几种方法">#</a> 获得输入流的几种方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;path/to/&quot;</span>)<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStream</span>(<span class="hljs-string">&quot;path/to/&quot;</span>) <span class="hljs-comment">//自己创建输入流，需要写明完整的绝对路径或者相对路径。</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="hljs-string">&quot;path/to/&quot;</span>); <span class="hljs-comment">//Resources.getResourceAsStream()的底层实现</span><br></code></pre></td></tr></table></figure><blockquote><p>核心配置文件不一定放在项目根目录下，你可以在根目录下建个目录，也可以放在项目根目录外面</p></blockquote><h1 id="mybatis的事务管理"><a class="markdownIt-Anchor" href="#mybatis的事务管理">#</a> Mybatis 的事务管理</h1><p><code>Mybatis</code>  通过核心配置文件的 <code>&lt;transactionManager type=&quot;&quot;&gt;</code>  管理事务。</p><p><code>type</code>  可用的属性为： <code>[JDBC|MANAGED]</code> 。不区分大小写</p><ul><li><code>JDBC</code> ： <code>Mybatis</code>  自己管理事务，使用 <code>JDBC</code>  原生的事务管理器进行管理。提交时，相当于 <code>JDBC</code>  的 <code>connection.commit()</code><ul><li>底层会创建 <code>JDBCTransaction</code>  实例</li></ul></li><li><code>MANAGED</code> ： <code>Mybatis</code>  不自己管理事务，交给第三方框架，例如： <code>spring</code><ul><li>如果只有 <code>Mybatis</code>  本身，那么代表着不开启事务。</li></ul></li></ul><blockquote><p>[!Important]</p><p>JDBC 底层的事务是默认提交的。</p></blockquote><h2 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析">#</a> 源码分析</h2><p>创建 <code>JDBC</code>  事务的 <code>SqlSession</code>  实例时，会创建 <code>JDBC</code>  原生的 <code>Connection</code>  实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sessionFactory.openSession(); <span class="hljs-comment">//从这里打断点，进入openSession方法</span><br><br><span class="hljs-keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">//openSession()的方法体，注意最后一个false</span><br><span class="hljs-comment">/*进入openSessionFromDataSource()方法 一直执行至如下语句*/</span><br>tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); <span class="hljs-comment">//创建了一个事务，注意此时autoCommit为false</span><br><span class="hljs-comment">//进入newTransaction()方法</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTransaction</span>(ds, level, autoCommit, skipSetAutoCommitOnClose);<br><br><span class="hljs-comment">/*再次进入JdbcTransaction()方法，搜索openConnetion()方法，打上断点，执行至此</span><br><span class="hljs-comment">一直运行至setDesiredAutoCommit()方法并进入*/</span><br><span class="hljs-keyword">if</span> (connection.getAutoCommit() != desiredAutoCommit) &#123; <span class="hljs-comment">//connection默认为自动提交，也就是autoCommit为true</span><br>    <span class="hljs-keyword">if</span> (log.isDebugEnabled()) &#123;<br>        log.debug(<span class="hljs-string">&quot;Setting autocommit to &quot;</span> + desiredAutoCommit + <span class="hljs-string">&quot; on JDBC Connection [&quot;</span> + connection + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>connection.setAutoCommit(desiredAutoCommit); <span class="hljs-comment">//只有当autoCommit为false时才会执行，也就是将connection的自动提交关闭</span><br><br><span class="hljs-comment">//如何开启自动提交？</span><br><span class="hljs-comment">//最开始就将autoCommit设为true</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sessionFactory.openSession(<span class="hljs-literal">true</span>) <span class="hljs-comment">//表示没有事务，执行一次DML就提交一次，不建议</span><br></code></pre></td></tr></table></figure><blockquote><p>[!Note]</p><p>注意， <code>openSession()</code>  方法有三个重载：</p><p><code>public SqlSession openSession()</code> ：默认 <code>autoCommit</code>  就为 <code>false</code></p><p><code>public SqlSession openSession(boolean autoCommit)</code></p><p><code>public SqlSession openSession(ExecutorType execType)</code></p></blockquote><p>创建 <code>MANAGED</code>  事务的 <code>SqlSession</code>  实例时</p><h1 id="日志"><a class="markdownIt-Anchor" href="#日志">#</a> 日志</h1><p><code>Mybatis</code>  可用的日志框架：</p><p>SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING |</p><p><code>Mybatis</code>  本身实现了 <code>STDOUT_LOGGING</code> 。</p><p>在 <code>&lt;settings&gt;</code>  中填入如下内容启用 <code>Mybatis</code>  自身的日志：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><code>&lt;settings&gt;</code>  应该在 <code>&lt;properties&gt;</code>  标签后</p></blockquote><h1 id="增删改查"><a class="markdownIt-Anchor" href="#增删改查">#</a> 增删改查</h1><ul><li>通过 <code>#&#123;&#125;</code>  来提供传入的参数。 <code>&#123;&#125;</code>  中填入传值的参数</li></ul><p>仍然使用 [Getting Started](#Getting Started) 中使用的表，代码</p><h2 id="增"><a class="markdownIt-Anchor" href="#增">#</a> 增</h2><p>将映射语句改成如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertCar&quot;</span>&gt;</span><br>    insert into t_car values(null,#&#123;carNum&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="map"><a class="markdownIt-Anchor" href="#map">#</a> Map</h3><p>通过 <code>map</code>  传参，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span>&#123;<br>    sqlSession = SqlSessionUtil.getSqlSession();<br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-literal">null</span>);<br>    map.put(<span class="hljs-string">&quot;carNum&quot;</span>,<span class="hljs-string">&quot;1003&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;brand&quot;</span>,<span class="hljs-string">&quot;大众&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;guidePrice&quot;</span>,<span class="hljs-number">10.00</span>);<br>    map.put(<span class="hljs-string">&quot;produceTime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    map.put(<span class="hljs-string">&quot;carType&quot;</span>,<span class="hljs-string">&quot;老爷车&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;影响: &quot;</span> + sqlSession.insert(<span class="hljs-string">&quot;insertCar&quot;</span>, map));<br>    sqlSession.commit();<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    <span class="hljs-keyword">if</span>(sqlSession != <span class="hljs-literal">null</span>)&#123;<br>        sqlSession.rollback();<br>        sqlSession.close();<br>    &#125;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实体类"><a class="markdownIt-Anchor" href="#实体类">#</a> 实体类</h3><p>创建一个 <code>Car</code>  实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    Integer id;<br>    String carNum;<br>    String brand;<br>    BigDecimal guidPrice;<br>    Date produceTime;<br>    String carType;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>@Data 为 <code>lombok</code>  依赖的注解，用于简化实体类开发，自动创建 <code>getter</code> 、 <code>setter</code>  方法以及重写 <code>toString</code>  方法</p><p>@AllArgsConstructor 则是创建全参数的构造器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span>&#123;<br>    sqlSession = SqlSessionUtil.getSqlSession();<br>    <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;1005&quot;</span>,<span class="hljs-string">&quot;红旗&quot;</span>,BigDecimal.valueOf(<span class="hljs-number">20.00</span>),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<span class="hljs-string">&quot;燃油车&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;影响: &quot;</span> + sqlSession.insert(<span class="hljs-string">&quot;insertCar&quot;</span>, car));<br>    sqlSession.commit();<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    <span class="hljs-keyword">if</span>(sqlSession != <span class="hljs-literal">null</span>)&#123;<br>        sqlSession.rollback();<br>sqlSession.close();<br>    &#125;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!Important]</p><p>当插入的是 <code>map</code>  时， <code>Mybatis</code>  底层会使用 <code>map</code>  的 <code>get</code>  方法获取参数值，参数的名字为对于的键名</p><p>当插入的是实体类时， <code>Mybatis</code>  底层会使用 <code>getter</code>  方法获取参数值，参数的名字是 <code>getter方法</code> 去掉 <code>get</code>  后首字母小写的得到的，例如：getUserName ()–&gt; userName。没有 <code>getter</code>  方法时会报错</p></blockquote><h2 id="删"><a class="markdownIt-Anchor" href="#删">#</a> 删</h2><p>根据 <code>Id</code>  删除：</p><p>修改 <code>CarMapper.xml</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;delCar&quot;</span>&gt;</span><br>    delete from t_car where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span>&#123;<br>    sqlSession = SqlSessionUtil.getSqlSession();<br>    System.out.println(<span class="hljs-string">&quot;影响: &quot;</span> + sqlSession.getMapper(CarMapper.class).delCar(<span class="hljs-number">6</span>));<br>    sqlSession.commit();<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    <span class="hljs-keyword">if</span>(sqlSession != <span class="hljs-literal">null</span>)&#123;<br>        sqlSession.rollback();<br>        sqlSession.close();<br>    &#125;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="改"><a class="markdownIt-Anchor" href="#改">#</a> 改</h2><p>根据 <code>Id</code>  改</p><p>修改 <code>CarMapper.xml</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateCar&quot;</span>&gt;</span><br>    update t_car set car_num=#&#123;carNum&#125;, brand=#&#123;brand&#125;, guide_price=#&#123;guidePrice&#125;,produce_time=#&#123;produceTime&#125;, car_type=#&#123;carType&#125; where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span>&#123;<br>    sqlSession = SqlSessionUtil.getSqlSession();<br>    <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;1110&quot;</span>,<span class="hljs-string">&quot;丰田&quot;</span>,BigDecimal.valueOf(<span class="hljs-number">30.00</span>),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<span class="hljs-string">&quot;新能源车&quot;</span>);<br>    System.out.println(sqlSession.update(<span class="hljs-string">&quot;updateCar&quot;</span>, car));<br>    sqlSession.commit();<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    <span class="hljs-keyword">if</span>(sqlSession != <span class="hljs-literal">null</span>)&#123;<br>        sqlSession.rollback();<br>        sqlSession.close();<br>    &#125;<br>    e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="查"><a class="markdownIt-Anchor" href="#查">#</a> 查</h2><p>首先，请在核心配置文件中添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="按id查"><a class="markdownIt-Anchor" href="#按id查">#</a> 按 id 查</h3><p>修改 <code>CarMapper.xml</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getCarById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.jhy.mybatis.entity.Car&quot;</span>&gt;</span><br>    select * from t_car where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span>&#123;<br>    sqlSession = SqlSessionUtil.getSqlSession();<br>    System.out.println((Car)sqlSession.selectOne(<span class="hljs-string">&quot;getCarById&quot;</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">//查出来是Object，需要强转</span><br>    sqlSession.commit();<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    <span class="hljs-keyword">if</span>(sqlSession != <span class="hljs-literal">null</span>)&#123;<br>        sqlSession.rollback();<br>        sqlSession.close();<br>    &#125;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查全部"><a class="markdownIt-Anchor" href="#查全部">#</a> 查全部</h3><p>修改 <code>CarMapper.xml</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getCars&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.jhy.mybatis.entity.Car&quot;</span>&gt;</span><br>select * from t_car;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span>&#123;<br>    sqlSession = SqlSessionUtil.getSqlSession();<br>    System.out.println(sqlSession.selectList(<span class="hljs-string">&quot;com.jhy.mybatis.mapper.CarMapper.getCars&quot;</span>, CarMapper.class));<br>    System.out.println(list);<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    <span class="hljs-keyword">if</span>(sqlSession != <span class="hljs-literal">null</span>)&#123;<br>        sqlSession.rollback();<br>        sqlSession.close();<br>    &#125;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!Important]</p><ul><li><p><code>Mybatis</code>  查出来后是一个数据集，要进行映射，必须告诉 <code>Mybatis</code>  如何进行映射。即在 <code>&lt;select&gt;</code>  中声明 <code>resultType</code>  或者 <code>resultMap</code> 。</p></li><li><p><code>resultType</code> ：将结果集和一个类型映射，一般是某个类的全类名。或者是别名</p><ul><li><p>通过核心配置文件中，添加 <code>&lt;typeAliases&gt;&lt;package name=&quot;/path/to/package&quot;/&gt;&lt;/typeAliases&gt;</code> ，来为改包下的所有类添加别名，默认为类名小写</p></li><li><p>或者在想要设置别名的类加上 <code>@Alias(alias)</code> ，来设置别名</p></li><li><p><code>@Alias</code>  会覆盖核心配置文件设置的别名</p></li><li><p><code>resultMap</code> ：自定义映射。见<a href="##resultMap"> resultMap</a></p></li></ul></li><li><p><code>&lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt;</code> ：开启下划线命名法和驼峰命名法的映射</p></li><li><p>光使用 <code>resultType</code>  还不行，因为数据库一般是下划线命名法， <code>java</code>  是驼峰命名法， <code>Mybatis</code>  不知道将字段映射至哪个属性上。开启这个设置后，将会使驼峰命名的属性和下划线命名的字段映射</p></li><li><p>若属性和字段相同 <code>Mybatis</code>  会自动映射，因此不用开启下划线命名法和驼峰命名法的映射</p></li><li><p>使用字段别名也可以进行映射</p></li></ul></blockquote><blockquote><p>[!Important]</p><p><code>namespace</code> ：命名空间。就像 <code>c++</code>  的命名空间和 <code>java</code>  的包一样，为了区分出映射语句 <code>id</code>  的所处的范围。防止重名。</p><p>完整的引用应该是： <code>namepace.id</code> 。当没有 <code>id</code>  重名是，仅仅使用 <code>id</code>  就能区分，有 <code>id</code>  重名时，必须使用完整的引用</p></blockquote><h1 id="核心配置文件详解"><a class="markdownIt-Anchor" href="#核心配置文件详解">#</a> 核心配置文件详解</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--properties：用于设置属性，或者引入properties文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span>  <span class="hljs-comment">&lt;!--通过$&#123;name&#125;即可获取value的值--&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--properties resource=&quot;/path/to/properties&quot;/--&gt;</span> <span class="hljs-comment">&lt;!--用于引入properties文件，同样可以用$&#123;name&#125;的方式获取value的值--&gt;</span><br><span class="hljs-comment">&lt;!--environments包裹enviroment标签， defualt代表默认的环境id，创建SqlSessionFactory实例时，未指明环境使用的默认环境--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!--环境，一般对于着一个数据库，一数据库对应着一个SqlSessionFactory，id为该环境的唯一标识--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span> <br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">transactionManager：申明使用哪种事务管理。</span><br><span class="hljs-comment">--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">dataSource：数据源==连接池，通过数据源获取提供connection对象。DataSource是JDK提供的规范，有很多实现</span><br><span class="hljs-comment">type：使用声明方式获取Connection实例 [POOLED|UNPOOLED|JNDI]</span><br><span class="hljs-comment">UNPOOLED：不适应数据库连接池技术，每一次连接都会创建新的Connection实例</span><br><span class="hljs-comment">POOLED：使用Mybatis自己实现的数据库连接池</span><br><span class="hljs-comment">JNDI：使用第三方的数据库连接池</span><br><span class="hljs-comment">--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    ... <span class="hljs-comment">&lt;!--可以创建多个环境--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="mybatis的核心类"><a class="markdownIt-Anchor" href="#mybatis的核心类">#</a> Mybatis 的核心类</h1><h2 id="sqlsessionfactorybuilder"><a class="markdownIt-Anchor" href="#sqlsessionfactorybuilder">#</a> SqlSessionFactoryBuilder</h2><p>这个类可以被实例化、使用和丢弃，一旦创建了 <code>SqlSessionFactory</code> ，就不再需要它了。 因此 <code>SqlSessionFactoryBuilder</code>  实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 <code>SqlSessionFactoryBuilder</code>  来创建多个 <code>SqlSessionFactory</code>  实例，但最好还是不要一直保留着它，以保证所有的 <code>XML</code>  解析资源可以被释放给更重要的事情。</p><h2 id="sqlsessionfactory"><a class="markdownIt-Anchor" href="#sqlsessionfactory">#</a> SqlSessionFactory</h2><p><code>SqlSessionFactory</code>  一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 <code>SqlSessionFactory</code>  的最佳实践是在应用运行期间不要重复创建多次，多次重建 <code>SqlSessionFactory</code>  被视为一种代码<strong>坏习惯</strong>。因此 <code>SqlSessionFactory</code>  的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><h2 id="sqlsession"><a class="markdownIt-Anchor" href="#sqlsession">#</a> SqlSession</h2><p>每个线程都应该有它自己的 <code>SqlSession</code>  实例。 <code>SqlSession</code>  的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 <code>SqlSession </code> 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 <code>SqlSession</code>  实例的引用放在任何类型的托管作用域中，比如 <code>Servlet</code>  框架中的 <code>HttpSession</code> 。如果你现在正在使用一种 <code>Web</code>  框架，考虑将 <code>SqlSession</code>  放在一个和 HTTP 请求相似的作用域中。换句话说，每次收到 HTTP 请求，就可以打开一个 <code>SqlSession</code> ，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 <code>finally</code>  块中。</p><h1 id="mybatis代理"><a class="markdownIt-Anchor" href="#mybatis代理">#</a> Mybatis 代理</h1><p>如果，你使用之前所述的方法在 <code>web</code>  钟进行查询，是否发现了， <code>dao</code>  层书写的代码大同小异。几乎一模一样。有没有简单的方法执行 <code>sql</code>  语句？</p><blockquote><p>答案是有。 <code>Mybatis</code>  底层封装了 <code>javassist</code>  进行动态代理，使用者可以只书写一个接口， <code>Mybatis</code>  可以为这个接口创建一个动态代理类。这样我们并不用自己区写一个访问数据库的方法。</p></blockquote><p><code>Mybatis</code> t 通过 <code>javassist</code>  实现接口和其中的方法。那么问题来了， <code>Mybatis</code>  底层如何获得的 <code>sql</code>  语句？</p><blockquote><p><code>Mybatis</code>  可以通过映射文件的标签中的 <code>id</code>  获得其中的 <code>sql</code>  语句</p></blockquote><p>既然可以通过 <code>id</code>  获取 <code>sql</code>  语句，那么 <code>Mybatis</code>  如何知道使用者书写的 <code>id</code>  和插入的对应方法？</p><blockquote><p><code>Mybatis</code>  规定：如果使用动态代理的方式执行 <code>sql</code>  语句，那么映射文件中的 <code>namespace</code>  应该是对应接口的完全限定类名，映射语句的 <code>id</code> ，应该是对应方法的方法名。</p><p>而如果你不适应动态代理的方式执行 <code>sql</code>  语句，则没有上述规定。</p></blockquote><p><code>Mybatis</code>  通过以下方式获得动态代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sqlsession.getMapper(xxx.class) <span class="hljs-comment">//这样将获得xxx接口的代理类，这样就可以通过代理类的方法执行sql</span><br></code></pre></td></tr></table></figure><h1 id="小技巧"><a class="markdownIt-Anchor" href="#小技巧">#</a> 小技巧</h1><h2 id="和的区别"><a class="markdownIt-Anchor" href="#和的区别">#</a> #{} 和 ${} 的区别</h2><p>实际上， <code>Mybatis</code>  提供 <code>#&#123;&#125;</code>  和 <code>$&#123;&#125;</code>  来进行传参。 <code>&#123;&#125;</code>  中填入传值的参数</p><ul><li><code>#&#123;&#125;</code> ：底层使用 <code>PreparedStatement</code> ，会先进行 <code>sql</code>  的编译，相当 <code>?</code>  占位符，对字符串来说会自动添加引号。</li><li><code>$&#123;&#125;</code> ：底层使用 <code>Staement</code> ，会先进行字符串的拼接，对字符串来说就是没有引号。无法防止 <code>sql</code>  注入，只有在字符串拼接的情况下才使用。</li></ul><h2 id="typealiases"><a class="markdownIt-Anchor" href="#typealiases">#</a> typeAliases</h2><p><code>typeAliases</code>  为核心配置文件的标签。为 <code>resultType</code>  提供别名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;/reference/to/class&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;alias&quot;</span>/&gt;</span> #type为起别名类的完全限定名，alias为别名<br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;/reference/to/class&quot;</span>/&gt;</span> #省略alias，将会使用类的默认简名————去掉包名，且别名不分大小写<br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;/path/to/package&quot;</span>/&gt;</span> #为该包下的所有类起别名，同样使用类的默认简名<br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><code>Mybatis</code>  为常用的类型提供了别名。参考文档：<a href="https://mybatis.net.cn/configuration.html#typeAliases">MyBatis 内置别名</a></p></blockquote><h2 id="mappers标签的细节"><a class="markdownIt-Anchor" href="#mappers标签的细节">#</a> mappers 标签的细节</h2><p><code>mappers</code>  为核心配置文件的标签。包含映射文件的路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;/path/to/xml&quot;</span>/&gt;</span> #从项目根路径开始找映射文件<br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file:///absolute/path/to/xml&quot;</span>/&gt;</span> #定位计算机本地的映射文件<br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;reference.to.class&quot;</span>/&gt;</span> #通过接口名找到的映射文件，Mybatis会从reference/to/class.xml找映射文件<br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;reference.to.package&quot;</span>/&gt;</span> #找到该包下的映射文件<br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>[!Important]</p><p>使用第 3 和第 4 种方式，必须保证：</p><ul><li>映射文件和接口同名</li><li>映射文件和接口处同一目录下</li></ul></blockquote><h2 id="插入数据时自动获取生成的主键"><a class="markdownIt-Anchor" href="#插入数据时自动获取生成的主键">#</a> 插入数据时自动获取生成的主键</h2><p>在 <code>&lt;insert&gt;</code>  标签中开启 <code>useGeneratedKey</code> ，表明开启自动获取生成的主键，同时设置 <code>keyProperty</code> ，实体类的哪个属性作为返回的主键</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">useGeneratedKey</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>当插入完成后， <code>Mybatis</code>  会自动给实体类的这个参数赋值为生成的主键。</p><h1 id="参数"><a class="markdownIt-Anchor" href="#参数">#</a> 参数</h1><p><code>Mybatis</code>  简单参数：</p><ul><li><p>byte short int long float double</p></li><li><p>Byte Short Integer Long Float Double</p></li><li><p>String</p></li><li><p>java.util.Date</p></li><li><p>java.sql.Date</p></li></ul><h2 id="单个简单参数"><a class="markdownIt-Anchor" href="#单个简单参数">#</a> 单个简单参数</h2><p>使用单个简单参数时， <code>#&#123;&#125;</code>  和 <code>$&#123;&#125;</code>  中的 <code>&#123;&#125;</code>  的参数可以随便写。对于 <code>#&#123;&#125;</code> ， <code>Mybatis</code>  底层仍然使用 <code>preparedStatement.setxxx()</code>  方法向占位符赋值。 <code>Mybatis</code>  底层会猜出简单参数的类型。</p><blockquote><p>[!Note]</p><p>实际上，在每个映射块中可以使用 <code>parameterType</code>  属性来指明参数的类型，但可以不写， <code>Mybatis</code>  可以猜出来。</p></blockquote><h2 id="map集合参数"><a class="markdownIt-Anchor" href="#map集合参数">#</a> Map 集合参数</h2><p><code>Mybatis</code>  底层会使用 <code>map</code>  的 <code>get</code>  方法获取参数值，， <code>#&#123;&#125;</code>  和 <code>$&#123;&#125;</code>  中的 <code>&#123;&#125;</code>  的参数的名字为对应的键名</p><h2 id="实体类参数"><a class="markdownIt-Anchor" href="#实体类参数">#</a> 实体类参数</h2><p><code>Mybatis</code>  底层会使用 <code>getter</code>  方法获取参数值，， <code>#&#123;&#125;</code>  和 <code>$&#123;&#125;</code>  中的 <code>&#123;&#125;</code>  的参数的名字是 <code>getter方法</code> 去掉 <code>get</code>  后首字母小写的得到的，例如：getUserName ()–&gt; userName。没有 <code>getter</code>  方法时会报错</p><h2 id="多参数"><a class="markdownIt-Anchor" href="#多参数">#</a> 多参数</h2><p><code>Mybatis</code>  底层会自动创建一个 <code>map</code>  集合，以以下方式存放：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">map.put(<span class="hljs-string">&quot;arg0&quot;</span>,param1)<br>map.put(<span class="hljs-string">&quot;arg1&quot;</span>,param2)<br>...<br>map.put(<span class="hljs-string">&quot;param1&quot;</span>,param0)<br>map.put(<span class="hljs-string">&quot;param2&quot;</span>,param1)<br></code></pre></td></tr></table></figure><p>因此可以使用以下方式引用参数值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">#&#123;arg0&#125;,#&#123;agr1&#125;...<br>$&#123;arg0&#125;,$&#123;arg1&#125;...<br>#&#123;param1&#125;,#&#123;param2&#125;...<br>$&#123;param1&#125;,$&#123;param2&#125;...<br></code></pre></td></tr></table></figure><h3 id="param注解"><a class="markdownIt-Anchor" href="#param注解">#</a> @Param 注解</h3><p>可以自己指定 <code>map</code>  中的 <code>key</code>  是什么，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> xxx <span class="hljs-title function_">getXXX</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;yy&quot;)</span>xx yy)</span><br></code></pre></td></tr></table></figure><blockquote><p>[!Note]</p><p>此方法会让前缀为 <code>arg</code>  的键失效，但前缀为 <code>param</code>  的键依然存在</p></blockquote><h2 id="数组或者list集合参数"><a class="markdownIt-Anchor" href="#数组或者list集合参数">#</a> 数组或者 List 集合参数</h2><p>此参数要配合 <code>foreach</code>  标签使用。 <code>foreach</code>  标签见<a href="##foreach"> foreach</a></p><h1 id="查询返回"><a class="markdownIt-Anchor" href="#查询返回">#</a> 查询返回</h1><h2 id="返回单个"><a class="markdownIt-Anchor" href="#返回单个">#</a> 返回单个</h2><h3 id="返回单个对象实例"><a class="markdownIt-Anchor" href="#返回单个对象实例">#</a> 返回单个对象实例</h3><h4 id="返回实体类"><a class="markdownIt-Anchor" href="#返回实体类">#</a> 返回实体类</h4><p>在映射块中表面 <code>resultType</code>  的类型， <code>Mybatis</code>  将自动进行结果集映射。</p><blockquote><p>若返回条数是多个，使用实体类接受会产生 <code>TooManyResultException</code>  错误</p></blockquote><h4 id="返回没有适合的实体类的结果集"><a class="markdownIt-Anchor" href="#返回没有适合的实体类的结果集">#</a> 返回没有适合的实体类的结果集</h4><p>返回的结果集没有适合的实体类接受，则可以使用 <code>map&lt;String, Object&gt;</code>  进行接受，同时指定 <code>resultType</code>  为 <code>map</code></p><h3 id="返回单个简单类型"><a class="markdownIt-Anchor" href="#返回单个简单类型">#</a> 返回单个简单类型</h3><p>用对应的简单类型接受即可。</p><h2 id="返回多个"><a class="markdownIt-Anchor" href="#返回多个">#</a> 返回多个</h2><h3 id="返回多个对象实例"><a class="markdownIt-Anchor" href="#返回多个对象实例">#</a> 返回多个对象实例</h3><h4 id="返回实体类-2"><a class="markdownIt-Anchor" href="#返回实体类-2">#</a> 返回实体类</h4><p>返回的结果集有多个。用 <code>List&lt;eneity&gt;</code>  接受。在映射块中表明 <code>resultType</code>  的类型， <code>Mybatis</code>  将自动进行结果集映射。同样的，此方法也可以接受返回单个结果集的结果</p><h4 id="返回没有适合的实体类的结果集-2"><a class="markdownIt-Anchor" href="#返回没有适合的实体类的结果集-2">#</a> 返回没有适合的实体类的结果集</h4><p>返回的结果集没有适合的实体类接受，则可以使用 <code>List&lt;map&lt;String, Object&gt;&gt;</code>  进行接受，同时指定 <code>resultType</code>  为 <code>map</code></p><h3 id="返回多个简单类型"><a class="markdownIt-Anchor" href="#返回多个简单类型">#</a> 返回多个简单类型</h3><p>用对应的简单类型 <code>List</code>  集合接受即可。</p><h2 id="大map"><a class="markdownIt-Anchor" href="#大map">#</a> 大 map</h2><p>使用 <code>map&lt;key, map&lt;String, Object&gt;&gt;</code>  的方式进行映射。区别于简单的 <code>map</code>  集合映射，该方法支持通过主键的方式引用结果集。</p><p>其中 <code>key</code>  是主键的类型， <code>map&lt;String, Object&gt;</code>  是主键对应的 <code>map</code>  集合。作为 <code>key</code>  的字段需通过 <code>@MapKey(&quot;&quot;)</code>  进行声明。同样的指定 <code>resultType</code>  为 <code>map</code></p><h2 id="resultmap"><a class="markdownIt-Anchor" href="#resultmap">#</a> resultMap</h2><p>自定义结果集映射。</p><p>查询结果集的字段和实体类对不上的解决方案：</p><ul><li>通过 <code>as</code>  起别名</li><li><strong>使用 <code>resultMap</code> </strong></li><li>使用下划线驼峰映射</li></ul><p>如下形式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--id为resultMap的唯一标识，type为映射的实体类--&gt;</span><br><span class="hljs-comment">&lt;!--property为实体类的属性名，column为字段名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--id标签为主键的映射，不是必须的，但配上会让Mybatis提高效率--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--result标签为主键的映射--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>  <span class="hljs-comment">&lt;!--resultMap为上面定义的resultMap的id--&gt;</span><br></code></pre></td></tr></table></figure><h1 id="动态sql"><a class="markdownIt-Anchor" href="#动态sql">#</a> 动态 SQL</h1><h2 id="if标签"><a class="markdownIt-Anchor" href="#if标签">#</a> if 标签</h2><p>相当于 if 语句，条件成立则执行，如下形式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;xx != null and xx != &#x27;&#x27;&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--test中写判断条件--&gt;</span><br>...<span class="hljs-comment">&lt;!--写sql分句--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>[!Important]</p><ol><li><code>if</code>  标签中 <code>test</code>  属性是必须的。</li><li><code>if</code>  标签中 <code>test</code>  属性的值是 <code>false</code>  或者 <code>true</code> 。 如果 <code>test</code>  是 <code>true</code> ，则 <code>if</code>  标签中的 <code>sql</code>  语句就会拼接。反之，则不会拼接。</li><li><code>test</code>  属性中可以使用的是:</li></ol><ul><li>当使用了 <code>@Param</code>  主解，那么 <code>test</code>  中要出现的是 <code>Param</code>  注解指定的参数名。 <code>@Param(&quot;brand&quot;)</code> ，那么这里只能使用 <code>brand</code></li><li>当没有使用 <code>@Param</code>  注解，那么 <code>test</code>  中要出现的是:  <code>param1</code>   <code>param2</code>   <code>param3</code> …  <code>arg0</code>   <code>arg1``arg2</code> …</li><li>当使用了实体类，那么 test 中出现的是实体类的属性名。</li><li>在 mybatis 的动态 SQL 当中，不能使用 &amp;&amp;，只能使用 and</li></ul></blockquote><blockquote><p>当出现多个 <code>if</code>  时，可能会出现 <code>and</code>  多了或者少了的语法错误</p></blockquote><h2 id="where标签"><a class="markdownIt-Anchor" href="#where标签">#</a> where 标签</h2><p><code>where</code>  标签的作用：让 where 子句更加动态智能，且会动态添加 <code>where</code>  关键字</p><ul><li>所有条件都为空时， <code>where</code>  标签保证不会生成 <code>where</code>  子句</li><li>自动去除某些条件 **<mark> 前面</mark> ** 多余的 <code>and</code>  或 <code>or</code> 。</li></ul><h2 id="trim标签"><a class="markdownIt-Anchor" href="#trim标签">#</a> trim 标签</h2><p>比 <code>where</code>  更加智能，包含 4 个属性，如下形式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">subfix</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">subfixOverrides</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">prefix：在trim标签前动态添加前缀，所有条件都为空，则不会添加。prefix=&quot;where&quot;，在整个标签前动态添加where</span><br><span class="hljs-comment">subfix：添加后缀</span><br><span class="hljs-comment">prefixOverrides：删除前缀</span><br><span class="hljs-comment">subfixOverrides：删除trim标签的后缀。subfixOverrides=&quot;and|or&quot; |代表或者，在trim标签的末尾删除and或者or</span><br><span class="hljs-comment">--&gt;</span><br>...<span class="hljs-comment">&lt;!--写sql分句--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="set"><a class="markdownIt-Anchor" href="#set">#</a> set</h2><p>主要使用在 <code>update</code>  语句当中，用来同态生成 <code>set</code>  关键字，同时去掉最后多余的逗号。比如我们只更新提交的不为空的字段，如果提交的数据是空或者 <code>””</code> ，那么这个字段我们将不更新。</p><p>如下形式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">update xxx <br><span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>...<span class="hljs-comment">&lt;!--写sql分句--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>...<span class="hljs-comment">&lt;!--写sql分句--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>...<span class="hljs-comment">&lt;!--写sql分句--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="choose-when-otherwise"><a class="markdownIt-Anchor" href="#choose-when-otherwise">#</a> choose、when、otherwise</h2><p>相当于 <code>switch-case-default</code>  的选择流程控制。形式如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>...<span class="hljs-comment">&lt;!--写sql分句--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>...<span class="hljs-comment">&lt;!--写sql分句--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>...<span class="hljs-comment">&lt;!--写sql分句--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>    ...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span>...<span class="hljs-comment">&lt;!--写sql分句--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="foreach"><a class="markdownIt-Anchor" href="#foreach">#</a> foreach</h2><p>相当于 <code>java</code>  的 <code>foreach</code>  循环，形式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">collection: 指定数组或者集合</span><br><span class="hljs-comment">item：代表数组或集合中的元素</span><br><span class="hljs-comment">separator：分割符。每次循环之间的分隔符</span><br><span class="hljs-comment">open：foreach拼接的sql语句以什么开始</span><br><span class="hljs-comment">close：foreach拼接的sql语句以什么结束</span><br><span class="hljs-comment">--&gt;</span><br>...<span class="hljs-comment">&lt;!--写sql分句--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="sql-include"><a class="markdownIt-Anchor" href="#sql-include">#</a> sql、include</h2><p>形式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--声明sql片段--&gt;</span><br>...<span class="hljs-comment">&lt;!--写sql分句--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span> <br><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span> <span class="hljs-comment">&lt;!--引入sql片段--&gt;</span><br></code></pre></td></tr></table></figure><h1 id="高级映射"><a class="markdownIt-Anchor" href="#高级映射">#</a> 高级映射</h1><p>通过 <code>resultMap</code>  能支持多表之间的联表查询，下面介绍一对一、一对多、多对多的关系</p><h2 id="一对一"><a class="markdownIt-Anchor" href="#一对一">#</a> 一对一</h2><p>以国家表和首都表为例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> t_country(<br>    id <span class="hljs-type">bigint</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    country_name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>    capital_id <span class="hljs-type">bigint</span><br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> t_capital(<br>    id <span class="hljs-type">bigint</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    capital_name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>    population <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>)<br></code></pre></td></tr></table></figure><blockquote><p>一个国家对应一个首都</p></blockquote><p>实体类如下设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Country</span> &#123; <span class="hljs-comment">//国家</span><br>    Long id;<br>    String countryName;<br>    Capital capital;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Capital</span> &#123; <span class="hljs-comment">//首都</span><br>    Long id;<br>    String capitalName;<br>    String population;<br>    Country country;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查询一个国家及其首都"><a class="markdownIt-Anchor" href="#查询一个国家及其首都">#</a> 查询一个国家及其首都</h3><p>以国家表为主表，首都标为副表。</p><h4 id="级联查询"><a class="markdownIt-Anchor" href="#级联查询">#</a> 级联查询</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countryCascade&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;capital.id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;capital_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;countryName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;country_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;capital.capitalName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;capital_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;capital.population&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;population&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getCountryCascade&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;countryCascade&quot;</span>&gt;</span><br>    select * from  t_country join t_capital on t_country.capital_id = t_capital.id where t_country.id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="association"><a class="markdownIt-Anchor" href="#association">#</a> association</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countryAssociation&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;countryName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;country_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;capital&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;capital&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;capital_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;capitalName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;capital_name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;population&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;population&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getCountryAssociation&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;countryAssociation&quot;</span>&gt;</span><br>    select * from  t_country join t_capital on t_country.capital_id = t_capital.id where t_country.id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="分步查询"><a class="markdownIt-Anchor" href="#分步查询">#</a> 分步查询</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countryStep&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;countryName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;country_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;capital&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.jhy.advanced.mapper.CapitalMapper.getCapital&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;capital&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;capital_id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getCountryStep&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;countryStep&quot;</span>&gt;</span><br>    select * from t_country where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--CapitalMapper.xml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.jhy.advanced.mapper.CapitalMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getCapitalStep&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;capital&quot;</span>&gt;</span><br>        select * from t_capital where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>优点：降低联表时的性能损耗；支持懒加载</p><h3 id="查询一个首都及其所属国家"><a class="markdownIt-Anchor" href="#查询一个首都及其所属国家">#</a> 查询一个首都及其所属国家</h3><p>以首都表为主表，国家表为从表。其余与<strong>查询一个国家及其首都</strong>一样。</p><h2 id="一对多"><a class="markdownIt-Anchor" href="#一对多">#</a> 一对多</h2><p>以学生表和班级表为例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> t_clazz<br>(<br>    c_id   <span class="hljs-type">bigint</span> auto_increment <span class="hljs-keyword">primary</span> key,<br>    c_name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">null</span><br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> t_student<br>(<br>    s_id     <span class="hljs-type">bigint</span> auto_increment <span class="hljs-keyword">primary</span> key,<br>    s_name   text,<br>    c_id   <span class="hljs-type">bigint</span>,<br>);<br></code></pre></td></tr></table></figure><blockquote><p>一个班级包含多个学生。一个学生属于一个班级</p></blockquote><p>则实体类应该设计如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Clazz</span> &#123; <span class="hljs-comment">//班级</span><br>    <span class="hljs-type">int</span> cId;<br>    String cName;<br>    List&lt;Student&gt; students; <span class="hljs-comment">//多个学生</span><br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123; <span class="hljs-comment">//学生</span><br>    <span class="hljs-type">int</span> sId;<br>    String sName;<br>    Clazz clazz; <span class="hljs-comment">//从属一个班级</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查询一个班级及其包含的学生"><a class="markdownIt-Anchor" href="#查询一个班级及其包含的学生">#</a> 查询一个班级及其包含的学生</h3><h4 id="collection"><a class="markdownIt-Anchor" href="#collection">#</a> collection</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clazzCollection&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Clazz&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;cId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;c_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;cName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;c_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;s_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;s_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getClazzCollection&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;clazzCollection&quot;</span>&gt;</span><br>    select * from t_clazz natural join t_student where t_clazz.c_id = #&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="分步查询-2"><a class="markdownIt-Anchor" href="#分步查询-2">#</a> 分步查询</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clazzStep&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Clazz&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;cId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;c_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;cName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;c_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.jhy.advanced.mapper.StudentMapper.getClazzStepTwo&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;c_id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getClazzStepOne&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;clazzStep&quot;</span>&gt;</span><br>    select * from t_clazz where t_clazz.c_id = #&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--StudentMapper.xml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.jhy.advanced.mapper.StudentMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getClazzStepTwo&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>        select * from t_student where c_id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="查询一个学生及其所属的班级"><a class="markdownIt-Anchor" href="#查询一个学生及其所属的班级">#</a> 查询一个学生及其所属的班级</h3><h4 id="级联查询-2"><a class="markdownIt-Anchor" href="#级联查询-2">#</a> 级联查询</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentCacade&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;s_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;s_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;clazz.cName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;c_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;clazz.cId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;c_id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentCascade&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentCacade&quot;</span>&gt;</span><br>    select * from t_student natural join t_clazz where s_id=#&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="association-2"><a class="markdownIt-Anchor" href="#association-2">#</a> association</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentAssociation&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;s_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;s_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;clazz&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;clazz&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;cName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;c_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;cId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;c_id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentAssociation&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentAssociation&quot;</span>&gt;</span><br>    select * from t_student natural join t_clazz where s_id=#&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="分步查询-3"><a class="markdownIt-Anchor" href="#分步查询-3">#</a> 分步查询</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentStep&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;s_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;s_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;clazz&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.jhy.advanced.mapper.ClazzMapper.getStudentStepTwo&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;c_id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentStepOne&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentStep&quot;</span>&gt;</span><br>    select * from t_student where s_id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--ClazzMapper.xml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.jhy.advanced.mapper.ClazzMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getClazzStepOne&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;clazzStep&quot;</span>&gt;</span><br>        select * from t_clazz where t_clazz.c_id = #&#123;id&#125;;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="多对多"><a class="markdownIt-Anchor" href="#多对多">#</a> 多对多</h2><p>以用户表、文章表，评论表为例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> t_user( <br>    u_id <span class="hljs-type">bigint</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    user_name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> t_paper(<br>    p_id <span class="hljs-type">bigint</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    paper_name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> t_review( <span class="hljs-comment">-- 多对多关系的中间表</span><br>    id <span class="hljs-type">bigint</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    rev_content text,<br>    user_id <span class="hljs-type">bigint</span>,<br>    paper_id <span class="hljs-type">bigint</span><br>)<br></code></pre></td></tr></table></figure><blockquote><p>一个用户能评论多个文章，一个文章能被多个用户评论。</p></blockquote><p>实体类如下设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Paper</span> &#123; <span class="hljs-comment">//文章</span><br>    Long id;<br>    String paperName;<br>    List&lt;Review&gt; reviews;<br>    List&lt;User&gt; users;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123; <span class="hljs-comment">//用户</span><br>    Long id;<br>    String userName;<br>    List&lt;Review&gt; reviews;<br>    List&lt;Paper&gt; papers;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Review</span> &#123; <span class="hljs-comment">//评论</span><br>    Long id;<br>    Long userId;<br>    Long paperId;<br>    String revContent;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="查询用户及其所评论的文章和评论内容"><a class="markdownIt-Anchor" href="#查询用户及其所评论的文章和评论内容">#</a> 查询用户及其所评论的文章和评论内容</h3><h4 id="collection-2"><a class="markdownIt-Anchor" href="#collection-2">#</a> collection</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userCollection&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;u_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;papers&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;paper&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;p_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;paperName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;paper_name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;reviews&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;review&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;paperId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;paper_id&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;revContent&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rev_content&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserReview&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userCollection&quot;</span>&gt;</span><br>    select * from t_user join t_review join t_paper on u_id=t_review.user_id and t_review.paper_id = p_id where user_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="查询文章及其评论的用户的和评论内容"><a class="markdownIt-Anchor" href="#查询文章及其评论的用户的和评论内容">#</a> 查询文章及其评论的用户的和评论内容</h3><p>以文章表为主表，用户表为从表。其余与<strong>查询用户及其所评论的文章和评论内容</strong>一样。</p><h1 id="缓存"><a class="markdownIt-Anchor" href="#缓存">#</a> 缓存</h1><h2 id="一级缓存"><a class="markdownIt-Anchor" href="#一级缓存">#</a> 一级缓存</h2><p>由 <code>SqlSession</code>  提供，默认设置，不用自主开启。同一个 <code>SqlSession</code>  实例和同一个 <code>sql</code>  语句。就会使用缓存。</p><p>第一次 <code>DQL</code>  和第二次 <code>DQL</code>  之间你做了以下两件事中的任意一件，都会让一级缓存清空:</p><ol><li>执行了 <code>sqlSession的clearCache()</code>  方法，这是手动清空缓存。</li><li>执行了 <code>INSERT</code>  或 <code>DELETE</code>  或 <code>UPDATE</code>  语句。不管你是操作哪张表的，都会清空一级缓存。</li></ol><h2 id="二级缓存"><a class="markdownIt-Anchor" href="#二级缓存">#</a> 二级缓存</h2><p>由 <code>SqlsessionFactory</code>  提供。</p><p>使用二级缓存需要具备以下几个条件:</p><ol><li><p><code>&lt;setting name=&quot;cacheEnabled&quot;value=&quot;true&quot;&gt;</code>  全局性地开启或关闭所有映射器配置文件中已配置的任缓存。默认就是 true, 无需设置</p></li><li><p>在需要使用二级缓存的 <code>SglMapperxml</code>  文件中添加配置:  <code>&lt;cache /&gt;</code></p></li><li><p>使用二级缓存的卖体类对象必须是可序列化的，也就是必须实现 <code>java.io.Serializable</code>  接口</p></li><li><p><code>SqlSession</code>  对象关闭或提交之后，一级缓存中的数据才会被写入到二级缓存当中。此时二级缓存才可用。</p></li></ol><h1 id="逆向工程"><a class="markdownIt-Anchor" href="#逆向工程">#</a> 逆向工程</h1><h1 id="pagehelper"><a class="markdownIt-Anchor" href="#pagehelper">#</a> PageHelper</h1><p>第三方提供的分页插件，依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>x.x.x<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用如下，首先前往 <code>Mybatis</code>  的核心配置文件，配置如下内容，注册拦截器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其次编写抽象方法和查询的 <code>sql</code>  语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getCars&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;car&quot;</span>&gt;</span><br>    select * from t_car <span class="hljs-comment">&lt;!--注意此处不要用limit，也不要用分号结尾--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后编写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">PageHelper.startPage(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//开启PageHelper的功能，1为开始的页数，5为本页的数据个数</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtil.getSqlSession();<br><span class="hljs-type">CarMapper</span> <span class="hljs-variable">carMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(CarMapper.class);<br>List&lt;Car&gt; cars = Car.getCars();<br>PageInfo&lt;Car&gt; pageInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>&lt;&gt;(cars); <span class="hljs-comment">//分页数据就保存在PageInfo对象中，其中PgeInfo的泛型用于声明保存的是何种对象</span><br></code></pre></td></tr></table></figure><h1 id="注解式开发"><a class="markdownIt-Anchor" href="#注解式开发">#</a> 注解式开发</h1><p><code>Mybatis</code>  提供了通过注解的方式开发，但对于复杂的 <code>sql</code>  语句， <code>Mybatis</code>  建议任然用 <code>xml</code>  进行开发，下面介绍简单的用法。</p><h2 id="insert"><a class="markdownIt-Anchor" href="#insert">#</a> @Insert</h2><p><code>insert</code>  语句的注解表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Insert(&quot;insert into t_car values(null,#&#123;carNum&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;)&quot;)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">IndsertCar</span><span class="hljs-params">(Car car)</span>;<br></code></pre></td></tr></table></figure><h2 id="delete"><a class="markdownIt-Anchor" href="#delete">#</a> @Delete</h2><p><code>delete</code>  语句的注解表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Delete(&quot;delete from t_car where id=#&#123;id&#125;&quot;)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">delCar</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span><span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure><h2 id="udate"><a class="markdownIt-Anchor" href="#udate">#</a> @Udate</h2><p><code>update</code>  语句的注解表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Update(&quot;update t_car set car_num=#&#123;carNum&#125;,brand=#&#123;brand&#125;&quot;)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">updateCar</span><span class="hljs-params">(Car car)</span>;<br></code></pre></td></tr></table></figure><h2 id="select"><a class="markdownIt-Anchor" href="#select">#</a> @Select</h2><p><code>select</code>  语句的注解表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from t_car where id=#&#123;id&#125;&quot;)</span><br>Car <span class="hljs-title function_">getCar</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span><span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure><h3 id="results"><a class="markdownIt-Anchor" href="#results">#</a> @Results</h3><p>自定义映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from t_car where id=#&#123;id&#125;&quot;)</span><br><span class="hljs-meta">@Results(value =&#123;</span><br><span class="hljs-meta">    @Result(property = &quot;carNum&quot;, column = &quot;car_num&quot;),</span><br><span class="hljs-meta">        @Result(property = &quot;guidePrice&quot;, column = &quot;guide_price&quot;)</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">)</span><br>Car <span class="hljs-title function_">getCar</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span><span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ORM框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ORM框架</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2024/01/23/nginx/"/>
    <url>/2024/01/23/nginx/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>使用平台: CentOS7</p><p>使用工具: VmWare17、xftp7、OpenSSH_for_Windows_8.1</p></blockquote> <img src="nginx.png"/><h1 id="centos配置"><a class="markdownIt-Anchor" href="#centos配置">#</a> CentOS 配置</h1><h2 id="静态ip"><a class="markdownIt-Anchor" href="#静态ip">#</a> 静态 IP</h2><h3 id="vware配置"><a class="markdownIt-Anchor" href="#vware配置">#</a> VWare 配置</h3><p>进入 Vmware，在最上方标签栏中找到 <strong>编辑 -&gt; 虚拟网络编辑器</strong>，进入网卡配置界面，如下图：</p><img src="IP1.png" /><p>点击更改设置标签，如下图：</p><img src="IP2.png" style="zoom: 67%;" /><p>首先选择 VMnet8 网卡，再点击<strong>下方 NAT 设置</strong>，如下图：</p><img src="IP3.png" style="zoom:67%;" /><p>记住弹出对话框中的子网 IP、子网掩码、网关。随后启动虚拟机</p><h3 id="虚拟机设置"><a class="markdownIt-Anchor" href="#虚拟机设置">#</a> 虚拟机设置</h3><p>使用命令  <code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code>  编辑 <code>ens33</code>  网卡设置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">TYPE</span>=<span class="hljs-string">Ethernet</span><br><span class="hljs-attr">PROXY_METHOD</span>=<span class="hljs-string">none</span><br><span class="hljs-attr">BROWSER_ONLY</span>=<span class="hljs-string">no</span><br><span class="hljs-attr">BOOTPROTO</span>=<span class="hljs-string">static #设置为静态IP，而不是dhcp动态分配</span><br><span class="hljs-attr">DEFROUTE</span>=<span class="hljs-string">yes</span><br><span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-string">no</span><br><span class="hljs-attr">IPV6INIT</span>=<span class="hljs-string">yes</span><br><span class="hljs-attr">IPV6_AUTOCONF</span>=<span class="hljs-string">yes</span><br><span class="hljs-attr">IPV6_DEFROUTE</span>=<span class="hljs-string">yes</span><br><span class="hljs-attr">IPV6_FAILURE_FATAL</span>=<span class="hljs-string">no</span><br><span class="hljs-attr">IPV6_ADDR_GEN_MODE</span>=<span class="hljs-string">stable-privacy</span><br><span class="hljs-attr">NAME</span>=<span class="hljs-string">ens33</span><br><span class="hljs-attr">UUID</span>=<span class="hljs-string">4565018e-6a54-4ffa-8ce2-802e725e46be</span><br><span class="hljs-attr">DEVICE</span>=<span class="hljs-string">ens33</span><br><span class="hljs-attr">ONBOOT</span>=<span class="hljs-string">yes #系统启动时，是否启动该网卡</span><br><span class="hljs-attr">IPADDR</span>=<span class="hljs-string">192.168.9.3 #IP地址，注意该地址必须为子网IP范围中的地址，即0~255</span><br><span class="hljs-attr">GATEWAY</span>=<span class="hljs-string">192.168.9.2 #网关，VmWare中设置的网关</span><br><span class="hljs-attr">NETMASK</span>=<span class="hljs-string">255.255.255.0 #子网掩码</span><br><span class="hljs-attr">DNS1</span>=<span class="hljs-string">8.8.8.8 #公网DNS服务器，可以配置多个，以DNS1，DNS2....排列</span><br></code></pre></td></tr></table></figure><p>编辑完成后，使用 <code>:</code>  +  <code>wq</code>  +  <code>回车</code> 保存并退出。</p><p>使用 <code>systemctl restart network</code>  重启网络。</p><p>尝试使用 <code>ping</code>  或者  <code>curl</code>  命令来判断配置是否成功，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping www.baidu.com<br>curl www.baidu.com<br></code></pre></td></tr></table></figure><p>若使用 <code>ping</code>  命令，出现下图，则代表网络畅通，配置成功：</p><img src="IP4.png" /><blockquote><p>[!Note]</p><p>注意：linux 的 ping 命令没有次数限制，需要使用 ctrl+c 来进行强制停止</p></blockquote><p>若使用 <code>curl</code>  命令，出现下图，则代表网络畅通，配置成功：</p><img src="IP4_1.png" /><h3 id="配置yum镜像源"><a class="markdownIt-Anchor" href="#配置yum镜像源">#</a> 配置 yum 镜像源</h3><blockquote><p>本文使用的是阿里云 yum 镜像源</p></blockquote><p>首先使用 <code>yum</code>  命令下载 <code>wget</code>  工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install wget -y #y参数代表，询问用户是否同意时，一律选择同意<br></code></pre></td></tr></table></figure><p>接着前往 <code>/etc/yum.repos.d</code> ，备份所有仓库文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc/yum.repos.d<br>mkdir backup #备份文件夹<br>mv *.repo backup<br>mv epel*.repo backup #若有epel仓库文件<br></code></pre></td></tr></table></figure><p>随后拉取阿里云 yum 源镜像仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget http://mirrors.aliyun.com/repo/Centos-7.repo<br>wget /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo #epel为为“红帽系”的操作系统提供额外的软件包<br><span class="hljs-meta prompt_">#</span><span class="language-bash">更新yum源</span><br>yum clean all<br>yum makecache<br>yum update<br></code></pre></td></tr></table></figure><h1 id="nginx学习"><a class="markdownIt-Anchor" href="#nginx学习">#</a> Nginx 学习</h1><h2 id="编译安装nginx"><a class="markdownIt-Anchor" href="#编译安装nginx">#</a> 编译安装 Nginx</h2><p>前往官网下载 Nginx，<a href="https://nginx.org/en/download.html" title="下载Nginx">Nginx 官网 ---- 下载</a>，选择适合 Linux 操作系统平台的版本，点击下载，如下图：</p><img src="download.png" /><p>通过 <code>ftp</code>  工具，将该文件上传至虚拟机中。</p><p>首先将压缩包放在一边。编译安装 nginx 需要一些前置的环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install gcc-c++ -y #g++编译器，编译c++<br>yum install pcre pcre-devel -y #Nginx的Rewrite模块和HTTP核心模块会使用到的PCRE正则表达式语法库<br>yum install zlib zlib-devel -y #zlib库提供了开发人员的压缩算法，在Nginx的各种模块中需要使用gzip压缩<br>yum install openssl openssl-devel -y #若要使用https，则需要安装 OpenSSL 库<br></code></pre></td></tr></table></figure><p>前置环境配置完成后，解压 Nginx 压缩包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -xzvf nginx-1.24.0.tar.gz<br>cd nginx-1.24.0<br></code></pre></td></tr></table></figure><p>解压缩后的文件目录如下图：</p><img src="nginx_compile_dir.png" /><p>其中 configure 即为我们需要的编译文件，执行以下命令进行编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">./configure --prefix=/usr/local/nginx  --with-http_ssl_module #运行configure脚本<br><span class="hljs-meta prompt_"># </span><span class="language-bash">prefix即为安装后的路径，源文件一般放在usr/local路径</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--with-http_ssl_module，集成https模块</span><br></code></pre></td></tr></table></figure><p>解压成功后，会自动在当前目录生成 Makefile 文件：</p><img src="nginx_configure_down.png" /><p>随后执行如下命令进行编译安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>出现下图即代表安装完成：</p><img src="nginx_compile_install.png" /><p>随后即可以前往之前设定的目录 <code>/usr/local/nginx</code>  查看安装完成的 Nginx。</p><h2 id="nginx目录"><a class="markdownIt-Anchor" href="#nginx目录">#</a> Nginx 目录</h2><p>Nginx 的目录如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx<br>├── client_body_temp<br>├── conf #配置文件目录<br>│   ├── fastcgi.conf<br>│   ├── fastcgi.conf.default<br>│   ├── fastcgi_params<br>│   ├── fastcgi_params.default<br>│   ├── koi-utf<br>│   ├── koi-win<br>│   ├── mime.types<br>│   ├── mime.types.default<br>│   ├── nginx.conf #nginx的主配置文件，可在nginx.conf通过include包含其他配置文件<br>│   ├── nginx.conf.default<br>│   ├── scgi_params<br>│   ├── scgi_params.default<br>│   ├── uwsgi_params<br>│   ├── uwsgi_params.default<br>│   └── win-utf<br>├── fastcgi_temp<br>├── html #静态页面目录<br>│   ├── 50x.html<br>│   └── index.html<br>├── logs #日志文件目录<br>│   ├── access.log #成功日志文件<br>│   ├── error.log #错误日志文件<br>│   └── nginx.pid #nginx启动后会生成的文件，记录了nginx的PID号<br>├── proxy_temp<br>├── sbin #二进制文件目录<br>│   ├── nginx #控制nginx的二进制文件<br>│   └── nginx.old<br>├── scgi_temp<br>└── uwsgi_temp<br></code></pre></td></tr></table></figure><h2 id="nginx的常用命令"><a class="markdownIt-Anchor" href="#nginx的常用命令">#</a> Nginx 的常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">./nginx start #启动Nginx<br>./nginx -s stop #暴力停止Nginx，不管是否还有任务<br>./nginx -s reload #重新加载配置文件，此时Nginx不在接受任何请求，直到配置文件重新加载完毕。<br>./nginx -s quit #优雅退出Nginx，此时Nginx不在接受任何请求，将未完成的任务完成后即退出<br>./nginx -s reopen #重新打开的日志文件和监听套接字<br>./nginx -t #测试配置文件是否配置正确<br>./nginx -h|? #查看帮助文档<br>./nginx -v #查看当前Nginx版本<br>./nginx -V #查看当前Nginx版本，执行configure时的配置<br>  -t            : test configuration and exit<br>  -T            : test configuration， dump it and exit<br>  -q            : suppress non-error messages during configuration testing<br>  -s signal     : send signal to a master process: stop， quit， reopen， reload<br>  -p prefix     : set prefix path (default: /usr/local/)<br>  -e filename   : set error log file (default: logs/error.log)<br>  -c filename   : set configuration file (default: conf/nginx.conf)<br>  -g directives : set global directives out of configuration file<br><span class="hljs-meta prompt_">#</span><span class="language-bash">-s参数为向Master进程发送signal。 什么是master进程，后面再详解</span><br></code></pre></td></tr></table></figure><h2 id="尝试启动nginx服务"><a class="markdownIt-Anchor" href="#尝试启动nginx服务">#</a> 尝试启动 Nginx 服务</h2><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">./nginx start<br>firewall-cmd --zone=public --add-port=80/tcp --permanent #开启80端口，Nginx默认监听80端口<br>systemctl restart firewalld #重启防火墙<br></code></pre></td></tr></table></figure><p>随后前往浏览器访问 <code>&lt;你的虚拟机IP&gt;:80</code>  或者在虚拟机中输入 <code>curl localhost:80</code> ，出现如下所示图片，即代表启动成功：</p><img src="nginx_start_url.png" /><img src="nginx_start_curl.png" /><h2 id="配置nginx为系统服务"><a class="markdownIt-Anchor" href="#配置nginx为系统服务">#</a> 配置 Nginx 为系统服务</h2><p>使用 <code>vi</code>  命令编辑，位于 <code>/lib/systemd/system</code>  的  <code>nginx.service</code>  文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /lib/systemd/system/nginx.service<br></code></pre></td></tr></table></figure><p>输入以下内容：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">[Unit]</span><br><span class="hljs-attr">Description</span>=<span class="hljs-string">nginx - high performance web server #该服务的描述</span><br><span class="hljs-attr">After</span>=<span class="hljs-string">network.target remote-fs.target nss-lookup.target #在什么服务之后执行</span><br><br><span class="hljs-attr">[Service]</span><br><span class="hljs-attr">Type</span>=<span class="hljs-string">simple #启动方式，告诉Systemd什么时候服务启动完成</span><br><span class="hljs-attr">PIDFile</span>=<span class="hljs-string">/usr/local/logs/nginx.pid #PID文件路径</span><br><span class="hljs-attr">ExecStartPre</span>=<span class="hljs-string">/usr/local/sbin/nginx -t -c /usr/local/conf/nginx.conf #start前执行什么</span><br><span class="hljs-attr">ExecStart</span>=<span class="hljs-string">/usr/local/sbin/nginx -c /usr/local/conf/nginx.conf #start执行命令</span><br><span class="hljs-attr">ExecReload</span>=<span class="hljs-string">/usr/local/sbin/nginx -s reload  #reload执行命令</span><br><span class="hljs-attr">ExecQuit</span>=<span class="hljs-string">/usr/local/sbin/nginx -s quit #quit执行命令</span><br><span class="hljs-attr">ExecStop</span>=<span class="hljs-string">/usr/local/sbin/nginx -s stop #stop执行命令</span><br><span class="hljs-attr">PrivateTmp</span>=<span class="hljs-string">true</span><br><br><span class="hljs-attr">[Install]</span><br><span class="hljs-attr">WantedBy</span>=<span class="hljs-string">multi-user.target</span><br></code></pre></td></tr></table></figure><p>编辑完成后，保存退出，重启 Systemd。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br>systemctl enable nginx #设置ngixn为开机自启服务<br></code></pre></td></tr></table></figure><h3 id="通过sytemctl控制nginx"><a class="markdownIt-Anchor" href="#通过sytemctl控制nginx">#</a> 通过 sytemctl 控制 Nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start|reload|stop|quit nginx #同nginx的内部命令<br>systemctl status nginx #查看nginx现在的状态<br>journalctl -xe #查看systemd的日志<br></code></pre></td></tr></table></figure><p>通过 systemctl 启动 nginx，注意：启动前请停止之前启动过的 nginx。随后查看 nginx 的状态，如下图所示则启动成功。</p><img src="nginx_avtive.png" /><p>现在也可以在外部访问 nginx 服务器。</p><blockquote><p>[!Tip]</p><p>若启动失败，尝试关闭 selinux。尝试运行命令： <code>setenforce 0</code></p></blockquote><h2 id="nginx的工作模型"><a class="markdownIt-Anchor" href="#nginx的工作模型">#</a> Nginx 的工作模型</h2><p>如下图为 Nginx 的工作模型。启动 Nginx 后会启动两个进程：Master 和 Worker。Master 为主进程，用来管理 worker，Worker 是子进程，接受网络请求和响应。</p><p>Master 启动时会读取配置文件并校验有无语法错误，随后开启子进程。</p><p>当 Worker 收到请求后，会解析请求，读取配置文件进行路径映射，加载请求的资源。</p><img src="nginx_model.png" /><h2 id="nginx配置"><a class="markdownIt-Anchor" href="#nginx配置">#</a> Nginx 配置</h2><h3 id="nginx的最小配置文件"><a class="markdownIt-Anchor" href="#nginx的最小配置文件">#</a> Nginx 的最小配置文件</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>; <span class="hljs-comment">#工作进程数，一般设置为核数或CPU数</span><br><span class="hljs-section">events</span> &#123; <span class="hljs-comment">#事件驱动模块</span><br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>; <span class="hljs-comment">#每个工作进程的连接数</span><br>&#125;<br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       mime.types; <span class="hljs-comment">#include将其他的配置文件引入，mine.types保存着请求头Accept和请求的资源后缀的映射</span><br>    <span class="hljs-attribute">default_type</span>  application/octet-stream; <span class="hljs-comment">#默认的请求头Accept</span><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>; <span class="hljs-comment">#数据零拷贝，见下图。</span><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>; <span class="hljs-comment">#长链接超时时间</span><br>    <span class="hljs-comment">#以下为虚拟主机vhost</span><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>; <span class="hljs-comment">#监听端口</span><br>        <span class="hljs-attribute">server_name</span>  localhost; <span class="hljs-comment">#域名、主机名</span><br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">root</span>   html; <span class="hljs-comment">#设置主机站点的根目录地址</span><br>            <span class="hljs-attribute">index</span>  index.html index.htm;<br>        &#125;<br>        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html; <span class="hljs-comment"># 服务器错误码为500 502 503 504，转到&quot;域名/50x.html&quot;</span><br>        <span class="hljs-section">location</span> = /50x.html &#123; <span class="hljs-comment">#指定到html文件夹下找/50x.htm</span><br>            <span class="hljs-attribute">root</span>   html;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sendfile"><a class="markdownIt-Anchor" href="#sendfile">#</a> sendfile</h4><p>开启 sendfile。nginx 将会向网络接口发送信号，让其读取文件，直接发送。</p><img src="nginx_sendfile.png"/><hr><p>关闭 sendfile。nginx 将会自己<strong>读取</strong>磁盘文件，加载到应用程序的内存中，然后将文件<strong>发送</strong>给网络接口，网络接口将文件返回。此过程将会有内核态和用户态之间的转换，降低性能。</p><img src="nginx_unsendfile.png"/><h3 id="权限控制"><a class="markdownIt-Anchor" href="#权限控制">#</a> 权限控制</h3><p>访问控制是网络安全防范和保护的主要策略，其任务是保证网络资源不被非法访问。 <code>Nginx</code>  作为 <code>Web</code>  服务器的后起之秀，也提供了访问控制的功能。它可以根据实际需求，对用户可以访问和禁止的目录进行限制。下面将对 <code>Nginx</code>  提供的权限控制指令以及典型的应用进行详细讲解。</p><p>Nginx 中提供了两个用于配置访问权限控制的指令，分别为 <code>allow</code>  和 <code>deny</code> 。从其名称就可以看出， <code>allow</code>  用于设置允许访问的权限、 <code>deny</code>  用于设置禁止访问的权限。在使用时，权限指令后只需跟上允许或禁止的 <code>IP</code>  段或 <code>all</code>  即可。其中， <code>all</code>  表示所有的。</p><blockquote><p>[!Note]</p><p>权限控制指令的使用虽然简单，但是在设置的过程中，还需要特别注意以下几个点。</p><ul><li>单个 <code>IP</code>  指定作用范围最小， <code>all </code> 指定作用范围最大。</li><li>同一块下，若同时存在多个权限指令 ( <code>deny</code> 、 <code>allow</code> )，则先出现的访问权限设置生效，并且会对后出现的设置进行覆盖，未覆盖的范围依然生效，否则以先出现的设置为准。</li><li>当多个块 (如 <code>http</code> 、 <code>server</code> 、 <code>location</code> ) 中都出现了权限设置指令，则内层块中的权限级别要比外层块中设置的权限级别高。</li><li>默认访问权限为： <code>allow all</code></li></ul></blockquote><h4 id="拒绝或允许所有人"><a class="markdownIt-Anchor" href="#拒绝或允许所有人">#</a> 拒绝或允许所有人</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">allow</span> all <span class="hljs-comment">#所有人都可以访问，没有意义</span><br>deny all <span class="hljs-comment">#任何人都不能访问</span><br></code></pre></td></tr></table></figure><blockquote><p>[!Note]</p><p>注意， <code>deny all</code>  将会把包括自己在内的访问者全部拒绝。</p></blockquote><h4 id="允许指定用户访问"><a class="markdownIt-Anchor" href="#允许指定用户访问">#</a> 允许指定用户访问</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">allow</span> <span class="hljs-number">192.168.9.3</span>; <span class="hljs-comment">#允许192.168.78.128的IP访问</span><br><span class="hljs-attribute">deny</span> all;<br></code></pre></td></tr></table></figure><blockquote><p>上述指令表示只允许 <code>192.168.9.3</code>  客户端访问，其他所有客户端都不能访问。需要注意的是，若省略此处的 <code>deny all</code> ，则会允许所有客户端访问；若将 <code>deny all</code>  移动到 <code>allow 192.168.9.3</code>  之后，则会阻止所有客户端访问。</p><p>同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置，使得 <code>allow 192.168.78.128</code>  的配置优先生效；同时 <code>deny</code>  指令设置的访问范围 <code>all</code>  较大未被 <code>allow</code>  覆盖的范围配置依然生效，达到除了 <code>IP</code>  为 <code>192.168.78.128</code>  的用户外，禁止其他用户对服务器访问的效果。</p></blockquote><h4 id="允许指定网段的用户访问"><a class="markdownIt-Anchor" href="#允许指定网段的用户访问">#</a> 允许指定网段的用户访问</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">allow</span> <span class="hljs-number">192.168.9.0</span>/<span class="hljs-number">24</span>; <span class="hljs-comment">#允许192.168.9.1到192.168.9.255的IP访问</span><br><span class="hljs-attribute">deny</span> all;<br></code></pre></td></tr></table></figure><h4 id="拒绝指定用户访问"><a class="markdownIt-Anchor" href="#拒绝指定用户访问">#</a> 拒绝指定用户访问</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">deny</span> <span class="hljs-number">192.168.9.4</span> <span class="hljs-comment">#拒绝192.168.9.4的IP访问</span><br></code></pre></td></tr></table></figure><h4 id="拒绝指定网段用户访问"><a class="markdownIt-Anchor" href="#拒绝指定网段用户访问">#</a> 拒绝指定网段用户访问</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">deny</span> <span class="hljs-number">192.168.9.0</span>/<span class="hljs-number">24</span> <span class="hljs-comment">#拒绝192.168.9.1到192.168.9.255的IP访问</span><br></code></pre></td></tr></table></figure><h3 id="location模块"><a class="markdownIt-Anchor" href="#location模块">#</a> location 模块</h3><p><code>location</code>  块用于匹配 <code>URI</code> ，同时进行一些访问控制、权限控制、负载均衡、反向代理等功能。</p><h4 id="location的匹配语法"><a class="markdownIt-Anchor" href="#location的匹配语法">#</a> location 的匹配语法</h4><p>在此之前，首先要简单了解一下 location 的相关语法及规定，具体如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> [=|~|~*|^~] URI &#123;...&#125; <span class="hljs-comment">#语法类型1</span><br><span class="hljs-section">location</span> <span class="hljs-variable">@name</span> &#123;...&#125; <span class="hljs-comment">#语法类型2</span><br></code></pre></td></tr></table></figure><blockquote><p>[!Note]</p><p>在上述语法中 =、~、~*、^~ 和 @都是 <code>location</code>  用于实现访问控制的前缀，且在使用时只能选择一种，当然也可以不设置前缀。其中，关于 location 前缀的含义如下表所示。<br>URI 表示 URL 地址中从域名到参数之间的部分， <code>&#123;...&#125;</code>  表示指令块，用于满足 <code>location</code>  匹配条件后需要执行的指令。</p></blockquote><table><thead><tr><th>前缀</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>根据其后的指定模式进行精准匹配。例如，在访问时要与 <code>/html/aaa/index.html</code>  完全一致才会执行其后的指令块</td></tr><tr><td>~</td><td>使用正则表达式完成 <code>location</code>  的匹配，区分大小写</td></tr><tr><td>~**</td><td>使用正则表达式完成 <code>location</code>  的匹配，不区分大小写</td></tr><tr><td>^~</td><td>不使用正则表达式，完成以指定模式开头的 <code>location</code>  匹配</td></tr><tr><td>@</td><td>用于定义一个 <code>location</code>  块，且该块不能被外部客户端所访问，只能被 Nginx 内部配置指令所访问</td></tr></tbody></table><blockquote><p>[!Note]</p><p>根据上表的描述可将 <code>location</code>  根据不同前缀的使用方式，大致分为普通 <code>location</code>  和正则 <code>location</code> 。其中， <code>~</code>  和 <code>~*</code>  属于正则 <code>location</code> ，其余的前缀和没有前缀的情况都属于普通 <code>location</code> 。</p></blockquote><h4 id="精确匹配"><a class="markdownIt-Anchor" href="#精确匹配">#</a> 精确匹配</h4><p>所谓精准匹配指的就是用户访问的  <code>URI</code>  与指定的 <code>URI</code>  完全一致的情况，才会执行其后的指令块</p><p>服务器位于 <code>192.168.9.5</code> ，有 <code>192.168.9.3</code>  和 <code>192.168.9.4</code>  两个用户进行访问，示例配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nginx">server&#123;<br><span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><span class="hljs-attribute">server_name</span> localhost;<br><span class="hljs-attribute">root</span> html;<br><span class="hljs-attribute">index</span> index.html index.htm;<br>    <span class="hljs-section">location</span> =/js &#123;<br><span class="hljs-attribute">allow</span> <span class="hljs-number">192.168.9.3</span>;<br>        <span class="hljs-attribute">deny</span> all;<br>    &#125;<br>    <span class="hljs-section">location</span> =/admin/auth&#123;<br>        <span class="hljs-attribute">allow</span> <span class="hljs-number">192.168.9.4</span>;<br>        <span class="hljs-attribute">deny</span> all;<br>&#125;<br>    <br>    <span class="hljs-attribute">deny</span> all;<br>&#125;<br></code></pre></td></tr></table></figure><p>响应结果如下：</p><table><thead><tr><th>URL</th><th>192.168.9.3</th><th>192.168.9.4</th></tr></thead><tbody><tr><td><a href="http://192.168.9.5">http://192.168.9.5</a></td><td>403 Forbidden</td><td>403 Forbidden</td></tr><tr><td><a href="http://192.168.9.5/js">http://192.168.9.5/js</a></td><td>404 Not Found</td><td>403 Forbidden</td></tr><tr><td><a href="http://192.168.9.5/admin/auth">http://192.168.9.5/admin/auth</a></td><td>403 Forbidden</td><td>404 Not Found</td></tr><tr><td><a href="http://192.168.9.5/admin">http://192.168.9.5/admin</a></td><td>403 Forbidden</td><td>403 Forbidden</td></tr></tbody></table><h4 id="正则匹配"><a class="markdownIt-Anchor" href="#正则匹配">#</a> 正则匹配</h4><p>Nginx 配置文件中，多个正则 <code>location</code>  之间按照正则 <code>location</code>  在配置文件中的书写顺序进行匹配，且只要匹配成功就不会继续匹配后面定义的正则 <code>location</code> 。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> ~\.html$ &#123;<br><span class="hljs-attribute">allow</span> all;<br>&#125;<br><span class="hljs-section">location</span> ~^/aaa/.*\.html$&#123;<br>    <span class="hljs-attribute">deny</span> all;<br>&#125;<br></code></pre></td></tr></table></figure><p>响应结果如下：</p><table><thead><tr><th>URL</th><th>响应结果</th></tr></thead><tbody><tr><td><a href="http://192.168.9.5/test.html">http://192.168.9.5/test.html</a></td><td>404 Not Found (匹配了第 1 行 location)</td></tr><tr><td><a href="http://192.168.9.5/aaa/test.html">http://192.168.9.5/aaa/test.html</a></td><td>404 Not Found (匹配了第 1 行 location)</td></tr></tbody></table><blockquote><p>[!Tip]</p><p>精确匹配和 <code>^~</code>  匹配会禁用正则匹配</p></blockquote><h4 id="最大前缀匹配"><a class="markdownIt-Anchor" href="#最大前缀匹配">#</a> 最大前缀匹配</h4><p>由于 <code>location</code>  可以同时定义多个，当一个配置文件中同时出现多个 <code>location</code>  时，普通 <code>location</code>  之间遵循<strong>最大前缀匹配</strong>原则。通俗地讲就是，匹配度最高的 <code>location</code>  将会执行。</p><p>示例如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /ng.test [<br>allow all;<br>&#125;<br><span class="hljs-section">location</span> /ng.test/log [<br>deny all;<br>&#125;<br></code></pre></td></tr></table></figure><p>响应结果如下：</p><table><thead><tr><th>URL</th><th>响应结果</th></tr></thead><tbody><tr><td><a href="http://192.168.9.5/ng.test/data">http://192.168.9.5/ng.test/data</a></td><td>404 Not Found (匹配了第 1 行 location)</td></tr><tr><td><a href="http://192.168.9.5/ng.test/log">http://192.168.9.5/ng.test/log</a></td><td>403 Forbidden (匹配了第 4 行 location)</td></tr><tr><td><a href="http://192.168.9.5/ng.test/log/data">http://192.168.9.5/ng.test/log/data</a></td><td>403 Forbidden (匹配了第 4 行 location)</td></tr></tbody></table><blockquote><p>[!Tip]</p><p><code>location \ &#123;...&#125;</code> ：遵守普通 location 的最大前缀匹配，由于任何 URI 都必然以 **/** 根开头，所以对于一个 URI, 若配置文件中有更合适的匹配则会将其替代，否则返回 <code>location \ &#123;...&#125;</code>  匹配到的结果，它相当于站点默认配置。</p><p><code>location =\ &#123;...&#125;</code> ：遵守的是精准匹配，也就是只能匹配该站点根目录，同时会禁止继续搜索正则 <code>location</code> , 效率比 <code>location \ &#123;...&#125;</code>  要高。</p><p>因此，若在开发中能确定精准匹配的情况，可以采用 <code>location =\ &#123;...&#125;</code>  的方式，提升匹配效率。</p></blockquote><blockquote><p>[!Note]</p><p>当多种类型的 location 匹配同时出现时；最终执行结果为： <code>=</code>  匹配 &gt;  <code>^~</code>  匹配 &gt; 正则匹配 &gt; 普通的最大前缀匹配</p><p>只要优先的 <code>location</code>  匹配成功，就不会执行其他的 <code>location</code> 。</p></blockquote><h2 id="虚拟主机配置"><a class="markdownIt-Anchor" href="#虚拟主机配置">#</a> 虚拟主机配置</h2><p>虚拟主机为配置文件中的 <code>server</code>  块。匹配到第一个<strong>虚拟主机</strong>，则停止匹配。</p><h3 id="基于端口的虚拟主机配置"><a class="markdownIt-Anchor" href="#基于端口的虚拟主机配置">#</a> 基于端口的虚拟主机配置</h3><p>在 <code>nginx.conf</code>  添加如下配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nginx">server&#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">81</span>;<br>    <span class="hljs-attribute">server_name</span> localhost;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span> html/www;<br>        <span class="hljs-attribute">index</span> index.html;<br>    &#125;<br>&#125;<br>server&#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">82</span>;<br>    <span class="hljs-attribute">server_name</span> localhost;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span> html/vod;<br>        <span class="hljs-attribute">index</span> index.html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新加载 nginx 主配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl reload nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">端口没有打开的情况</span><br>firewall-cmd --zone=public --add-port=81/tcp --permanent<br>firewall-cmd --zone=public --add-port=82/tcp --permanent<br>systemctl restart firewalld<br></code></pre></td></tr></table></figure><p>重新访问即可进入不同的页面。</p><h3 id="基于server_name的虚拟主机配置"><a class="markdownIt-Anchor" href="#基于server_name的虚拟主机配置">#</a> 基于 server_name 的虚拟主机配置</h3><p>server_name 的匹配顺序为：<strong>准确</strong> &gt; <strong>开头通配符</strong> &gt; <strong>结尾通配符</strong> &gt; <strong>正则表达式</strong>。</p><h4 id="准确"><a class="markdownIt-Anchor" href="#准确">#</a> 准确</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nginx">server&#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> www.<span class="hljs-number">123</span>.com;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span> html/www;<br>        <span class="hljs-attribute">index</span> index.html;<br>    &#125;<br>&#125;<br>server&#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> www.<span class="hljs-number">1234</span>.com;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span> html/vod;<br>        <span class="hljs-attribute">index</span> index.html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="开头通配符"><a class="markdownIt-Anchor" href="#开头通配符">#</a> 开头通配符</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx">server&#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> *.<span class="hljs-number">123</span>.com;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span> html/www;<br>        <span class="hljs-attribute">index</span> index.html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结尾通配符"><a class="markdownIt-Anchor" href="#结尾通配符">#</a> 结尾通配符</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx">server&#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> www.<span class="hljs-number">123</span>.*;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span> html/www;<br>        <span class="hljs-attribute">index</span> index.html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式">#</a> 正则表达式</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx">server&#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> ~^w&#123;3&#125;\.123.com;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span> html/www;<br>        <span class="hljs-attribute">index</span> index.html;<br>    &#125;<br>&#125;<br><span class="hljs-comment"># ~代表开启正则表达式匹配，不属于正则表达式的内容</span><br></code></pre></td></tr></table></figure><h2 id="代理"><a class="markdownIt-Anchor" href="#代理">#</a> 代理</h2><p>如果两方无法正常通信。那么可以使用 <strong>代理</strong>，通过访问代理服务器，让代理服务器去访问之前无法访问的主机。</p><h3 id="正向代理"><a class="markdownIt-Anchor" href="#正向代理">#</a> 正向代理</h3><p>正向代理可以理解为「客户端」的代理，即客户端主动提供代理服务，客户端知道代理服务器的存在。</p><img src="proxy_positive.png"/><h3 id="反向代理"><a class="markdownIt-Anchor" href="#反向代理">#</a> 反向代理</h3><p>反向代理可以理解为「服务器」的代理，即服务器端主动提供代理服务，客户端不知道代理服务器的存在。</p><img src="proxy_negative.png"/><h4 id="nginx反向代理"><a class="markdownIt-Anchor" href="#nginx反向代理">#</a> Nginx 反向代理</h4><p>如下图所示， <code>Nginx</code>  服务器接入公网，可以被外界访问，真正的业务服务器，外界无法访问。业务服务器的进出都要通过 <code>Nginx</code>  服务器，如果 <code>Nginx</code>  服务器的带宽不够高，将导致性能瓶颈。此谓， <code>Nginx</code>  代理的隧道模型</p><img src="nginx_proxy_tunnel.png"/><blockquote><p>另一种模型为 <code>DR</code>  模型，进则经过代理服务器，出则直接通向网关。</p></blockquote><p>Nignx 的反向代理通过关键字「 <code>proxy_pass</code> 」实现。「 <code>proxy_pass</code> 」要在 <code>location</code>  块中使用。如下所示：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://www.bilibili.com <span class="hljs-comment">#注意，必须带有协议。</span><br>        <span class="hljs-comment">#root   html;</span><br>        <span class="hljs-comment">#index  index.html index.htm;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!Note]</p><p>可能出现： <code>proxy_pass</code>  中的域名，如果去掉二级域名，可能会导致重定向。此时并不是反向代理未成功。而是因为网站设计人员可能会让无 <code>www</code>  二级域名的请求重定向至含有 <code>www</code>  二级域名的网址。</p><p>同时，若访问的请求是 http 协议，那么也可能发生重定向。重定向至 https 协议。原因也是网站设计带来的问题。</p></blockquote><p>额外的参数：</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>proxy_set_header</td><td>在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息</td></tr><tr><td>proxy_connect_timeout</td><td>配置 Nginx 与后端代理服务器尝试建立连接的超时时间</td></tr><tr><td>proxy_read_timeout</td><td>配置 Nginx 向后端服务器组发出 read 请求后，等待响应的超时时间</td></tr><tr><td>proxy_send_timeout</td><td>配置 Nginx 向后端服务器组发出 write 请求后，等待响应的超时时间</td></tr><tr><td>proxy_redirect</td><td>用于修改后端服务器返回的响应头中的 Location 和 Refresh</td></tr></tbody></table><h2 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡">#</a> 负载均衡</h2><p>把请求，按照一定算法规则，分配给多台业务服务器（即使其中一个坏了 / 维护升级，还有其他服务器可以继续提供服务）。</p><img src="load_balance.png" /><p>Nginx 的负载均衡通过， <code>upstream</code>  和 <code>proxy_pass</code>  配合使用。</p><blockquote><p>[!Note]</p><p>注意， <code>upstream</code>  和 <code>server</code>  一个级别</p></blockquote><h3 id="轮询"><a class="markdownIt-Anchor" href="#轮询">#</a> 轮询</h3><p>雨露均沾，所有配置的服务器轮换着被访问。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> httpd&#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.9.4:80</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.9.5:80</span>;<br>&#125;<br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://httpd;<br>        <span class="hljs-comment">#root   html;</span><br>        <span class="hljs-comment">#index  index.html index.htm;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!Note]</p><p>轮询为 <code>Nginx</code>  的默认负载均衡策略</p></blockquote><p><code>upstream</code>  有如下常用状态参数：</p><table><thead><tr><th style="text-align:left">指令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">fail_timeout</td><td style="text-align:left">与 max_fails 结合使用。</td></tr><tr><td style="text-align:left">max_fails</td><td style="text-align:left">设置在 fail_timeout 参数设置的时间内最大失败次数，如果在这个时间内，所有针对该服务器的请求都失败了，那么认为该服务器会被认为是停机了</td></tr><tr><td style="text-align:left">fail_time</td><td style="text-align:left">服务器会被认为停机的时间长度，默认为 10s。</td></tr><tr><td style="text-align:left">backup</td><td style="text-align:left">标记该服务器为备用服务器。当主服务器停止时，请求会被发送到它这里。</td></tr><tr><td style="text-align:left">down</td><td style="text-align:left">标记服务器永久停机了。</td></tr></tbody></table><blockquote><p>[!Note]</p><ul><li><p>在轮询中，如果服务器 down 掉了，会自动剔除该服务器。</p></li><li><p>缺省配置就是轮询策略。</p></li><li><p>此策略适合服务器配置相当，<strong>无状态</strong>且短平快的服务使用</p></li></ul></blockquote><h4 id="加权轮询"><a class="markdownIt-Anchor" href="#加权轮询">#</a> 加权轮询</h4><p>通过 <code>weight</code>  实现，权重大的访问会更多。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> httpd&#123; <span class="hljs-comment">#httpd为别名</span><br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.9.4:80</span> weight=<span class="hljs-number">2</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.9.5:80</span> weight=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://httpd;<br>        <span class="hljs-comment">#root   html;</span><br>        <span class="hljs-comment">#index  index.html index.htm;</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>[!Tip]</p><p>轮询是一种无状态的轮询策略，无法保证 <code>session</code>  一致。</p></blockquote><h3 id="ip_hash"><a class="markdownIt-Anchor" href="#ip_hash">#</a> ip_hash</h3><p>同一个来源的 <code>IP</code>  指向一个服务器。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> httpd&#123;<br>    ip_hash; <span class="hljs-comment">#指明使用ip_hash方式</span><br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.9.4:80</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.9.5:80</span>;<br>&#125;<br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://httpd;<br>        <span class="hljs-comment">#root   html;</span><br>        <span class="hljs-comment">#index  index.html index.htm;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!Note]</p><p>需要注意的是，在使用 <code>ip_hash</code>  方式处理负载均衡时，Web 服务器在负载均衡列表中的状态不能使用 <code>weight</code>  和 <code>backup</code>  设置。</p></blockquote><blockquote><p>[!Tip]</p><p>值得一提的是，由于 <code>ip_hash</code>  方式为每一个用户 <code>IP</code>  绑定了一个 <code>Web</code>  服务器处理，将会导致某些 <code>Web</code>  服务器接收的请求多，某些 <code>Web</code>  服务器接到的请求少，无法保证 <code>Web</code>  服务器的负载均衡。因此，建议只在必要的情况下使用这种方式。同时， <code>ip_hash</code>  可以用来处理有状态的请求。</p></blockquote><h3 id="url_hash"><a class="markdownIt-Anchor" href="#url_hash">#</a> url_hash</h3><p>同一个来源的 <code>URL</code>  指向一个服务器。</p><h3 id="leat_connection"><a class="markdownIt-Anchor" href="#leat_connection">#</a> leat_connection</h3><p>把请求转发给连接数较少的后端服务器。需要第三方的组件</p><h3 id="fair"><a class="markdownIt-Anchor" href="#fair">#</a> fair</h3><p>根据后端服务器相应时间进行分配。需要第三方的组件。</p>]]></content>
    
    
    <categories>
      
      <category>web服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
