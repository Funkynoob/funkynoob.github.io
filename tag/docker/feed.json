{
    "version": "https://jsonfeed.org/version/1",
    "title": "Funkynoob的个人博客 • All posts by \"docker\" tag",
    "description": "亿点点心得",
    "home_page_url": "https://blog.riversea.top",
    "items": [
        {
            "id": "https://blog.riversea.top/2024/03/10/docker/",
            "url": "https://blog.riversea.top/2024/03/10/docker/",
            "title": "docker",
            "date_published": "2024-03-10T05:07:52.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"什么是docker\"><a class=\"markdownIt-Anchor\" href=\"#什么是docker\">#</a> 什么是 Docker</h1>\n<p><code>docker</code>  提供了一个平台为开发，转交，测试，以及运行应用提供了便利，让应用从操作系统等底层环境中分离开，不再受底层环境的桎梏。 <code>docker</code>  提供了一种名为 <strong>容器</strong> 的特性，让应用的运行与打包，在一个隔离的环境中。</p>\n<h1 id=\"容器container\"><a class=\"markdownIt-Anchor\" href=\"#容器container\">#</a> 容器 (container)</h1>\n<p>容器是提供给代码运行的隔离的环境。这意味着容器对你的操作系统或者文件系统一无所知。容器提供了代码运行的所有必要的东西，像是软件运行的必要的环境、类库，甚至是最底层的操作系统。你可以将容器类比为集装箱 —— 事实上这也是  <code>docker</code>  logo 的类比。容器就好似集装箱一样，所有的集装箱之间互不干扰。</p>\n<h2 id=\"镜像image\"><a class=\"markdownIt-Anchor\" href=\"#镜像image\">#</a> 镜像 (image)</h2>\n<p>镜像和容器的关系类似于类和对象的、程序和进程的关系。镜像在本地运行起来之后就是容器。镜像由开发人员所维护以及编写，镜像包括了代码运行的所有必要的环境。</p>\n<h3 id=\"如何获得镜像\"><a class=\"markdownIt-Anchor\" href=\"#如何获得镜像\">#</a> 如何获得镜像</h3>\n<p><code>Docker</code>  官方提供了一个镜像仓库 —— <a href=\"https://hub.docker.com/\">Docker hub</a>，类似于  <code>Github</code>  这样的代码托管平台，该镜像仓库托管了所有官方或者第三方提供的镜像。</p>\n<img src=\"docker/docker_hub.png\" alt=\"docker hub\"/>\n<p>由于  <code>docker hub</code>  是国外的，可以使用一些镜像仓库进行加速，例如阿里云、腾讯云。</p>\n<p>通过以下命令拉取镜像：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker pull &lt;image&gt;:[tag] #如果不指定tag，tag将会是默认值：latest<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>某个版本的镜像由镜像名和 tag 进行指定</p>\n</blockquote>\n<h2 id=\"查看本地镜像\"><a class=\"markdownIt-Anchor\" href=\"#查看本地镜像\">#</a> 查看本地镜像</h2>\n<p>查看本地的所有镜像：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker images<br></code></pre></td></tr></table></figure>\n<p>查看某个镜像的详细信息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker image inspect &lt;image-name&gt;<br></code></pre></td></tr></table></figure>\n<h3 id=\"删除本地镜像\"><a class=\"markdownIt-Anchor\" href=\"#删除本地镜像\">#</a> 删除本地镜像</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker rmi &lt;image-name&gt;<br></code></pre></td></tr></table></figure>\n<h2 id=\"运行容器\"><a class=\"markdownIt-Anchor\" href=\"#运行容器\">#</a> 运行容器</h2>\n<p>如何将镜像运行起来？ <code>docker</code>  提供了一个子命令，来将镜像运行为容器。：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>如果该镜像本地没有，则会进行远程拉取</p>\n</blockquote>\n<p>假设现在我们有一个名为： <code>mysql</code>  的镜像，我们来演示如何运行它：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -d|--detach #-d参数代表后台运行，并打印容器Id，如果不加这个参数，那么执行这个命令后，你的命令行会卡住，无法输入命令<br>--name mysql #--name，为该容器分配一个名字<br>-p|--publish 3306:3306 #-p为该容器分配一个端口映射，由于外部无法直接访问容器内部，因此需要进行端口映射。代表着宿主机的3306端口映射到容器的3306端口<br>-e|--env TZ=Asia/Shanghai #-e为容器写入环境变量，前面提到容器本事其实就算一个操作系统，所以理应由环境变量，该环境变量由容器中的容器读写<br>-e MYSQL_ROOT_PASSWORD=123<br>mysql #镜像名<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>好了，当你按下回车的那一刻，一个名为  <code>mysql</code>  的容器就开始创建了</p>\n</blockquote>\n<h3 id=\"环境变量\"><a class=\"markdownIt-Anchor\" href=\"#环境变量\">#</a> 环境变量</h3>\n<p>你可能想问，我怎么知道有哪些环境变量我可以使用。其实，每个镜像都配备了官方文档，你可以在上面寻找官方提供的环境变量，在<a href=\"https://hub.docker.com/\"> Docker hub</a> 上面搜索  <code>mysql</code>  找到最高  <code>star</code>  的那个镜像：</p>\n<img src=\"docker/mysql.png\" alt=\"mysql镜像\"/>\n<p>点进去，持续往下翻，直到你看到：</p>\n<img src=\"docker/mysql_doc.png\" alt=\"mysql镜像\"/>\n<p>现在你就知道了官方给我们提供了哪些环境变量。如图， <code>MYSQL_ROOT_PASSWORD</code>  代表着数据库的密码</p>\n<h2 id=\"如何查看运行的容器\"><a class=\"markdownIt-Anchor\" href=\"#如何查看运行的容器\">#</a> 如何查看运行的容器</h2>\n<p><code>docker</code>  提供了一个子命令，用于查看运行的容器：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker ps &lt;container&gt; <br></code></pre></td></tr></table></figure>\n<p>大概样式如下：</p>\n<img src=\"docker/docker_ps.png\" alt=\"运行中的容器\"/>\n<h2 id=\"启动-停止-删除\"><a class=\"markdownIt-Anchor\" href=\"#启动-停止-删除\">#</a> 启动、停止、删除</h2>\n<p>如果你想暂停一个容器，那么只需要使用如下命令，即可暂停容器：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker stop &lt;container-name&gt;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>请注意，即使你暂停了容器，该容器任然存在，只是没有在运行了而已</p>\n</blockquote>\n<p>如果此时你想重新启动这个容器，那么使用如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker start &lt;container-name&gt;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>请注意，不要使用  <code>docker run</code>  因为，该命令总是新创建一个容器，而不是启动原来的容器，请注意与  <code>docker start</code>  的区别</p>\n</blockquote>\n<p>如果你想删除一个容器，那么运行下面的命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker rm &lt;container-name&gt;<br></code></pre></td></tr></table></figure>\n<p>如果此时你的容器正在运行，那么依靠上面的命令你是无法删除的，使用如下命令进行强制删除：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">docker rm &lt;container-name&gt; -f<br></code></pre></td></tr></table></figure>\n<h1 id=\"数据卷volume\"><a class=\"markdownIt-Anchor\" href=\"#数据卷volume\">#</a> 数据卷 (volume)</h1>\n<h2 id=\"如何进入容器\"><a class=\"markdownIt-Anchor\" href=\"#如何进入容器\">#</a> 如何进入容器</h2>\n<p>之前提到容器相当于操作系统，每个操作系统都有它自己的文件系统，所以如何进入到容器内部操纵里面的文件呢？</p>\n<p>使用  <code>docker</code>  提供的如下子命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker exec<br></code></pre></td></tr></table></figure>\n<p>该命令会在容器内部运行你提供的命令，该命令会运行在默认的目录下，且必须保证命令是可执行，链式的或者引用的命令是无法执行的，例如</p>\n<ul>\n<li>该命令可以执行:  <code>docker exec -it my_container sh -c &quot;echo a &amp;&amp; echo b&quot;</code></li>\n<li>该命令不可以执行:  <code>docker exec -it my_container &quot;echo a &amp;&amp; echo b&quot;</code></li>\n</ul>\n<p>使用如下命令进入容器内部：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker exec -it &lt;container-name&gt; bash<br></code></pre></td></tr></table></figure>\n<p>回车后你会发现，主机名改变了，使用  <code>ls</code>  命令，你将会看到如  <code>linux</code>  一般的文件系统。</p>\n<p>此时你可能会迫不及待，打算执行一些操作，于是你新创建一个名为  <code>test</code>  的文件，然后尝试用  <code>vi</code>  命令进行编辑，可是当你执行过后会发现， <code>vi</code>  命令找不到。这是怎么回事呢？明明容器就如操作系统一样，应该也会包含所有的命令的啊。</p>\n<p>结论是：镜像所创建的环境仅仅会包含和镜像应用有关的命令，所有不会包含所有的命令。所有，你在有关  <code>mysql</code>  的容器中使用  <code>mysql</code>  命令会成功，而你在不包含  <code>mysql</code>  的容器中使用，则会失败。</p>\n<h2 id=\"和容器进行连接\"><a class=\"markdownIt-Anchor\" href=\"#和容器进行连接\">#</a> 和容器进行连接</h2>\n<p>如果有些命令无法使用，拿我想修改容器中的数据的时候该怎么办？  <code>docker</code>  提供了一个特性 —— 数据卷，来帮助我们完成这个操作。</p>\n<p>什么是数据卷？在操作系统中，万物皆文件，数据卷就是挂载载文件系统上的设备。像物理机上的硬盘就是数据卷。当然在  <code>docker</code>  中数据卷只是逻辑的。</p>\n<p>所以，该如何使用这个数据卷呢？相信你一定使用过  <code>u盘</code>  ，当你插上  <code>u盘</code>  后，你的文件系统就会将这个  <code>u盘</code>  挂载到文件系统上，你就能通过文件的形式访问  <code>u盘</code>  的数据。</p>\n<p>所以我们要做的就是，将  <code>docker</code>  容器中的文件看成  <code>u 盘</code>  将其挂载到我们的宿主机的文件系统上，然后就能通过宿主机修改容器的数据。这就是数据卷的作用。那么我们该如何使用？</p>\n<h2 id=\"挂载数据卷\"><a class=\"markdownIt-Anchor\" href=\"#挂载数据卷\">#</a> 挂载数据卷</h2>\n<blockquote>\n<p>数据卷只能在运行容器时进行挂载。</p>\n</blockquote>\n<p>在运行  <code>docker run</code>  时只需要添加一个选项即可，如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -d|--detach #-d参数代表后台运行，并打印容器Id，如果不加这个参数，那么执行这个命令后，你的命令行会卡住，无法输入命令<br>--name mysql #--name，为该容器分配一个名字<br>-p|--publish 3306:3306 #-p为该容器分配一个端口映射，由于外部无法直接访问容器内部，因此需要进行端口映射。代表着宿主机的3306端口映射到容器的3306端口<br>-e|--env TZ=Asia/Shanghai #-e为容器写入环境变量，前面提到容器本事其实就算一个操作系统，所以理应由环境变量，该环境变量由容器中的容器读写<br>-e MYSQL_ROOT_PASSWORD=123 <br>-v source:/var/lib/mysql #将名为source的数据卷与/var/lib/mysql相映射<br>mysql #镜像名<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>数据卷默认存放在： <code>/var/lib/docker/volumes/&lt;volume-name&gt;/_data</code>  目录下</p>\n</blockquote>\n<p>现在你就能在： <code>/var/lib/docker/volumes/source/_data</code>  下看到你挂载的数据卷了，里面包含了容器中  <code>/var/lib/mysql</code>  目录下的所有的文件</p>\n<p>当然你也可以运行以下命令来提前创建一个数据卷：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker volume create [volume-name]<br></code></pre></td></tr></table></figure>\n<p>如果你不指定数据卷的名字，那么会使用一段  <code>hash</code>  值来作为数据卷的名字。现在，请前往之前所说的那个目录下，你已经能看到这个数据卷了。当然，数据卷下面并没有任何数据，因为你没有进行挂载。然后你可以在运行容器时使用该数据卷的名字进行挂载。</p>\n<h3 id=\"自定义数据卷位置\"><a class=\"markdownIt-Anchor\" href=\"#自定义数据卷位置\">#</a> 自定义数据卷位置</h3>\n<p>如果你不想让数据卷放在默认位置下，你可以在运行容器时指定目录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -dp 80:80 <br>--name docker-demo<br>-v /root:/var/lib/nginx #我们在root目录下进行挂载<br>docker-demo <br></code></pre></td></tr></table></figure>\n<p>前外  <code>/root</code>  目录下，你就能看到这个数据卷</p>\n<blockquote>\n<p>注意自定义目录必须要以绝对路径起首，不然会被默认为默认数据卷</p>\n</blockquote>\n<h2 id=\"查看数据卷\"><a class=\"markdownIt-Anchor\" href=\"#查看数据卷\">#</a> 查看数据卷</h2>\n<p>你可以使用，如下命令查看所有的数据卷：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker volume ls<br></code></pre></td></tr></table></figure>\n<p>如果你想查看某个数据卷的详细信息，可以使用如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker volume inspect &lt;volume-name&gt;<br></code></pre></td></tr></table></figure>\n<h1 id=\"网络network\"><a class=\"markdownIt-Anchor\" href=\"#网络network\">#</a> 网络 (network)</h1>\n<p>现在让我考考你一个问题。如果现在有两个容器，一个是数据库，一个是服务器，服务器想要访问数据库怎么办呢。前面说到，容器是一个个隔离的环境，如何才能让容器之间通信呢？</p>\n<p>容器作为操作系统，当然有自己的<strong>网络</strong>。 <code>docker</code>  在运行的时候会初始化一张虚拟网卡，现在前往你的宿主机尝试一下  <code>ip addr</code>  命令，如果你的  <code>docker</code>  在运行中，不出意外你将会看到：</p>\n<img src=\"docker/net_adapter.png\" alt=\"docker的虚拟网卡\"/>\n<p>这就是  <code>docker</code>  生成的虚拟网卡。意味着容器本身之间也能进行<strong>通信</strong>。</p>\n<h2 id=\"使用默认的网络\"><a class=\"markdownIt-Anchor\" href=\"#使用默认的网络\">#</a> 使用默认的网络</h2>\n<p><code>docker</code>  会初始化一个  <code>docker0</code>  的网卡，分配一个名为  <code>bridge</code>  的默认网段。所有启动的容器将会默认使用这个网段，并分配一个  <code>ip</code>  地址，但 <code>docker</code>  官方并不推荐使用默认的网络，而是推荐 —— 自定义网络</p>\n<h2 id=\"自定义网络\"><a class=\"markdownIt-Anchor\" href=\"#自定义网络\">#</a> 自定义网络</h2>\n<p>在  <code>docker</code>  中只有同一网段的<strong>容器</strong>才能互相通信。你可以创建自定义的<strong>网络</strong>，然后将容器连接到这个自定义的网络上，一旦容器连接到同一个网络上，容器中间就能通过  <code>ip</code>  地址或者容器名进行通信。</p>\n<p><code>docker</code>  提供了用于创建网络的命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker network create &lt;network-name&gt;<br></code></pre></td></tr></table></figure>\n<p>该令会创建一个默认基于  <code>driver</code>  网卡的网络，该网络会被分配一个网段。</p>\n<h2 id=\"连接网络\"><a class=\"markdownIt-Anchor\" href=\"#连接网络\">#</a> 连接网络</h2>\n<p>现在你可以在运行容器的时候，连接指定的网络：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -d|--detach #-d参数代表后台运行，并打印容器Id，如果不加这个参数，那么执行这个命令后，你的命令行会卡住，无法输入命令<br>--name mysql #--name，为该容器分配一个名字<br>-p|--publish 3306:3306 #-p为该容器分配一个端口映射，由于外部无法直接访问容器内部，因此需要进行端口映射。代表着宿主机的3306端口映射到容器的3306端口<br>-e|--env TZ=Asia/Shanghai #-e为容器写入环境变量，前面提到容器本事其实就算一个操作系统，所以理应由环境变量，该环境变量由容器中的容器读写<br>-e MYSQL_ROOT_PASSWORD=123 <br>--network=&lt;network-name&gt;<br>mysql #镜像名<br></code></pre></td></tr></table></figure>\n<p>一旦你运行这个容器，该容器会加入这个网络，并分配一个  <code>ip</code>  地址</p>\n<p>或者你可以为一个已经运行的容器连接网络：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker network connet &lt;network-name&gt; &lt;container-name&gt;<br></code></pre></td></tr></table></figure>\n<h1 id=\"层layer\"><a class=\"markdownIt-Anchor\" href=\"#层layer\">#</a> 层 (layer)</h1>\n<p>了解完上述概念，相信你已经能运行一个自己的容器了。</p>\n<p>现在让我们来思考一个问题：如果我们拉取两个镜像 —— 一个是只有操作系统的镜像，另外一个是建立在该操作系统上的  <code>jre</code>  镜像。那么，拉取完操作系统镜像后，并在拉取  <code>jre</code>  镜像时会再继续拉取一个包含操作系统的  <code>jre</code>  环境吗？</p>\n<p>答案是不会的，这就涉及到了  <code>docker</code>  的一个重要概念 —— <strong>层 (layer)</strong>。 <code>docker</code>  将容器成了多个层，层与层之间能够复用。如果两个镜像包含了相同的层，那么相同的层将不会进行重复拉取而是复用，这就增加了镜像的复用性，减少了镜像的空间大小。每个镜像都可以建立在某个层上，对某个层进行扩展和补充形成新的层。</p>\n<p>我们把那些提供基础环境的层叫做：基础镜像</p>\n<h1 id=\"自定义镜像\"><a class=\"markdownIt-Anchor\" href=\"#自定义镜像\">#</a> 自定义镜像</h1>\n<p>使用  <code>dcoker</code>  我们可以自定义镜像，但我们不用去实现镜像的细节，我们只需要告诉  <code>docker</code>  这个镜像需要什么，然后  <code>docker</code>  帮我们组装这个镜像。那么，我们如何告诉  <code>docker</code>  我们需要什么呢？ <code>docker</code>  提供了一个文件 ——  <code>Dockerfile</code>  来让我们编写自定义镜像的细节。</p>\n<h2 id=\"编写dockerfile\"><a class=\"markdownIt-Anchor\" href=\"#编写dockerfile\">#</a> 编写 Dockerfile</h2>\n<p><code>Dockerfile</code>  常用的命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">FROM #用于设置容器的基础镜像，用于应用运行的基础环境<br>WORKDIR &lt;path&gt; #容器的工作目录，当你进入容器的文件系统后，默认为该目录<br>COPY &lt;src&gt; &lt;target&gt;  #将宿主机的文件拷贝至容器的目录下<br>RUN #在构建镜像时执行一些命令<br>EXPOSE #暴露的端口，通知Docker监听的端口<br>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] #在容器运行后执行<br>ENV key=value... #添加环境变量<br></code></pre></td></tr></table></figure>\n<h2 id=\"cmd\"><a class=\"markdownIt-Anchor\" href=\"#cmd\">#</a> CMD</h2>\n<p>当你运行时容器，会执行  <code>CMD</code>  给出的指令，公有三种形式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] #executable形式：executable是执行的命令，param时给命令的参数<br>CMD [&quot;param1&quot;,&quot;param2&quot;] #param会传递给ENTRYPOINT<br>CMD command param1 param2 (shell form) #shell形式，默认用shell命令，shell类型默认为sh<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>只能存在一条  <code>CMD</code>  语句，如果存在多条，只使用最后一条语句</p>\n</blockquote>\n<h2 id=\"entrypoint\"><a class=\"markdownIt-Anchor\" href=\"#entrypoint\">#</a> ENTRYPOINT</h2>\n<p>与  <code>CMD</code>  类似，共有两种形式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] #executable形式：executable是执行的命令，param时给命令的参数<br>ENTRYPOINT command param1 param2  #shell形式，默认用设定的shell类型去执行，shell类型默认为sh<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>只能存在一条  <code>ENTRYPOINT</code>  语句，如果存在多条，只使用最后一条语句</p>\n</blockquote>\n<blockquote>\n<p><code>CMD</code>  与  <code>ENTRYPOINT</code>  不同之处在于， <code>ENTRYPOINT</code>  不可以被  <code>docker run</code>  后的参数覆盖，会把  <code>docker run</code>  后面的参数传递给  <code>ENTRYPOINT</code>  指定的参数。</p>\n</blockquote>\n<p>以下为实例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dockerfile\"><span class=\"hljs-keyword\">FROM</span> node:<span class=\"hljs-number\">18</span>-alpine <span class=\"hljs-comment\">#dockerfile开头通常为FROM以引入基础环境</span><br><br><span class=\"hljs-keyword\">WORKDIR</span><span class=\"language-bash\"> /app <span class=\"hljs-comment\">#设置工作路径 /app</span></span><br><br><span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> package*.json ./ <span class=\"hljs-comment\">#拷贝待用package的json文件至 /app 下面</span></span><br><br><br><span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> ./src ./src <span class=\"hljs-comment\">#仍然时拷贝</span></span><br><span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> ./public ./public</span><br><br><span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> npm install \\ <span class=\"hljs-comment\">#运行命令</span></span><br>    &amp;&amp; npm install -g serve \\<br>    &amp;&amp; npm <span class=\"hljs-keyword\">run</span><span class=\"language-bash\"> build \\</span><br><span class=\"language-bash\">    &amp;&amp; <span class=\"hljs-built_in\">rm</span> -fr node_modules</span><br> <br><span class=\"hljs-keyword\">EXPOSE</span> <span class=\"hljs-number\">3000</span> <span class=\"hljs-comment\">#暴露端口</span><br><br><br><span class=\"hljs-keyword\">CMD</span><span class=\"language-bash\"> [ <span class=\"hljs-string\">&quot;serve&quot;</span>, <span class=\"hljs-string\">&quot;-s&quot;</span>, <span class=\"hljs-string\">&quot;build&quot;</span> ] <span class=\"hljs-comment\">#容器运行时执行命令</span></span><br></code></pre></td></tr></table></figure>\n",
            "tags": [
                "docker"
            ]
        }
    ]
}