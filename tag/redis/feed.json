{
    "version": "https://jsonfeed.org/version/1",
    "title": "Funkynoob的个人博客 • All posts by \"redis\" tag",
    "description": "亿点点心得",
    "home_page_url": "https://blog.riversea.top",
    "items": [
        {
            "id": "https://blog.riversea.top/2024/03/18/redis/",
            "url": "https://blog.riversea.top/2024/03/18/redis/",
            "title": "redis",
            "date_published": "2024-03-18T13:20:07.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"持久化\"><a class=\"markdownIt-Anchor\" href=\"#持久化\">#</a> 持久化</h1>\n<p><code>redis</code>  提供了持久化策略， <code>redis</code>  会将内存中的数据持久化到磁盘中存储避免了断电之后，内存中的数据消失。当再次重启  <code>redis</code>  服务器后， <code>redis</code>  会读取磁盘文件加载进内存，将数据恢复至之前的状态。</p>\n<p><code>redis</code>  提供了四种持久化策略：</p>\n<ul>\n<li><strong> <code>RDB</code> </strong> ( <code>Redis Database</code> ): 使用该策略， <code>redis</code>  会为数据库的数据在指定的时间间隔中生成一份时间点快照。</li>\n<li><strong> <code>AOF</code> </strong> (Append Only File): 使用该策略， <code>redis</code>  会记录每次服务器收到的<strong>写</strong>的操作。这些操作会在服务器启动的时候重新运行以便能够重新构建起原始的数据库。这些<strong>写</strong>操作会按照  <code>redis</code>  的协议以同样的格式被日志记录</li>\n<li><strong> <code>No persistence</code> </strong>: 你可以完全禁用持久化。这有时候是在缓存的时候使用。</li>\n<li><strong> <code>RDB + AOF</code> </strong>: 你也可以在在同一次运行中结合使用  <code>AOF</code>  和  <code>RDB</code>  两种策略</li>\n</ul>\n<h2 id=\"rdb\"><a class=\"markdownIt-Anchor\" href=\"#rdb\">#</a> RDB</h2>\n<p>实现类似照片记录效果的方式，就是把某一时刻的数据和状态以文件的形式写到磁盘上，也就是快照。这样一来即使故障宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为  <code>RDB</code>  文件 (文件名默认为： <code>dump.rdb</code> )，其中， <code>RDB</code>  就是  <code>Redis DataBase</code>  的缩写。</p>\n<p>当服务器再次重启后，服务器将会读取这个快照文件，恢复整个数据集。</p>\n<h3 id=\"如何开启rdb\"><a class=\"markdownIt-Anchor\" href=\"#如何开启rdb\">#</a> 如何开启 RDB</h3>\n<p>进入  <code>redis</code>  配置文件，大概在  <code>418</code>  行，你将会看到如下的话：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">################################ SNAPSHOTTING  ################################<br><br># Save the DB to disk.<br>#<br><span class=\"hljs-meta\"># save <span class=\"hljs-string\">&lt;seconds&gt;</span> <span class=\"hljs-string\">&lt;changes&gt;</span> [<span class=\"hljs-string\">&lt;seconds&gt;</span> <span class=\"hljs-string\">&lt;changes&gt;</span> ...]</span><br>#<br># Redis will save the DB <span class=\"hljs-keyword\">if</span> the given number of seconds elapsed and it<br><span class=\"hljs-meta\"># surpassed the given number of write operations against the DB.</span><br>#<br># Snapshotting can be completely disabled with a single empty <span class=\"hljs-built_in\">string</span> argument<br><span class=\"hljs-meta\"># as in following example:</span><br><span class=\"hljs-meta\"># save <span class=\"hljs-string\">&quot;&quot;</span></span><br><br>#<br># Unless specified otherwise, by <span class=\"hljs-keyword\">default</span> Redis will save the DB:<br>#   * After <span class=\"hljs-number\">3600</span> seconds (an hour) <span class=\"hljs-keyword\">if</span> at least <span class=\"hljs-number\">1</span> change was performed<br>#   * After <span class=\"hljs-number\">300</span> seconds (<span class=\"hljs-number\">5</span> minutes) <span class=\"hljs-keyword\">if</span> at least <span class=\"hljs-number\">100</span> changes were performed<br>#   * After <span class=\"hljs-number\">60</span> seconds <span class=\"hljs-keyword\">if</span> at least <span class=\"hljs-number\">10000</span> changes were performed<br>#<br></code></pre></td></tr></table></figure>\n<p>原来  <code>redis</code>  默认已经开启了  <code>RDB</code>  且遵守以下策略：</p>\n<ul>\n<li>在 60 秒之后，如果至少有 10000 次改变被执行</li>\n<li>在 5 分钟之后，如果至少有 100 次变化被执行</li>\n<li>在 1 小时之后，如果至少有 1 次变化被执行</li>\n</ul>\n<p>如果上面的规定至少有一个被遵守， <code>redis</code>  将会自动触发  <code>RDB</code>  持久化，为此刻的数据生成快照，然后将其保存在为以  <code>rdb</code>  为后缀的二进制文件，文件名默认为 <code>dump.rdb</code> 。</p>\n<p>你可以以如下的形式重载  <code>redis</code>  默认的  <code>RDB</code>  持久化规则：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">save &lt;seconds&gt; &lt;changes&gt; [&lt;seconds&gt; &lt;changes&gt; ...]<br></code></pre></td></tr></table></figure>\n<p><code>redis</code>  会当  <code>&lt;seconds&gt;</code>  秒消逝，并且累计的  <code>&lt;changes&gt;</code>  个数的写操作被执行后，自动保存数据库。</p>\n<blockquote>\n<p>注意是在每个时间区间内，一旦写操作<strong>累积</strong>到了设定的数就会触发</p>\n</blockquote>\n<h3 id=\"禁用rdb\"><a class=\"markdownIt-Anchor\" href=\"#禁用rdb\">#</a> 禁用 RDB</h3>\n<p>在配置文件中可以使用一个简单的配置来禁用  <code>RDB</code>  持久化策略，在  <code>redis</code>  中有以下描述：</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\"># Snapshotting can be completely disabled <span class=\"hljs-keyword\">with</span> a single empty string argument<br># <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">in</span> following example:<br>快照化可以用下面的例子，使用单个空的字符串参数来完全禁用：<br># save <span class=\"hljs-string\">&quot;&quot;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"配置rdb\"><a class=\"markdownIt-Anchor\" href=\"#配置rdb\">#</a> 配置 RDB</h3>\n<p>如何更改默认文件名，来到配置文件的大概  <code>481</code>  行：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-comment\"># The filename where to dump the DB</span><br><span class=\"hljs-attribute\">dbfilename</span> dump.rdb<br></code></pre></td></tr></table></figure>\n<p>你可以通过更改  <code>dbfilename</code>  的值来修改  <code>RDB</code>  文件的名字。</p>\n<p>如何更改文件存储路径，来到配置文件的大概  <code>502</code>  行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><br><span class=\"hljs-comment\"># The working directory.</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># The DB will be written inside this directory, with the filename specified</span><br><span class=\"hljs-comment\"># above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># The Append Only File will also be created inside this directory.</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># Note that you must specify a directory here, not a file name.</span><br><span class=\"hljs-built_in\">dir</span> ./<br></code></pre></td></tr></table></figure>\n<p>你可以通过修改  <code>dir</code>  的值来修改  <code>RDB</code>  的存储路径。</p>\n<h3 id=\"手动保存\"><a class=\"markdownIt-Anchor\" href=\"#手动保存\">#</a> 手动保存</h3>\n<p><code>redis</code>   提供了两个命令来手动保存  <code>RDB</code>  文件： <code>save</code>  ， <code>bgsave</code>  。</p>\n<p><code>save</code>  以同步的方式执行保存操作，会阻塞进程。</p>\n<p><code>bgsave</code>  以异步的方式执行保存操作，不会阻塞进程</p>\n<p>当你运行上述命令时，会为当前  <code>redis</code>   实例中的所有数据生成一个以  <code>RDB</code>  文件的格式的快照。</p>\n<p>你绝对不应该在生产环境中使用  <code>save</code>   命令，当你运行该命令时，会阻塞所有客户端的请求，服务器将不再接受所有客户端的请求，直到保存操作结束。</p>\n<p>实际上， <code>redis</code>  的自动保存正是调用的  <code>bgsave</code></p>\n<blockquote>\n<p>在生产环境中必须使用  <code>bgsave</code></p>\n</blockquote>\n<h3 id=\"rdb的优点\"><a class=\"markdownIt-Anchor\" href=\"#rdb的优点\">#</a> RDB 的优点</h3>\n<ul>\n<li><code>RDB</code>  是一个非常紧凑的单时间点代表  <code>Redis</code>  数据的单文件。 <code>RDB</code>  文件非常适合于备份。举个例子，你可能想每个小时归档你的  <code>RDB</code>  文件，或者每天保存一次  <code>RDB</code>  快照。这样允许你非常轻松的恢复不同版本的数据以防灾难的发生。</li>\n<li><code>RDB</code>  非常适合于灾难性的数据恢复，因为单文件的结构可以被运输至远程的数据中心。</li>\n<li><code>RDB</code>  最大化  <code>redis</code>  的功能，因为  <code>redis</code>  的父进程为了完成持久化的唯一的工作就是  <code>fork</code>  子进程，然后剩余的工作都交给子进程。父进程并不会执行  <code>I/O</code>  操作。</li>\n<li>对比  <code>AOF</code> ， <code>RDB</code>  在大数据的情况下，能够进行快速重启。</li>\n</ul>\n<h3 id=\"rdb的缺点\"><a class=\"markdownIt-Anchor\" href=\"#rdb的缺点\">#</a> RDB 的缺点</h3>\n<ul>\n<li>\n<p><code>RDB</code>  不是一个好选择，如果你想减少数据丢失的可能性以防  <code>redis</code>  异常的停止工作。你可以配置不同的  <code>RDB</code>  创建的时间点。然而，你会经常每 5 分钟或者更久的时间创建一个  <code>RDB</code>   快照，所以在   <code>redis</code>   没有正常进行  <code>shutdown</code>  的莫名情况停止工作的情况下，你应该准备好丢失最新几分钟的数据</p>\n</li>\n<li>\n<p><code> RDB</code>  需要经常调用  <code>fork()</code>  以使用子进程进行持久化。 <code>fork()</code>  有时会很消耗时间，如果数据库的我数据很大的话，并且如果数据很大，且  <code>cpu</code>  的性能不是很好，将会导致  <code>redis</code>  在几微秒甚至 1 秒的时间停止服务客户端。 <code>AOF</code>  也会使用  <code>fork()</code>  但是不会如此频繁，并且你也可以自定义重新写入日志的频率且不用担心任何耐用性的损失。</p>\n</li>\n</ul>\n<h3 id=\"数据检查\"><a class=\"markdownIt-Anchor\" href=\"#数据检查\">#</a> 数据检查</h3>\n<p><code>redis</code>  提供了一个工具用来检查  <code>RDB</code>   文件的格式是否正确：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis－check－rdb &lt;/path/to/rdb/file&gt;<br></code></pre></td></tr></table></figure>\n<p>如果  <code>RDB</code>  文件损坏，该命令能检查出来。如果加载坏的  <code>RDB</code>  文件，那么  <code>redis</code>  客户端将无法执行命令，会弹出  <code>not connected</code>  字样</p>\n<h2 id=\"aof\"><a class=\"markdownIt-Anchor\" href=\"#aof\">#</a> AOF</h2>\n<p>快照不总是耐用的。如果你的计算机上的正在运行的  <code>redis</code>  停止了、断电了、或者你意外地使用  <code>kill －9</code>   杀死了你的实例，最新写入  <code>redis</code>  的数据将会丢失。</p>\n<p><code>AOF</code>  是  <code>RDB</code>  的一个更充满耐用性的替代品。在  <code>1.1</code>  版本开始了使用。</p>\n<p><code>AOF</code>  以日志的形式记录每一次 ** 写操作，** 且不记录任何形式的读操作。当服务器重新启动的时候会读取日志记录，重新执行以构建原来的数据。</p>\n<h3 id=\"开启aof\"><a class=\"markdownIt-Anchor\" href=\"#开启aof\">#</a> 开启 AOF</h3>\n<p><code>redis</code>  没有默认开启  <code>AOF</code>  ，需要手动开启。</p>\n<p>进入配置文件，大概  <code>1381</code>  行</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-comment\"># AOF and RDB persistence can be enabled at the same time without problems.</span><br><br><span class=\"hljs-comment\"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><br><span class=\"hljs-comment\"># with the better durability guarantees.</span><br><br><span class=\"hljs-comment\">#</span><br><br><span class=\"hljs-comment\"># Please check https://redis.io/topics/persistence for more information.</span><br><br>appendonly <span class=\"hljs-literal\">no</span><br></code></pre></td></tr></table></figure>\n<p>将  <code>appendonly</code>  的值改为  <code>yes</code>  则代表开启了 <code>AOF</code>  。</p>\n<p>由文档注释可知，如果你开启了  <code>AOF</code>  ，那么每次服务器启动的时候就只会加载  <code>AOF</code>  文件，不管是否开启了  <code>RDB</code>  持久化。</p>\n<h3 id=\"aof文件\"><a class=\"markdownIt-Anchor\" href=\"#aof文件\">#</a> AOF 文件</h3>\n<p>自  <code>redis 7.0.0</code>  开始， <code>redis</code>  使用<strong>多部分  <code>AOF</code>  机制</strong>。这是什么呢？原始的单  <code>AOF</code>  文件被分割为：</p>\n<p><code>base</code>  文件 (最多只有一个)：它是在创建文件时表示数据集完整状态的快照，可以为  <code>RDB</code>  或者  <code>AOF</code>  格式</p>\n<p><code>incremental</code>  文件 (可能会有多个)：包含额外的被应用在数据库的跟随旧文件的命令</p>\n<p>这两个文件会被放进一个分离的路径且会被  <code>manifest</code>  文件追踪。</p>\n<h4 id=\"文件存放位置\"><a class=\"markdownIt-Anchor\" href=\"#文件存放位置\">#</a> 文件存放位置</h4>\n<p>上述三种文件的存放位置，同样可以由配置文件进行配置，在配置文件大概  <code>1404</code>  行：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-comment\"># Append-only file names are created by Redis following a specific pattern.</span><br><span class=\"hljs-comment\"># The file name&#x27;s prefix is based on the &#x27;appendfilename&#x27; configuration</span><br><span class=\"hljs-comment\"># parameter, followed by additional information about the sequence and type.</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># For example, if appendfilename is set to appendonly.aof, the following file</span><br><span class=\"hljs-comment\"># names could be derived:</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># - appendonly.aof.1.base.rdb as a base file.</span><br><span class=\"hljs-comment\"># - appendonly.aof.1.incr.aof, appendonly.aof.2.incr.aof as incremental files.</span><br><span class=\"hljs-comment\"># - appendonly.aof.manifest as a manifest file.</span><br><br><span class=\"hljs-attribute\">appendfilename</span> <span class=\"hljs-string\">&quot;appendonly.aof&quot;</span><br><br><span class=\"hljs-comment\"># For convenience, Redis stores all persistent append-only files in a dedicated</span><br><span class=\"hljs-comment\"># directory. The name of the directory is determined by the appenddirname</span><br><span class=\"hljs-comment\"># configuration parameter.</span><br><br>appenddirname <span class=\"hljs-string\">&quot;appendonlydir&quot;</span><br></code></pre></td></tr></table></figure>\n<p>根据注释我们可以知道， <code>AOF</code>  文件名字遵守一个格式：由  <code>appendfilename</code>  的值为前缀，随后更随着序列号和类型，默认的名字为：</p>\n<ul>\n<li><code>appendonly.aof.1.base.rdb</code> ： <code>base</code>  文件</li>\n<li><code>appendonly.aof.1.incr.aof</code> ,  <code>appendonly.aof.2.incr.aof</code> ： <code>increment</code>  文件</li>\n<li><code>appendonly.aof.manifest</code> ： <code>manifest</code>  文件</li>\n</ul>\n<p>每次进行写回后， <code>AOF</code>  文件的序列号将会进行增加，开始序号为 1。</p>\n<ul>\n<li>\n<p>修改  <code>appendfilename</code>  值来修改文件名的前缀</p>\n</li>\n<li>\n<p>修改  <code>appenddirname</code>  的值来修改存放路径。</p>\n</li>\n</ul>\n<p>注意在  <code>redis 7</code>  之后  <code>AOF</code>  文件的存放路径由  <code>dir</code>  +  <code>appenddirname</code>  一起决定，即会在  <code>RDB</code>  文件的存放路径中，放一个隔离的  <code>appenddirname</code>  的目录来存放  <code>AOF</code>  文件</p>\n<h3 id=\"写回策略\"><a class=\"markdownIt-Anchor\" href=\"#写回策略\">#</a> 写回策略</h3>\n<p><code>redis</code>  支持三种写回策略：</p>\n<ul>\n<li>\n<p><code>Always</code> ：同步写回，每个写命令执行完立刻同步地将日志写回磁盘。这个策略会导致服务器非常非常的慢，当很多客户端同时请求时，客户端将会不得不等待服务器一条命令一条命令写回后再进行回复，但该策略也会很安全。</p>\n</li>\n<li>\n<p><code>everysec</code> ：每秒写回，每个写命令执行完，只是先把日志写到  <code>AOF</code>  文件的内存缓冲区，每隔  <code>1</code>  秒把缓冲区中的内容写入磁盘。该策略已经足够快了，但是你可能会丢失 1 秒的数据如果服务器宕机了的话。</p>\n</li>\n<li>\n<p><code>no</code> ：操作系统控制的写回，每个写命令执行完，只是先把日志写到  <code>AOF</code>  文件的内存缓冲区，由操作系统决定何时将缓冲区的数据写回磁盘。该此略会更快，但会很不安全。通常， <code>linux</code>  会每 30 秒将数据写回磁盘，但这取决于内核。</p>\n</li>\n</ul>\n<p>我们进入配置文件，大概 1448 行：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-comment\"># appendfsync always</span><br><span class=\"hljs-attribute\">appendfsync</span> everysec<br><span class=\"hljs-comment\"># appendfsync no</span><br></code></pre></td></tr></table></figure>\n<p>我们可以通过修改  <code>appendfsync</code>  的值来修改写回策略，根据配置文件我们可以了解到  <code>redis</code>  默认且推荐的策略是  <code>everysec</code>  ，该策略兼具速度并且相对的安全。</p>\n<h3 id=\"日志重写\"><a class=\"markdownIt-Anchor\" href=\"#日志重写\">#</a> 日志重写</h3>\n<p><code>AOF</code>  会随着写操作的次数而变得越来越大。举个例子，如果你增加了一个计数器 100 次，你会都得到一个包含了最终值的键，但是 100 次操作全部进入了你的  <code>AOF</code>  文件，而其他 99 个操作不需要参入重建现在状态的过程。</p>\n<p>重写是完全安全的。当  <code>Redis</code>  继续追加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪， <code>Redis</code>  就会切换这两个文件并开始追加到新文件。</p>\n<p>所以  <code>Redis</code>  支持一个有趣的功能：它能够在后台重建 AOF 而不中断对客户端的服务。每当您发出  <code>BGREWRITEAOF</code>  命令时， <code>Redis</code>  都会写入在内存中重建当前数据集所需的最短命令序列。 如果您在  <code>Redis 2.2</code>  中使用  <code>AOF</code> ，则需要时不时地运行  <code>BGREWRITEAOF</code> 。因为自从  <code>Redis 2.4</code>  开始才能够自动触发日志重写。</p>\n<p>从  <code>Redis 7.0.0</code>  开始，当计划进行  <code>AOF</code>  重写时， <code>Redis</code>  父进程会打开一个新的增量  <code>AOF</code>  文件来继续写入。子进程执行重写逻辑并生成新的  <code>base AOF</code> 。 <code>Redis</code>  将使用临时清单文件来跟踪新生成的基础文件和增量文件。 当它们准备好时， <code>Redis</code>  将执行原子替换操作以使这个临时清单文件生效。为了避免  <code>AOF</code>  重写重复失败和重试时创建大量增量文件的问题， <code>Redis</code>  引入了  <code>AOF</code>  重写限制机制，以确保失败的  <code>AOF</code>  重写以越来越慢的速度重试。</p>\n<p>既然说到  <code>Redis 2.4</code>  以上地版本会自动进行重写，那么如何配置呢，来到配置文件大概 1471 行：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-comment\"># Automatic rewrite of the append only file.</span><br><span class=\"hljs-comment\"># Redis is able to automatically rewrite the log file implicitly calling</span><br><span class=\"hljs-comment\"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># This is how it works: Redis remembers the size of the AOF file after the</span><br><span class=\"hljs-comment\"># latest rewrite (if no rewrite has happened since the restart, the size of</span><br><span class=\"hljs-comment\"># the AOF at startup is used).</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># This base size is compared to the current size. If the current size is</span><br><span class=\"hljs-comment\"># bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class=\"hljs-comment\"># you need to specify a minimal size for the AOF file to be rewritten, this</span><br><span class=\"hljs-comment\"># is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class=\"hljs-comment\"># is reached but it is still pretty small.</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># Specify a percentage of zero in order to disable the automatic AOF</span><br><span class=\"hljs-comment\"># rewrite feature.</span><br><br><span class=\"hljs-attribute\">auto</span>-aof-rewrite-percentage <span class=\"hljs-number\">100</span><br><span class=\"hljs-attribute\">auto</span>-aof-rewrite-min-size <span class=\"hljs-number\">64</span>mb<br></code></pre></td></tr></table></figure>\n<p>由注释可知， <code>redis</code>  会自动调用  <code>BGREWRITEAOF</code>  命令当  <code>AOF</code>  文件的大小到达指定的百分比时。 <code>redis</code>  会记住最新一次重写时的文件大小，如果没有发生重写，那么当服务器重启之后的  <code>AOF</code>  文件的大小将会被使用。这个被记住的大小将会被与现在的大小进行比较，如果现在文件的大小超过了指定的百分比，重写将会被触发。并且，你需要指定要重写的  <code>AOF</code>  文件的最小大小，这对于避免重写  <code>AOF</code>  文件很有用，因为即使达到百分比增加但仍然很小。</p>\n<p>指定百分比为 0 可以禁用自动  <code>AOF</code></p>\n<p>现在你可以指定  <code>auto-aof-rewrite-percentage</code>  的值来指定百分比，指定  <code>auto-aof-rewrite-min-size</code>  的值来指定最小的文件大小。</p>\n<h4 id=\"手动重写\"><a class=\"markdownIt-Anchor\" href=\"#手动重写\">#</a> 手动重写</h4>\n<p>你可以主动使用  <code>BGREWRITEAOF</code>  命令来执行重写操作，事实上，自动的重写操作也是由  <code>redis</code>  客户端向  <code>redis</code>  服务器发送这个命令完成的。</p>\n<h3 id=\"数据检查-2\"><a class=\"markdownIt-Anchor\" href=\"#数据检查-2\">#</a> 数据检查</h3>\n<p><code>redis</code>  提供了工具来检查  <code>AOF</code>  文件的格式是否正确：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-check-aof &lt;/path/to/aof&gt;<br></code></pre></td></tr></table></figure>\n<p>如果提示  <code>AOF</code>  文件的格式出错，那么你可以通过添加  <code>--fix</code>  选项来修复该文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-check-aof --fix &lt;/path/to/aof&gt; <br></code></pre></td></tr></table></figure>\n<h2 id=\"混合模式\"><a class=\"markdownIt-Anchor\" href=\"#混合模式\">#</a> 混合模式</h2>\n<p><code>redis</code>  支持  <code>RDB</code>  和  <code>AOF</code>  混合模式。</p>\n<p>如何开启混合模式，来到配置文件大概  <code>1516</code>  行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-comment\"># Redis can create append-only base files in either RDB or AOF formats. Using</span><br><span class=\"hljs-comment\"># the RDB format is always faster and more efficient, and disabling it is only</span><br><span class=\"hljs-comment\"># supported for backward compatibility purposes.</span><br>aof-use-rdb-preamble <span class=\"hljs-literal\">yes</span><br></code></pre></td></tr></table></figure>\n<p><code>aof-use-rdb-preamble</code>  用于开启混合模式，可见混合模式是默认开启的，代表着，如果你启用了  <code>RDB</code>  和  <code>AOF</code> ，那么将进入混合模式。</p>\n<h3 id=\"原理\"><a class=\"markdownIt-Anchor\" href=\"#原理\">#</a> 原理</h3>\n<p>当你开启混合模式时，服务器启动时将会进行一次快照存储，然后使用  <code>AOF</code>  记录每一次写操作。当  <code>AOF</code>  达到重写条件时，将会将最新的数据存储为新的  <code>RDB</code>  记录。这样的话，重启服务的时候会从  <code>RDB</code>  和  <code>AOF</code>  两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。简单来说：混合持久化方式产生的文件一部分是  <code>RDB</code>  格式，一部分是  <code>AOF</code>  格式</p>\n<h2 id=\"no-persistence\"><a class=\"markdownIt-Anchor\" href=\"#no-persistence\">#</a> No persistence</h2>\n<p>禁用用  <code>AOF</code>  和  <code>RDB</code>  ，仅仅把  <code>redis</code>  当作缓存来用。</p>\n<h1 id=\"事务\"><a class=\"markdownIt-Anchor\" href=\"#事务\">#</a> 事务</h1>\n<p><code>redis</code>  支持事务。在事务中  <code>redis</code>  允许在一步中运行完所有的命令。整个事务围绕着 4 个命令： <code>exec</code> 、 <code>multi</code> 、 <code>discard</code> 、 <code>watch</code></p>\n<p><code>redis</code>  的事务有两个特点：</p>\n<ul>\n<li>所有在事务中的命令将会被序列化并被顺序执行。在事务执行时其他客户端的请求将不会被处理。这个特点保证了事务中的所有命令将会以一个独立的单步操作的方式执行。</li>\n<li><code>exec</code>  命令会触发事务中命令的执行，所以如果客户端在命令执行前就失去连接，那么事务将不会开始执行。当你使用  <code>AOF</code>  持久化时， <code>redis</code>  在事务执行后会尝试把事务写进文件里。如果  <code>redis</code>  服务器宕机了，那么可能只有一部分的事务命令写入文件。 <code>reids</code>  服务器重新启动的时候会检查  <code>AOF</code>  文件的格式，如果有错误将会退出。可以使用  <code>redis-check-aof</code>  工具尝试移除一部分事务来修复  <code>AOF</code>  文件。</li>\n</ul>\n<h2 id=\"开启事务\"><a class=\"markdownIt-Anchor\" href=\"#开启事务\">#</a> 开启事务</h2>\n<p>使用  <code>multi</code>  命令开启事务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">127.0.0.1:6379&gt; MULTI<br>OK<br></code></pre></td></tr></table></figure>\n<p>成功开启事务将会以  <code>ok</code>  的形式返回</p>\n<h3 id=\"序列化命令\"><a class=\"markdownIt-Anchor\" href=\"#序列化命令\">#</a> 序列化命令</h3>\n<p>在事务的状态下，输入的所有命令将会以队列的形式进行记忆。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">127.0.0.1:6379(TX)&gt; INCR foo<br>QUEUED<br>127.0.0.1:6379(TX)&gt; INCR bar<br>QUEUED<br></code></pre></td></tr></table></figure>\n<p>每次命令的返回值  <code>queued</code>  表示该命令已经加入队列，但此时该命令并没有执行。</p>\n<h3 id=\"执行命令\"><a class=\"markdownIt-Anchor\" href=\"#执行命令\">#</a> 执行命令</h3>\n<p>当完成了所有命令的输入后，使用  <code>exec</code>  命令顺序执行事务中的所有命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">127.0.0.1:6379(TX)&gt; EXEC<br>1) (integer) 1<br>2) (integer) 1<br></code></pre></td></tr></table></figure>\n<p>每条命令的结果，将会以一个数组的形式进行返回。</p>\n<h3 id=\"退出事务\"><a class=\"markdownIt-Anchor\" href=\"#退出事务\">#</a> 退出事务</h3>\n<p>在事务的状态下，如果你想退出事务可以使用  <code>discard</code>  进行退出</p>\n<blockquote>\n<p>Note</p>\n<p>在  <code>redis</code>  中不支持回滚，因为回滚会影响  <code>redis</code>  的表现和简单</p>\n</blockquote>\n<h2 id=\"错误\"><a class=\"markdownIt-Anchor\" href=\"#错误\">#</a> 错误</h2>\n<p>在  <code>redis</code>  的事务中有两个可能发生的错误：事务开始前的错误和事务开始后的错误。</p>\n<h3 id=\"事务开始前\"><a class=\"markdownIt-Anchor\" href=\"#事务开始前\">#</a> 事务开始前</h3>\n<p>在事务开始前，也就是正在将命令加入队列时，有些错误将会导致命令无法加入队列中。例如：错误的命令 (命令的参数不对或者命令本身的名字不对)、内存溢出的情况 (如果你配置了服务器的内存限制)。</p>\n<p>如果在事务执行前发生了错误，那么在执行  <code>exec</code>  命令后， <code>redis</code>  将会返回  <code>error</code>  并拒绝执行事务，并退出事务状态：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; set<br>(error) ERR wrong number of arguments for &#x27;set&#x27; command<br>127.0.0.1:6379(TX)&gt; exec<br>(error) EXECABORT Transaction discarded because of previous errors.<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>\n<h3 id=\"事务开始后\"><a class=\"markdownIt-Anchor\" href=\"#事务开始后\">#</a> 事务开始后</h3>\n<p>在调用了  <code>exec</code>  命令执行事务后，如果某些命令执行发生了错误比如：让一个字符串进行自增，那么该命令将会返回  <code>error</code>  ，但这并不会影响其他的命令的执行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">127.0.0.1:6379(TX)&gt; incr k1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; incr k<br>QUEUED<br>127.0.0.1:6379(TX)&gt; exec<br>1) (error) ERR value is not an integer or out of range<br>2) (integer) 4<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>上述结果得知： <code>redis</code>  的事务并没有原子性</p>\n</blockquote>\n<h2 id=\"乐观锁\"><a class=\"markdownIt-Anchor\" href=\"#乐观锁\">#</a> 乐观锁</h2>\n<p><code>redis</code>  使用  <code>watch</code>  命令来实现乐观锁。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">watch &lt;key&gt; [key...]<br></code></pre></td></tr></table></figure>\n<p>通过  <code>watch</code>  监控键，如果在命令入队时，该键的值发生了改变，那么事务不会执行，当你调用  <code>exec</code>  后，事务将返回  <code>nil</code>  并退出事务状态。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">127.0.0.1:6379&gt; get k #k当前的值发生了改变<br>&quot;4&quot;<br>127.0.0.1:6379&gt; watch k #监控k<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; incr k #此时，另一个客户端修改了k的值为5<br>QUEUED<br>127.0.0.1:6379(TX)&gt; set k1 qweasd<br>QUEUED<br>127.0.0.1:6379(TX)&gt; exec #执行事务后，发现返回nil<br>(nil)<br>127.0.0.1:6379&gt; get k1 #发现所有键的值都没有被事务所修改<br>&quot;hello&quot;<br>127.0.0.1:6379&gt; get k<br>&quot;5&quot;<br></code></pre></td></tr></table></figure>\n<p>如果你在监控了某个键后，不想再监控了，可以使用  <code>unwatch</code>  命令来取消监控。该命令没有任何参数，将会取消监控所有的键。</p>\n<h1 id=\"管道\"><a class=\"markdownIt-Anchor\" href=\"#管道\">#</a> 管道</h1>\n<p><code>Redis</code>  是一种基于<strong>客户端 - 服务端模型</strong>以及<strong>请求 / 响应协议</strong>的 TCP 服务。一个请求会遵循以下步骤：</p>\n<ol>\n<li>客户端向服务端发送命令分四步 (发送命令→命令排队→命令执行→返回结果)，并监听  <code>Socket</code>  返回，通常以阻塞模式等待服务端响应。</li>\n<li>服务端处理命令，并将结果返回给客户端。</li>\n</ol>\n<p>如果同时需要执行大量的命令，那么就要等待上一条命令应答后再执行，这中间不仅仅多了<strong> RTT（Round Time Trip）</strong>，而且还频繁调用系统 IO，发送网络请求，同时需要  <code>redis</code>  调用多次  <code>read()</code>  和  <code>write()</code>  系统方法，系统方法会将数据从<strong>用户态</strong>转移到<strong>内核态</strong>，这样就会对进程上下文有比较大的影响了，性能不太好。</p>\n<p>管道用来优化客户端和服务端的<strong>网络时延 (RTT)</strong>。</p>\n<p><code>管道(pipeline)</code>  可以一次性发送多条命令给服务端，服务端依次处理完完毕后，通过一条响应一次性将结果返回，通过减少客户端与  <code>redis</code>  的通信次数来实现降低往返延时时间。 <code>pipeline</code>  实现的原理是队列，先进先出特性就保证数据的顺序性。</p>\n<h1 id=\"主从复制\"><a class=\"markdownIt-Anchor\" href=\"#主从复制\">#</a> 主从复制</h1>\n<p><code>redis</code>  提供一个主从复制机制。<strong>主 (master) 库</strong> 能够进行读写，<strong>从 (slave) 库</strong> 只能读。当  <code>master</code>  数据变化的时候，自动将新的数据异步同步到其它  <code>slave</code>  数据库，保证主从之间的数据保持一致性。</p>\n<h2 id=\"配置\"><a class=\"markdownIt-Anchor\" href=\"#配置\">#</a> 配置</h2>\n<p>通过修改从库的配置，标识从库要复制的是哪个主库。前往配置文件大概 553 行：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\"># replicaof <span class=\"hljs-string\">&lt;masterip&gt;</span> <span class=\"hljs-string\">&lt;masterport&gt;</span></span><br></code></pre></td></tr></table></figure>\n<p>通过配置  <code>relicaof</code>  的参数  <code>masterip</code>  主库的  <code>ip</code>  ， <code>masterport</code>  主库的端口</p>\n<p>如果主库被设置了密码，那么需要修改另一个配置，前往配置文件大概 554 行：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\"># masterauth <span class=\"hljs-string\">&lt;master-password&gt;</span></span><br></code></pre></td></tr></table></figure>\n<p>通过配置  <code>masterauth</code>  的参数  <code>master-password</code>  指明主库的密码，从而能被验证通过。</p>\n<p>除上述配置之外，主库的配置文件不需要任何修改。</p>\n<h2 id=\"连接主库\"><a class=\"markdownIt-Anchor\" href=\"#连接主库\">#</a> 连接主库</h2>\n<p>我们使用一个主库，然后再使用两个从库。使整个架构呈现出：一个主库下面挂着三个从库的状态。</p>\n<p>假设我们的主库的套接字为：172.17.0.2:6376。从库的套接字为：172.17.0.3:6377、172.17.0.4:6378。密码都为：12345</p>\n<p>所以从库的配置文件呈现如下情况：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">172.17.0.3:6377</span><br>replicaof 172.0.2 6376<br>masterauth 12345<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">172.17.0.4:6378</span><br>replicaof 172.0.2 6376<br>masterauth 12345<br></code></pre></td></tr></table></figure>\n<p>为了更好的观察运行情况，我们对上述三个库，继续修改如下配置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">以下配置路径均可以自定义</span><br>dir /usr/local/etc/redis #设置工作目录<br>log /usr/local/etc/redis/redis.log #设置日志路径<br>pid /usr/local/etc/redis/redis.pid #设置pid文件路径<br>appendonly no #关闭AOF持久化，可关可不关<br></code></pre></td></tr></table></figure>\n<p>配置完成后，我们首先启动主库，观察之前配置的日志文件，如果出现以下日志，说明启动成功：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">Ready to <span class=\"hljs-keyword\">accept</span> connections tcp<br></code></pre></td></tr></table></figure>\n<p>随后，我们启动剩余两个从库，从库启动成功后会尝试连接主库，出现以下日志说明连接成功：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">Connecting <span class=\"hljs-keyword\">to</span> MASTER <span class=\"hljs-number\">172.17</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.2</span>:<span class=\"hljs-number\">6376</span><br>MASTER &lt;-&gt; <span class=\"hljs-keyword\">REPLICA</span> sync started<br></code></pre></td></tr></table></figure>\n<p>如果你想查看当前  <code>redis</code>  实例的主从状态，可以使用如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">info replication<br></code></pre></td></tr></table></figure>\n<p>该命令会显示当前  <code>redis</code>  实例处于的主从状态，如果是主库，那么也会显示当前主库挂载了哪些从库。</p>\n<h3 id=\"手动配置\"><a class=\"markdownIt-Anchor\" href=\"#手动配置\">#</a> 手动配置</h3>\n<p>上面的配置均基于配置文件，在  <code>redis</code>  服务启动后，也可以手动配置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">slaveof &lt;masterip&gt; &lt;masterport&gt;<br></code></pre></td></tr></table></figure>\n<p><code>slaveof</code>  命令对标  <code>replicaof</code>  配置。可以在运行时进行配置。</p>\n<blockquote>\n<p>注意：如果主库仍然含有密码，仍需要在配置文件中配置  <code>masterauth</code></p>\n</blockquote>\n<p>如果，你想要在运行时让从库变为主库同样可以使用  <code>slaveof</code> ：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">slaveof no one<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>注意手动配置仅仅在当此运行中有效，重新启动服务后，任然会使用配置文件的配置</p>\n</blockquote>\n<h2 id=\"同步\"><a class=\"markdownIt-Anchor\" href=\"#同步\">#</a> 同步</h2>\n<p>尝试在主库中写入一些键，观察从库的状态。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">127.0.0.1:6376&gt; set k1 v1 #我们在从库中设置一个数据<br>OK <br>127.0.0.3:6377&gt; get k1 #切换至从库，获取改键，发现能够获取，且值和主库中的对应<br>&quot;v1&quot;<br><br>127.0.0.3:6377&gt; set k2 v2 #尝试在从库中进行写入，发现报错无法写入<br>(error) READONLY You can&#x27;t write against a read only replica.<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>从库没有写入的权力</p>\n</blockquote>\n<p>如果运行时，主库宕机了怎么办？我们尝试  <code>shutdown</code>  主库，观察从库的日志：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">Connecting <span class=\"hljs-keyword\">to</span> MASTER <span class=\"hljs-number\">172.17</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.2</span>:<span class=\"hljs-number\">6376</span><br>MASTER &lt;-&gt; <span class=\"hljs-keyword\">REPLICA</span> sync started<br>Error condition <span class=\"hljs-keyword\">on</span> socket <span class=\"hljs-keyword\">for</span> SYNC: <span class=\"hljs-keyword\">Connection</span> refused<br></code></pre></td></tr></table></figure>\n<p>你会看到一场串的上面的内容，代表着当主库宕机后，从库其实一直在尝试连接主库。意味着，从库在主库宕机后选择发呆，什么事也不干，<strong>也不会从从库变为主库</strong>，只是一味请求连接主库。同时如果你在从库查看数据，同步之后的数据任然存在。</p>\n<p>那此时的主库重启后仍然为主库吗？答案是，仍然是！</p>\n<p>如果从库宕机后，我们持续向主库中写入数据，从库再次启动后能否同步到主库的新数据？答案是也会！</p>\n<h3 id=\"同步链\"><a class=\"markdownIt-Anchor\" href=\"#同步链\">#</a> 同步链</h3>\n<p>上一个  <code>slave</code>  可以是下一个  <code>slave</code>  的  <code>master</code> ,  <code>slave</code>  同样可以接收其他  <code>slave</code>  的连接和同步请求，那么该  <code>slave</code>  作为了链条中下一个的  <code>master</code> , 可以有效减轻主  <code>master</code>  的写压力形成同步链。</p>\n<p>可以在配置文件中直接配置  <code>replicaof</code>  或者在运行中使用  <code>slaveof</code>  来暂时设置。</p>\n<h3 id=\"原理-2\"><a class=\"markdownIt-Anchor\" href=\"#原理-2\">#</a> 原理</h3>\n<ol>\n<li>当主从库连接良好时，主库会向从库发送命令流来同步由于以下原因导致主库数据集发生改变的影响</li>\n</ol>\n<ul>\n<li>客户端写入</li>\n<li>键过期或者删除</li>\n<li>更改主库数据集的任何其他操作，例如： <code>flushdb</code></li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>当主从库因为网络问题或者命令流发送超时导致连接丢失后，从库会进行重连并尝试进行部分的重新同步：意味着从库会尝试获取一部分它在失去连接中丢失的命令流</p>\n</li>\n<li>\n<p>当部分重新同步不可能时， <code>slave</code>  将请求完全重新同步，其中主服务器需要创建所有的数据快照，将其发送到从库，然后在数据集发生变化时继续发送命令流。</p>\n</li>\n</ol>\n<p>每个主库都有一个 复制 ID ，这是一个超大伪随机的字符串用来标记一个给定数据集的状况。每个主库也拥有一个发送给从库且随着复制流字节增长的偏移量，使用主库的改变用来更新从库的状态。主库的偏移量在从库没有连接时也存在，下面给出的就是主库数据集版本的标识。</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">Replication</span> ID, <span class=\"hljs-keyword\">offset</span><br></code></pre></td></tr></table></figure>\n<p>当从库连接至主库后，从库会使用  <code>PSYNC</code>  命令用来发送他的旧主库的复制 ID 以及最近处理的的偏移量。这样主设备就可以只发送所需的增量部分。但是，如果主库缓冲区没有足够的  <code>backlog</code>  或者从库正在参考的是一个历史的从来不知道的复制 ID，然后就会发生全量的重新同步：在这个情况下，从库会获得全量的数据集的复制。</p>\n<p>全量的重新同步的细节如下：</p>\n<p>主库会启动一个后台保存进程生产  <code>RDB</code>  文件。同一时间，主库会开始缓存所有新收到的写命令。当后台保存完成后，主库会将数据库文件传输给从库，然后从库会将文件保存在硬盘上之后将它加载进内存。然后主库会发送所有缓存的命令到从库。这是以命令流的形式发送的。</p>\n<p>主库会使用心跳机制，默认每 10s 钟和从库进行通信保持长连接。</p>\n<h2 id=\"缺点\"><a class=\"markdownIt-Anchor\" href=\"#缺点\">#</a> 缺点</h2>\n<p>由于所有的写操作都是先在  <code>Master</code>  上操作，然后同步更新到  <code>Slave</code>  上，所以从  <code>Master</code>  同步到  <code>Slave</code>  机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重， <code>Slave</code>  机器数量的增加也会使这个问题更加严重。</p>\n<p>默认情况下，当  <code>master</code>  宕机后，不会在引  <code>slave</code>  节点中自动重选一个  <code>master</code> ，这意味着，你无法进行写入。</p>\n<h1 id=\"哨兵\"><a class=\"markdownIt-Anchor\" href=\"#哨兵\">#</a> 哨兵</h1>\n<p>为了解决主从复制的痛点 ——  <code>master</code>  宕机后， <code>slave</code>  中并不会产生一个  <code>master</code>  来进行写入。吹哨人巡查监控后台  <code>master</code>  主机是否故障，如果故障了根据投票数自动将某一个从库转换为新主库，继续对外服务。</p>\n <img src=\"redis/sentinel.png\" alt=\"哨兵架构\" style=\"zoom: 50%;\" />\n<blockquote>\n<p>哨兵是在非集群状态下使用的</p>\n</blockquote>\n<p>以下是哨兵提供的一系列功能：</p>\n<ul>\n<li><strong>监控</strong>：哨兵能持续不断地检查  <code>master</code>  和  <code>slave</code>  是否如期运行</li>\n<li><strong>通知</strong>：哨兵能通过  <code>API</code>  通知系统管理员，或者其他电脑程序，某一个被监控的  <code>redis</code>  实例出问题了</li>\n<li><strong>自动的故障转移</strong>：如果  <code>master</code>  宕机了，哨兵会开始故障转移进程，将  <code>slave</code>  提拔为  <code>master</code>  ，其他的额外的  <code>slave</code>  将会被<strong>重新配置</strong>以使用新的  <code>master</code>  ，并且使用  <code>reids</code>  服务器的应用程序会在连接中被通知使用新的地址</li>\n<li><strong>配置提供者</strong>：哨兵充当客户端服务发现的权威来源，客户端连接到哨兵以询问负责给定服务的  <code>master</code>  的地址。如果发生故障转移，哨兵将报告新地址。</li>\n</ul>\n<blockquote>\n<p>哨兵在进行故障转移时，会动态的修改配置文件</p>\n</blockquote>\n<h2 id=\"哨兵架构\"><a class=\"markdownIt-Anchor\" href=\"#哨兵架构\">#</a> 哨兵架构</h2>\n<p><code>reids</code>  的哨兵是<strong>分布式系统</strong>。哨兵被设计来以<strong>多个哨兵进程共同合作</strong>的配置运行。这样的好处有如下：</p>\n<ol>\n<li>当多个哨兵都认同某个给定的  <code>master</code>  已经宕机，那么故障检测将会被执行。这降低了<strong>假阳性</strong>的可能性，也就是误判  <code>master</code>  宕机。</li>\n<li>在所有的哨兵进程没有完全停止工作时哨兵也能发挥作用，这提高了对抗故障的<strong>健壮性</strong></li>\n</ol>\n<blockquote>\n<p>哨兵、 <code>Redis</code>  实例（ <code>master</code>  和  <code>slave</code> ）以及连接到哨兵 和  <code>Redis</code>  的客户端的总和，也是一个具有特定属性的更大的分布式系统</p>\n</blockquote>\n<h2 id=\"如何运行哨兵实例\"><a class=\"markdownIt-Anchor\" href=\"#如何运行哨兵实例\">#</a> 如何运行哨兵实例</h2>\n<p>你可以使用  <code>redis</code>  提供的命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-sentinel /path/to/sentinel.conf<br></code></pre></td></tr></table></figure>\n<p>也可以同样使用  <code>redis-server</code>  命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-server /path/to/sentinel.conf --sentinel<br></code></pre></td></tr></table></figure>\n<p>哨兵被<strong>强制使用配置文件</strong>，无法默认运行，因为该文件会被系统使用，用来保存当前的状态，并且会在重新启动时被重新加载。如果没有给出配置文件或者配置文件路径不可写，哨兵将简单地拒绝启动。</p>\n<p>哨兵运行<strong>默认监听端口 26379</strong>，所以为了保证能够运行，必须让你的服务器打开<strong> 26379 端口</strong>。否则，哨兵们将不能交流并且也无法就该做什么达成一致，所以故障转义将不会被执行。</p>\n<h3 id=\"配置哨兵文件\"><a class=\"markdownIt-Anchor\" href=\"#配置哨兵文件\">#</a> 配置哨兵文件</h3>\n<p><code>Redis</code>  源代码发行版包含一个名为  <code>Sentinel.conf</code>  的文件，它是一个自记录示例配置文件，可用于配置  <code>Sentinel</code> ，但是典型的最小配置文件如下所示：</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs smali\">sentinel<span class=\"hljs-built_in\"> monitor </span>mymaster 127.0.0.1 6379 2<br>sentinel down-after-milliseconds mymaster 60000<br>sentinel failover-timeout mymaster 180000<br>sentinel parallel-syncs mymaster 1<br><br>sentinel<span class=\"hljs-built_in\"> monitor </span>resque 192.168.1.3 6380 4<br>sentinel down-after-milliseconds resque 10000<br>sentinel failover-timeout resque 180000<br>sentinel parallel-syncs resque 5<br></code></pre></td></tr></table></figure>\n<p>您只需要指定要监视的  <code>master</code> ，为每个单独的  <code>master</code> （可能有任意数量的 <code>slave</code> ）提供不同的名称，无需指定  <code>slave</code> ， <code>slave</code>  是自动发现的。 哨兵将使用有关 <code>slave</code>  的附加信息自动更新配置（以便在重新启动时保留信息），每次在故障转移期间将  <code>slave</code>  提升为  <code>master</code>  以及每次发现新的哨兵时，配置也会被重写</p>\n<p>上面的示例配置基本上监视两组  <code>Redis</code>  实例，每个实例由一个主实例和未定义数量的  <code>slave</code>  组成。一组实例称为  <code>mymaster</code> ，另一组实例称为  <code>resque</code></p>\n<p><code>sentinel monitor</code>  语句的参数含义如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;<br></code></pre></td></tr></table></figure>\n<p>让我们一行一行检查：</p>\n<p>第一行用于告诉  <code>Redis</code>  监视一个名为  <code>mymaster</code>  的主机，该主机位于地址  <code>127.0.0.1</code>  和端口  <code>6379</code> ，投票数 ( <code>quorum</code> ) 为 2。一切都非常明显，但<strong> quorum 参数</strong>除外：</p>\n<ul>\n<li>\n<p>投票数是需要就  <code>master</code>  无法访问这一事实达成一致的哨兵数量，以便真正将主站标记为故障，并在可能的情况下最终启动故障转移过程</p>\n</li>\n<li>\n<p>然而，投票数仅用于检测故障。为了实际执行故障转移，需要选举其中一个哨兵为故障转移的领导者并被授权继续进行。只有大多数哨兵进程投票才会发生这种情况</p>\n</li>\n</ul>\n<p>例如，如果您有 5 个 哨兵进程，并且给定  <code>master</code>  进程的投票数设置为 2，则会发生以下情况：</p>\n<ul>\n<li>如果两个哨兵同时同意主节点无法访问，则两者之一将尝试启动故障转移</li>\n<li>如果总共至少有三个哨兵可达，则故障转移将被授权并实际启动</li>\n</ul>\n<blockquote>\n<p>实际上，这意味着在故障期间，如果大多数哨兵进程无法通信（也称为少数分区中没有故障转移），则哨兵永远不会启动故障转移</p>\n</blockquote>\n<p>除了上述配置之外，其余的哨兵配置遵从与以下格式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sentinel &lt;option_name&gt; &lt;master_name&gt; &lt;option_value&gt;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</code> ：是当哨兵开始认为实例<strong>主观下线</strong>时，实例不应该可达的时间（要么不回复我们的  <code>PING</code> ，要么回复错误）</li>\n<li><code>parallel-syncs &lt;master-name&gt; &lt;nums&gt;</code> ：设置故障转移后可以重新配置为同时使用新  <code>master</code>  的  <code>slave</code>  数量。数字越低，完成故障转移过程所需的时间越长。</li>\n<li><code>auth-pass &lt;master-name&gt; &lt;password&gt;</code> ： <code>master</code>  设置了密码，连接  <code>master</code>  服务的密码</li>\n</ul>\n<p>其余的可参照实例配置文件： <code>sentinel.conf</code></p>\n<blockquote>\n<p><code>redis</code>  官方建议配置至少三个哨兵</p>\n</blockquote>\n<h2 id=\"主观下线和客观下线\"><a class=\"markdownIt-Anchor\" href=\"#主观下线和客观下线\">#</a> 主观下线和客观下线</h2>\n<p><code>redis</code>  哨兵有两种下下线的判断：客观下线 (ODOWN) 和主观下线 (SDOWN)</p>\n<ul>\n<li>主观下线 (SDOWN)：单独一个哨兵认为  <code>master</code>  已经下线，这种情况由于， <code>master</code>  没有在有效的时间正确回应哨兵的  <code>PING</code>  命令。这个时间在配置文件中是  <code>is-master-down-after-milliseconds</code>  参数。\n<ul>\n<li>仅仅通过  <code>SDOWN</code>  无法判断  <code>master</code>  是否下线。需要哨兵之间进行投票。</li>\n</ul>\n</li>\n<li>客观下线 (ODOWN)：当哨兵之间的投票数达到之前设定的  <code>quorm</code>  时， <code>master</code>  进入客观下线状态。触发故障转移。</li>\n</ul>\n<h2 id=\"故障转移流程\"><a class=\"markdownIt-Anchor\" href=\"#故障转移流程\">#</a> 故障转移流程</h2>\n<ol>\n<li>主观下线</li>\n<li>客观下线</li>\n<li>选出领导者哨兵：当主节点被判断客观下线以后，各个哨兵节会进行协商，通过  <code>raft</code>  算法 先选举出一个领导者 (leader) 哨兵节点并由该领导者节点，也即被选举出的兵王进行  <code>failover</code>  (故障转移）</li>\n<li>由领导者 (leader) 开始推动故切流程并选出一个新  <code>master</code> ：\n<ol>\n<li>在剩下的  <code>slave</code>  中选出一个  <code>master</code>  , 从节点选举过程评估从节点的下列信息来选举  <code>master</code> ：\n<ul>\n<li>与主节点断开的时间</li>\n<li>从节点优先级：由  <code>replica-priority</code>  参数指定，越低的优先级越高，但该参数指定为 0 时，该节点将不会参与选举。</li>\n<li>复制偏移处理：更新的偏移量越优先</li>\n<li>运行 ID</li>\n</ul>\n</li>\n<li>切换剩下的  <code>slave</code>  至新的  <code>master</code> ：\n<ul>\n<li>执行  <code>slaveof no one</code>  命令让选出来的从节成为新的主节点，并通过  <code>slaveof</code>  命令让其他节点成为其从节点</li>\n<li>会修改  <code>slave</code>  以及  <code>sentinel</code>  的配置文件</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>此时，若旧的  <code>master</code>  重新上线，仍然会成为新选举出来的  <code>master</code>  的  <code>slave</code></li>\n</ol>\n<h1 id=\"集群\"><a class=\"markdownIt-Anchor\" href=\"#集群\">#</a> 集群</h1>\n<h2 id=\"为什么要使用-redis-集群\"><a class=\"markdownIt-Anchor\" href=\"#为什么要使用-redis-集群\">#</a> 为什么要使用 redis 集群</h2>\n<p>使用主从复制 + 哨兵的模式能够很大程度上减轻   <code>redis</code>   的读写压力，但归根结底，此模式仍有不足：</p>\n<ul>\n<li>接受请求的服务器从始至终只有一台   <code>redis</code>  实例，无法适应高并发的场景。</li>\n<li>从节点的上位可能会导致写丢失。</li>\n</ul>\n<h2 id=\"什么是redis集群\"><a class=\"markdownIt-Anchor\" href=\"#什么是redis集群\">#</a> 什么是 redis 集群</h2>\n<p>由于数据量过大，单个   <code>master</code>  复制集难以承担，因此需要对多个复制集进行集群，形成水平扩展每个复制集只负责存储整个数据集的一部分，这就是  <code>Redis</code>  的集群，其作用是提供在多个  <code>Redis</code>  节点间共享数据的程序集。</p>\n<p>形象的图像表示如下图：</p>\n<p><img src=\"/upload/cluster.png\" alt=\"cluster.png\" title=\"cluster架构\"></p>\n<p>当客户端请求来到  <code>redis</code>  服务之后，将会根据规则将请求分散至不同的  <code>redis</code>  实例中，以减少每台服务器的压力。每台   <code>redis</code>  服务器仅仅存储数据集的一部分，且  <code>redis</code>   服务间数据共享。</p>\n<h2 id=\"如何确定键的落点\"><a class=\"markdownIt-Anchor\" href=\"#如何确定键的落点\">#</a> 如何确定键的落点</h2>\n<p><code>redis</code>  通过哈希的方式找到键的落点。下面我们一一介绍常见的哈希方式以及  <code>redis</code>   最终的使用方案。</p>\n<h3 id=\"普通哈希\"><a class=\"markdownIt-Anchor\" href=\"#普通哈希\">#</a> 普通哈希</h3>\n<p>通过简单的哈希函数来确定键的落点。例如，现在我有三个实例：A、B、C 组成了一个集群。那么，可能的哈希函数就可能如下所示：</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mathematica\"><span class=\"hljs-variable\">RES</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">KEY</span> <span class=\"hljs-operator\">%</span> <span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n<p>通过键对 3 取余得到键的落点在哪个实例上。这样的方法看似非常简单且稳妥。但实际上却有很大的弊端：当其中某个实例宕机或者新加入一些实例后，哈希函数将会发生改变，之前的键的映射方式将会重新洗牌，将会有大量的键无法映射到对应的  <code>redis</code>   的服务上。</p>\n<h3 id=\"一致性哈希\"><a class=\"markdownIt-Anchor\" href=\"#一致性哈希\">#</a> 一致性哈希</h3>\n<p>一致性哈希是为了解决普通哈希带来的问题 —— 当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系。一致性哈希算法将整个哈希值空间映射成一个虚拟的圆环。整个哈希空间的取值范围为 0~2<sup>32-1，按顺时针方向开始从 0~2</sup>32-1 排列，最后的节点 2^32-1 在 0 开始位置重合，形成一个虚拟的圆环。如下图所示：</p>\n<p><img src=\"/upload/consistency-hash.png\" alt=\"consistency-hash.png\" title=\"一致性哈希环\"></p>\n<h5 id=\"服务器映射到哈希环\"><a class=\"markdownIt-Anchor\" href=\"#服务器映射到哈希环\">#</a> 服务器映射到哈希环</h5>\n<p>接下来，将服务器节点映射到哈希环上对应的位置。我们可以对服务器 IP 地址进行哈希计算，哈希计算后的结果对 2<sup>32 取模，结果一定是一个 0 到 2</sup>32-1 之间的整数。最后将这个整数映射在哈希环上，整数的值就代表了一个服务器节点的在哈希环上的位置。即：hash（服务器 ip）% 2^32。下面我们依次将 node0、node1、node2 三个缓存服务器映射到哈希环上，如下图所示：</p>\n<p><img src=\"/upload/consistency-hash-node.png\" alt=\"consistency-hash-node.png\"></p>\n<h5 id=\"对象key映射到服务器\"><a class=\"markdownIt-Anchor\" href=\"#对象key映射到服务器\">#</a> 对象 key 映射到服务器</h5>\n<p>当服务器接收到数据请求时，首先需要计算请求 Key 的哈希值；然后将计算的哈希值映射到哈希环上的具体位置；接下来，从这个位置沿着哈希环顺时针查找，遇到的第一个节点就是 key 对应的节点；最后，将请求发送到具体的服务器节点执行数据操作。</p>\n<p>假设我们有 “key-01：张三”、“key-02：李四”、“key-03：王五” 三条缓存数据。经过哈希算法计算后，映射到哈希环上的位置如下图所示：</p>\n<p><img src=\"/upload/consistency-hah-map.png\" alt=\"consistency-hah-map.png\"></p>\n<p>如上图所示，通过哈希计算后，key-01 顺时针寻找将找到 node0，key-02 顺时针寻找将找到 node1，key-03 顺时针寻找将找到 node2。最后，请求找到的服务器节点执行具体的业务操作。</p>\n<p>以上便是一致性哈希算法的工作原理。</p>\n<h4 id=\"服务器扩容缩容\"><a class=\"markdownIt-Anchor\" href=\"#服务器扩容缩容\">#</a> 服务器扩容 &amp; 缩容</h4>\n<p>前面介绍了一致性哈希算法的工作原理，那么，一致性哈希算法如何避免服务器动态伸缩的问题的呢？</p>\n<h5 id=\"服务器缩容\"><a class=\"markdownIt-Anchor\" href=\"#服务器缩容\">#</a> 服务器缩容</h5>\n<p>服务器缩容就是减少集群中服务器节点的数量或是集群中某个节点故障。假设，集群中的某个节点故障，原本映射到该节点的请求，会找到哈希环中的下一个节点，数据也同样被重新分配至下一个节点，其它节点的数据和请求不受任何影响。这样就确保节点发生故障时，集群能保持正常稳定。如下图所示：</p>\n<p><img src=\"/upload/consistency-hash-reduce.png\" alt=\"consistency-hash-reduce.png\"></p>\n<p>如上图所示：节点 node2 发生故障时，数据 key-01 和 key-02 不会受到影响，只有 key-03 的请求被重定位到 node0。在一致性哈希算法中，如果某个节点宕机不可用了，那么受影响的数据仅仅是会寻址到此节点和前一节点之间的数据。其他哈希环上的数据不会受到影响。</p>\n<h5 id=\"服务器扩容\"><a class=\"markdownIt-Anchor\" href=\"#服务器扩容\">#</a> 服务器扩容</h5>\n<p>服务器扩容就是集群中需要增加一个新的数据节点，假设，由于需要缓存的数据量太大，必须对集群进行扩容增加一个新的数据节点。此时，只需要计算新节点的哈希值并将新的节点加入到哈希环中，然后将哈希环中从上一个节点到新节点的数据映射到新的数据节点即可。其他节点数据不受影响，具体如下图所示：</p>\n<p><img src=\"/upload/consistency-hash-scall.png\" alt=\"consistency-hash-scall.png\"></p>\n<p>如上图所示，加入新的 node3 节点后，key-01、key-02 不受影响，只有 key-03 的寻址被重定位到新节点 node3，受影响的数据仅仅是会寻址到新节点和前一节点之间的数据。</p>\n<p>通过一致性哈希算法，集群扩容或缩容时，只需要重新定位哈希环空间内的一小部分数据。其他数据保持不变。当节点数越多的时候，使用哈希算法时，需要迁移的数据就越多，使用一致哈希时，需要迁移的数据就越少。所以，一致哈希算法具有较好的容错性和可扩展性。</p>\n<h4 id=\"缺点-2\"><a class=\"markdownIt-Anchor\" href=\"#缺点-2\">#</a> 缺点</h4>\n<p>一致性哈希也并不是那么完美，它有一个很致命的弱点 —— 数据倾斜。由于哈希计算的随机性，我们无法保证所有的节点都能完美地均匀地分散在哈希环上，特别是在节点太少的情况下，会导致大量的键会集中映射至少量几个节点的情况，造成数据访问的冷热不均，如下图所示：</p>\n<p><img src=\"/upload/consistency-hash-short.png\" alt=\"consistency-hash-short.png\"></p>\n<p>如上图所示，key-1、key-2、key-3 可能被映射到同一个节点 node0 上。导致 node0 负载过大，而 node1 和 node2 却很空闲的情况。这有可能导致个别服务器数据和请求压力过大和崩溃，进而引起集群的崩溃。</p>\n<h3 id=\"哈希槽\"><a class=\"markdownIt-Anchor\" href=\"#哈希槽\">#</a> 哈希槽</h3>\n<p>为了解决一致性哈希的数据倾斜问题， <code>redis</code>  使用了名为<strong>哈希槽</strong>的技术来实现集群。 <code>redis</code>  通过将键映射至<strong>哈希槽</strong>而不是节点来规避底层节点的变动带来的数据问题。使用如下的公式来计算哈希槽：</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mathematica\"><span class=\"hljs-type\">HASH_SLOT</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">CRC16</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">key</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-variable\">mod</span> <span class=\"hljs-number\">16384</span><br></code></pre></td></tr></table></figure>\n<p>通过  <code>CRC16</code>  算法计算  <code>key</code>  的哈希值，该哈希值总共有 16 位，也就是哈希值的范围为 0~65535。但在  <code>redis</code>  中哈希槽的个数被设定为 0~16383</p>\n<h4 id=\"分片\"><a class=\"markdownIt-Anchor\" href=\"#分片\">#</a> 分片</h4>\n<p>每个节点分配一定数量哈希槽，哈希槽被<strong>分片</strong>至集群中的节点上。也就是每个节点就是哈希槽的<strong>分片</strong>。</p>\n<p>假如，现在我有 A，B，C 三台节点并组成一个集群，三台机器的分片可能如下：</p>\n<ul>\n<li>节点 A 包含哈希槽 0~5500</li>\n<li>节点 B 包含哈希槽 5501 到 11000</li>\n<li>节点 C 包含哈希槽 11001 至 16383</li>\n</ul>\n<p>我们使用上面提到的哈希槽计算公式计算给定键的哈希槽，根据每个节点的分片将其分配至对应的节点上。</p>\n<p>哈希槽均匀地分布在各个节点上，这样数据倾斜问题就解决了。</p>\n<p>实际上，键的映射只和哈希槽有关。我们可以形象地将哈希槽和节点理解为：座位和教室的关系。</p>\n<p><strong>教室 (节点)<strong> 包含</strong>座位 (哈希槽)</strong>。同学 (键) 寻找的永远是座位，不管如何移动教室，同学最终只会根据其座位坐上他应在的位置上。只不过，座位可能会从属于不同的教室，即哈希槽位可能会从属于不同的节点。</p>\n<h5 id=\"优点\"><a class=\"markdownIt-Anchor\" href=\"#优点\">#</a> 优点</h5>\n<p>使用哈希槽的技术可以可以很方便地添加和移除节点。例如，现在有 A、B、C 三台节点，现在我向里面添加一个新的节点 D，那么我们只需要从 A、B、C 三个节点中移走部分的哈希槽至节点 D 即可。同样的，如果我移除节点 C，那么我们只需要将 C 的哈希槽移动到 A、B 节点上，一旦节点 C 的哈希槽空了，那么删除 C 即可。</p>\n<p>同时哈希槽的移动并不会停止集群对外服务，这意味着无论是修改分片占比还是移动哈希槽都不会让集群下线。</p>\n<h4 id=\"为什么使用16384个槽位\"><a class=\"markdownIt-Anchor\" href=\"#为什么使用16384个槽位\">#</a> 为什么使用 16384 个槽位</h4>\n<p>前面提到 CRC16 计算的哈希位数有 16 位，即范围为 0~65535，但   <code>redis</code>   只使用了 14 位，即哈希槽范围为 0~16383。为什么这样设计能？我目前的水平不足以理解背后的原因，但究其原因是因为：</p>\n<ul>\n<li>集群之间发送的心跳包包含  <code>redis</code>  所有的配置，包括哈希槽，且哈希槽占据心跳包的大部分空间，为了减小心跳包占用的带宽，所以缩小哈希槽的范围，14 位是折中的选择</li>\n<li>官方建议的集群节点数不超过 1000 个，所以不需要太大的哈希槽范围</li>\n</ul>\n<h2 id=\"集群配置参数\"><a class=\"markdownIt-Anchor\" href=\"#集群配置参数\">#</a> 集群配置参数</h2>\n<ul>\n<li><strong>cluster-enabled  <code>&lt;yes/no&gt;</code> </strong>：如果设置为 yes，那么这个配置文件所代表的  <code>redis</code>  实例将会支持集群。否则，该实例将会以普通的方式启动。</li>\n<li><strong>cluster-config-file  <code>&lt;filename&gt;</code> </strong>：设置集群的配置文件，该文件是无法写入的，集群节点会在每次配置改变时自动将配置持久化进该文件里，为了当重新启动时读取该文件。该文件会列举像是集群中的节点、他们的状态、持久化变量等等</li>\n<li><strong>cluster-node-timeout <milliseconds></strong>：</li>\n<li><strong>cluster-allow-reads-when-down</strong>  <code>&lt;yes/no&gt;</code> ：</li>\n</ul>\n<h2 id=\"创建集群\"><a class=\"markdownIt-Anchor\" href=\"#创建集群\">#</a> 创建集群</h2>\n<p>在创建集群之间，我们必须首先进行配置以让  <code>redis</code>  实例支持以集群模式运行。最小的配置如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">port 7000 #redis的端口<br>cluster-enabled yes #声明该实例支持集群模式<br>cluster-config-file nodes.conf #设置该实例的集群配置文件<br>cluster-node-timeout 5000 #超时时间<br>appendonly yes #支持AOF持久化<br></code></pre></td></tr></table></figure>\n<p>最小的集群必须至少含有 3 台   <code>master</code>  节点。官方推荐部署时，使用六台节点的集群，3 台   <code>master</code>  节点和 3 台   <code>slave</code>  节点。现在我们以这个场景进行创建集群的演示：</p>\n<h3 id=\"运行集群节点\"><a class=\"markdownIt-Anchor\" href=\"#运行集群节点\">#</a> 运行集群节点</h3>\n<p>首先我们必须让所有的在集群中工作的节点都支持以集群的模式运行。注意，此时不用单独配置主从复制的关系。 <code>redis</code>  会自动为我们搭建主从复制关系。我们规定 6 个节点的端口分别为：7000，7001，7002，7003，7004，7005。那么每个节点的配置文件的内容如下所示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">bind 0.0.0.0<br>daemonize yes<br>protected-mode no<br>port 7000 #端口自定<br>dir /usr/local/etc/redis #工作路径自定<br>logfile 7000.log #日志文件自定<br>pidfile 7000.pid #pid文件自定<br>appendonly yes<br>appendfilename &quot;7000.aof&quot; #aof文件前缀自定<br>masterauth 12345 #如果由密码，则必须配置该项，用于建立自从复制关系时的认证<br>requirepass 12345 #密码，可要可不要<br><br>cluster-enabled yes<br>cluster-config-file node-7000.conf #集群配置文件自定<br>cluster-node-timeout 5000<br></code></pre></td></tr></table></figure>\n<p>请确保每个节点都包含了属于该节点的配置文件。随后我们使用命令启动着 6 个节点：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-server /path/to/config.conf<br></code></pre></td></tr></table></figure>\n<p>启动完成后，你会在日志中发现下面这句话：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I&#x27;m 97a3a64667477371c4479320d683e4c8db5858b1<br></code></pre></td></tr></table></figure>\n<p><code>ID</code>  会在集群中被永久使用以代表唯一的实例名字。节点会使用  <code>ID</code>  来记住其他节点。随后你会在工作目录下，看见新创建的集群配置文件。</p>\n<h3 id=\"创建真正的集群\"><a class=\"markdownIt-Anchor\" href=\"#创建真正的集群\">#</a> 创建真正的集群</h3>\n<p>现在我们已经有了正在运行的实例了，现在你可以使用以下的命令来创建你的集群：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-cli -a &lt;password&gt; --cluster create &lt;ip&gt;:&lt;port&gt; [ip:port....] --cluster-replicas 1<br></code></pre></td></tr></table></figure>\n<p>这里使用的命令是 create，因为我们要创建一个新的集群。选项 --cluster-replicas 1 意味着我们希望为每个创建的主节点创建一个副本。其他参数是我想要用来创建新集群的实例的地址列表。</p>\n<p>redis-cli 将为一个配置提出建议。随机分配主从关系。输入 yes 接受建议的配置。集群将被配置并被加入。这意味着实例将被引导以相互通信。最后，如果一切顺利，您将看到如下消息：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-attr\">[OK]</span> <span class=\"hljs-attribute\">All</span> <span class=\"hljs-number\">16384</span> slots covered<br></code></pre></td></tr></table></figure>\n<p>现在你已经构建起三主三从的集群架构了。如果你这时候前往集群配置文件，你能观察到此时的配置文件已经被写入该集群的一些信息了。</p>\n<blockquote>\n<p><code>redis</code>  之间通信的端口默认为，port + 10000。</p>\n</blockquote>\n<h4 id=\"查看集群信息\"><a class=\"markdownIt-Anchor\" href=\"#查看集群信息\">#</a> 查看集群信息</h4>\n<p>现在你可以查看你之前创建好地集群的信息。我们可以从端口为 7000 的这台实例入手，通过以下命令进入客户端并查看节点的信息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-cli -a &lt;password&gt; -p 7000<br><br>127.0.0.1:7000&gt; info replication<br>127.0.0.1:7000&gt; cluster info<br>127.0.0.1:7000&gt; cluster slots<br></code></pre></td></tr></table></figure>\n<h3 id=\"读写\"><a class=\"markdownIt-Anchor\" href=\"#读写\">#</a> 读写</h3>\n<p>现在进入某一个实例尝试读写吧。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">redis-cli -c -p 7000</span><br>redis 127.0.0.1:7000&gt; set foo bar<br><span class=\"hljs-meta prompt_\">-&gt; </span><span class=\"language-bash\">Redirected to slot [12182] located at 127.0.0.1:7002</span><br>OK<br>redis 127.0.0.1:7002&gt; set hello world<br><span class=\"hljs-meta prompt_\">-&gt; </span><span class=\"language-bash\">Redirected to slot [866] located at 127.0.0.1:7000</span><br>OK<br>redis 127.0.0.1:7000&gt; get foo<br><span class=\"hljs-meta prompt_\">-&gt; </span><span class=\"language-bash\">Redirected to slot [12182] located at 127.0.0.1:7002</span><br>&quot;bar&quot;<br>redis 127.0.0.1:7002&gt; get hello<br><span class=\"hljs-meta prompt_\">-&gt; </span><span class=\"language-bash\">Redirected to slot [866] located at 127.0.0.1:7000</span><br>&quot;world&quot;<br></code></pre></td></tr></table></figure>\n<p><code>-c</code>  选项代表该客户端以集群模式连接服务端。你可能已经看见了上面结果的  <code>redirected</code>  提示且观察到客户端连接到的服务端发生了变化。下面我们来介绍一下。该提示信息被称为 ——Moved 重定向错误。每当客户端的请求被某个节点接受后，会计算键的哈希槽，当判断该哈希槽不属于该节点，则会查找哈希槽和节点的映射集。然后回复客户端，让其重定向至指定的节点。</p>\n<h3 id=\"重新分片\"><a class=\"markdownIt-Anchor\" href=\"#重新分片\">#</a> 重新分片</h3>\n<p>这个操作将会让某一个节点的的分片被重新划分。让其他节点的部分哈希槽移动至该节点，使用如下的命令进行重新分片：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-clit -a &lt;passowrd&gt; --cluster reshard &lt;ip&gt;:&lt;port&gt;<br></code></pre></td></tr></table></figure>\n<p>如果我们以端口为 7000 的节点为例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-cli -a &lt;password&gt; --cluster reshard 127.0.0.1:7000<br></code></pre></td></tr></table></figure>\n<p>你只需要指定这个集群的单个节点， <code>redis</code>  将会自动寻找剩余的节点。</p>\n<p>目前 redis-cli 只能在管理员支持下重新分片，你不能只是说将 5% 的槽从这个节点移动到另一个节点（但这实现起来非常简单）。所以它会一个问题开始。第一个问题是是您想要移动的哈希槽的个数：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">How many slots do you want to move (from 1 to 16384)?<br></code></pre></td></tr></table></figure>\n<p>当你确认后，会询问你接受这些哈希槽的   <code>master</code>  节点 ID：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">What is the receiving node ID? <br></code></pre></td></tr></table></figure>\n<p>当你执行分片时，该集群中的所有节点包括 ID 等一切信息均以展示，所以你可以直接从上方查阅。</p>\n<p>当你确认后，会继续询问你哈希槽来源的 IDs。你有两个选择：</p>\n<ul>\n<li><code>all</code> ：哈希槽来自于除该节点外的所有节点</li>\n<li>随着 node #1、node #2、node #3… 写入来源节点的 id，随后以  <code>done</code>  结束输入</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">Please enter all the source node IDs.<br>  Type &#x27;all&#x27; to use all the nodes as source nodes for the hash slots.<br>  Type &#x27;done&#x27; once you entered all the source nodes IDs.<br>Source node #1: 2280954adfacc87e6f776bcb2684ea1be1b46567<br>Source node #2: done<br><br></code></pre></td></tr></table></figure>\n<p>最后，会询问你是否执行重新分片：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">Do you want to proceed with the proposed reshard plan (yes/no)?<br></code></pre></td></tr></table></figure>\n<p>输入 yes 即可开始重新分片</p>\n<p>分片完成成后可以使用如下的命令检查节点的健康状态：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-cli -a &lt;password&gt; --cluster check &lt;ip&gt;:&lt;port&gt;<br></code></pre></td></tr></table></figure>\n<p>重新分片可以自动进行，无需以交互方式手动输入参数。这可以使用如下的命令行来实现：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-cli --cluster reshard &lt;host&gt;:&lt;port&gt; --cluster-from &lt;node-id&gt; --cluster-to &lt;node-id&gt; --cluster-slots &lt;number of slots&gt; --cluster-yes<br></code></pre></td></tr></table></figure>\n<h3 id=\"故障转移\"><a class=\"markdownIt-Anchor\" href=\"#故障转移\">#</a> 故障转移</h3>\n<p><code>redis</code>  集群不用使用哨兵的支持则可以自动触发故障转移。现在，尝试使某一台  <code>master</code>  宕机：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-cli -a &lt;password&gt; -p &lt;port&gt; shutdown<br></code></pre></td></tr></table></figure>\n<p>随后我们使用，如下命令查看其中一个节点：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-cli -a 12345 -p 7001 cluster nodes<br></code></pre></td></tr></table></figure>\n<p>可以发现指定的那台节点已经宕机。但仍有三台  <code>master</code>   节点。可以确定，从节点已经上位为主节点。</p>\n<p>现在让之前的主节点重新上线，仍然使用上面的命令可以发现，之前的宕机的主节点上线后变为从节点。</p>\n<h4 id=\"手动故障转移\"><a class=\"markdownIt-Anchor\" href=\"#手动故障转移\">#</a> 手动故障转移</h4>\n<p>如果你想手动切换主从节点的状态，可以使用如下命令，进行手动的故障转移：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-cli -a 12345 -p 7000 cluster failover<br></code></pre></td></tr></table></figure>\n<h3 id=\"添加新节点\"><a class=\"markdownIt-Anchor\" href=\"#添加新节点\">#</a> 添加新节点</h3>\n<p>添加一个新的主节点非常简单，你只需要添加一个空的节点，并且移动一些哈希槽到这个新的主节点。而添加一个从节点只需要告诉这个节点以从节点的身份启动，就能添加一个从节点。</p>\n<p>下面我们从添加主节点开始。</p>\n<h4 id=\"添加主节点\"><a class=\"markdownIt-Anchor\" href=\"#添加主节点\">#</a> 添加主节点</h4>\n<p>我们以端口为 7006 的节点为例子。（注意，你之前已经创建了以 7000 到 7 005 端口的共六个节点的集群。）现在请确保你已经按照之前的步骤，创建了一个端口为 7006 的   <code>redis</code>  配置文件。让我们启动他。</p>\n<p>当你启动完成后，你会发现该实例的集群配置文件只有它自己，是因为该节点还未加入原来的集群中，现在让我们使用下面的命令来加入他：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-cli -a &lt;password&gt; --cluster add-node &lt;ip&gt;:&lt;port&gt; &lt;ip&gt;:&lt;port&gt;<br></code></pre></td></tr></table></figure>\n<p>第一个参数代表着新加入集群的节点的套接字，第二个参数代表着集群中任意节点的套接字，用于标识新加入的节点加入的是哪个集群中。你只需要标识其中一个节点的套接字，其他的节点将会被自动寻找。</p>\n<p>现在你可以链接任何节点使用  <code>cluster nodes</code>  查看节点状况。你会发现，新加入的节点默认为主节点。</p>\n<h5 id=\"重新分片-2\"><a class=\"markdownIt-Anchor\" href=\"#重新分片-2\">#</a> 重新分片</h5>\n<p>当你将节点成功加入集群中后，该节点就能正确的将查询进行重定向，该新节点和其他的节点有如下的不同：</p>\n<ul>\n<li>该节点没有数据且没有被分配哈希槽</li>\n<li>因为该节点是没有分配哈希槽的主节点，所有该节点无法在从节点想提拔为主节点时参与选举</li>\n</ul>\n<p>所以现在可以使用如下的命令进行重新分片：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">reids-cli -a &lt;passowrd&gt; --cluster reshard &lt;ip&gt;:&lt;port&gt;<br></code></pre></td></tr></table></figure>\n<h4 id=\"添加从节点\"><a class=\"markdownIt-Anchor\" href=\"#添加从节点\">#</a> 添加从节点</h4>\n<p>添加从节点有两种途径，一种是像之前我们添加主节点那样，但是在末尾添加一个   <code>--cluster-slave</code>  参数：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-cli -a &lt;password&gt; --cluster add-node &lt;ip&gt;:&lt;port&gt; &lt;ip&gt;:&lt;port&gt; --cluster-slave<br><br></code></pre></td></tr></table></figure>\n<p>使用这个命令，我们并没有指定我们目标的主节点，所以  <code>redis-cli</code>  会随机挑选一个主节点。但是如果你想明确指定一个目标主节点你可以使用如下的命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-cli -a &lt;password&gt; --cluster add-node &lt;ip&gt;:&lt;port&gt; &lt;ip&gt;:&lt;port&gt; --cluster-slave --cluster-mster-id &lt;id&gt;<br></code></pre></td></tr></table></figure>\n<p>通过指定目标主节点的 id，我们可以指定我们想要的目标主节点。</p>\n<p>另外的一种方式就是，你可以先添加一个空的主节点，然后让他变成某个主节点的从节点，我们以端口为 7006 的节点为例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">127.0.0.1:7006&gt;cluster replicate &lt;id&gt;<br></code></pre></td></tr></table></figure>\n<p>参数 id 为某个主节点的 id。执行完这个命令后即可让该节点变为指定主节点的从节点</p>\n<h2 id=\"删除节点\"><a class=\"markdownIt-Anchor\" href=\"#删除节点\">#</a> 删除节点</h2>\n<p>使用如下命令删除一个节点：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">redis-cli -a &lt;passowrd&gt; --cluster del-node &lt;ip&gt;:&lt;port&gt; &lt;node-id&gt;<br></code></pre></td></tr></table></figure>\n<p>第一个参数代表着集群中的一个节点，用于寻找集群中的其他节点。第二个参数时你想要删除的那个节点。</p>\n<p>你能使用这个命令删除主从节点，但是如果你想删除一个主节点，请确保这个主节点是空的。如果这个主节点不是空的，你需要在删除前将这个节点上的所有数据重新分片至其他的节点上。</p>\n<p>其他的删除主节点的替代方法就是你可以进行手动的故障转移，当这个节点转换为从节点后即可删除。但显然的，这个方法并不会帮你减少主节点的数量，所以当你想减少主节点的数量时，重新分片是必要的。</p>\n<p>还有一个特殊的方法当你想移除一个的宕机的节点时，你不应该使用   <code>del-node </code>  命令因为他会尝试连接所有节点。所有你将会面对一个 —— <code>connection refused error</code>  (连接拒绝错误)，相反的，你应该使用如下的命令：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">redis-cli --cluster <span class=\"hljs-keyword\">call</span> <span class=\"hljs-symbol\">&lt;ip&gt;</span>:<span class=\"hljs-symbol\">&lt;port&gt;</span> cluster forget <span class=\"hljs-symbol\">&lt;node-id&gt;</span><br></code></pre></td></tr></table></figure>\n<p>这个命令将会在任何节点上执行  <code>cluster forget</code>  命令</p>\n<h2 id=\"hash-tag\"><a class=\"markdownIt-Anchor\" href=\"#hash-tag\">#</a> hash tag</h2>\n<p><code>hash tag</code>  用于将多个键分配至同一个哈希槽。这用于在集群中实现多键操作。</p>\n<p>为了实现  <code>hash tag</code>  ，键的哈希槽和其他的键的计算在某种情况下有细微的差别。如果一个键包含一个  <code>&quot;&#123;...&#125;</code> &quot; 那么只有  <code>&#123;</code>  和  <code>&#125;</code>  里的子串会被哈希，以获取哈希槽。但是也有可能会有大量的  <code>&#123;</code> 或} 出现。所以该算法被指定遵循以下规则：</p>\n<ul>\n<li>键包含一个  <code>&#123;</code></li>\n<li>并且有一个  <code>&#125;</code>  在  <code>&#123;</code>  右边</li>\n<li>有一个或多个字符在第一个  <code>&#123;</code>  和  <code>&#125;</code>  的中间</li>\n</ul>\n<p>第一个  <code>&#123;</code>  和  <code>&#125;</code>  的中间字符串会被哈希。</p>\n<p>例子：</p>\n<ul>\n<li>两个键，{user1000}.forllowing 和 {user1000}.forllowers 会被分配至一个哈希槽。因为只有唯一的字串 user1000 会被哈希</li>\n<li>键 foo {}{bar}，整个键会被哈希因为第一个  <code>&#123;</code>  和  <code>&#125;</code>  的中间没有字符</li>\n<li>键  <code>foo&#123;&#123;bar&#125;&#125;zap</code>  的字串  <code>&#123;bar</code>  会被哈希，因为这是一个在第一个  <code>&#123;</code>  和  <code>&#125;</code>  的中间的字符子串</li>\n<li>键   <code>foo&#123;bar&#125;&#123;zap&#125;</code>  的 子串  <code>bar</code>  会被哈希</li>\n<li>如果键以  <code>&#123;&#125;</code>  开头，则保证它作为一个整体进行哈希处理。当使用二进制数据作为键名时这很有用</li>\n</ul>\n",
            "tags": [
                "redis"
            ]
        }
    ]
}